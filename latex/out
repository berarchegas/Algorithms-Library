\documentclass[12pt, a4paper, twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}
\usepackage{comment}
\usepackage{datetime}
\usepackage[pdfusetitle]{hyperref}
\usepackage[all]{xy}
\usepackage{graphicx}
\addtolength{\parskip}{.5\baselineskip}

%aqui comeca o que eu fiz de verdade, o resto veio e eu to com medo de tirar
\usepackage{listings} %biblioteca pro codigo
\usepackage{color}    %deixa o codigo colorido bonitinho
\usepackage[landscape, left=1cm, right=1cm, top=1cm, bottom=2cm]{geometry} %pra deixar a margem do jeito que o brasil gosta

\definecolor{gray}{rgb}{0.4, 0.4, 0.4} %cor pros comentarios
%\renewcommand{\footnotesize}{\small} %isso eh pra mudar o tamanho da fonte do codigo
\setlength{\columnseprule}{0.2pt} %barra separando as duas colunas
\setlength{\columnsep}{15pt} %distancia do texto ate a barra

\lstset{ %opcoes pro codigo
breaklines=true,
keywordstyle=\color{blue},
commentstyle=\color{gray},
basicstyle=\footnotesize,
breakatwhitespace=true,
language=C++,
%frame=single, % nao sei se gosto disso ou nao
numbers=none,
rulecolor=\color{black},
showstringspaces=false
stringstyle=\color{blue},
tabsize=4,
basicstyle=\ttfamily\footnotesize, % fonte
literate={~} {$\sim$}{1} % ~ bonitinho
}

\title{[UFMG] Summergimurne?}
\author{Bruno Monteiro, Emanuel Silva e Bernardo Amorim}


\begin{document}
\twocolumn
\date{} %tira a data
\maketitle


\renewcommand{\contentsname}{√çndice} %troca o nome do indice para indice
\tableofcontents


%%%%%%%%%%%%%%%%%%%%
%
% Graph
%
%%%%%%%%%%%%%%%%%%%%

\section{Graph}

\subsection{Bellman Ford}
\begin{lstlisting}

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;

vector<array<int, 3>> v;
ll dist[MAXN];
int p[MAXN];
 
int main() { 
	ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	array<int, 3> a;

	// recebe aresta de a pra b com custo c
	for (int i = 0; i < m; i++) {
		cin >> a[0] >> a[1] >> a[2];
		v.push_back(a);
	}
	int x = -1;
	for (int i = 2; i <= n; i++) dist[i] = INF;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (dist[v[j][0]] + v[j][2] < dist[v[j][1]]) {
				dist[v[j][1]] = dist[v[j][0]] + v[j][2];
				p[v[j][1]] = v[j][0];
				if (i == n-1) x = v[j][1];
			}
		}
	}
	if (x == -1) cout << "NO\n";
	else {
		cout << "YES\n";
		for (int i = 0; i < n; i++) x = p[x];
		stack<int> ans;
		ans.push(x);
		for (int i = p[x]; i != x; i = p[i]) {
			ans.push(i);
		}
		ans.push(x);
		while (!ans.empty()) {
			cout << ans.top() << ' ';
			ans.pop();
		}
		cout << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{Dinic}
\begin{lstlisting}
// O(min(m * max_flow, n^2 m))
// Grafo com capacidades 1 -> O(sqrt(n)*m)
// INF ta pra int
struct dinic {
	const bool scaling = false;
	int lim;
	struct edge {
		int to, cap, rev, flow;
		bool res;
		edge(int to_, int cap_, int rev_, bool res_)
			: to(to_), cap(cap_), rev(rev_), flow(0), res(res_) {}
	};

	vector<vector<edge>> g;
	vector<int> lev, beg;
	ll F;
	dinic(int n) : g(n), F(0) {}

	void add(int a, int b, int c) {
		g[a].emplace_back(b, c, g[b].size(), false);
		g[b].emplace_back(a, 0, g[a].size()-1, true);
	}
	bool bfs(int s, int t) {
		lev = vector<int>(g.size(), -1); lev[s] = 0;
		beg = vector<int>(g.size(), 0);
		queue<int> q; q.push(s);
		while (q.size()) {
			int u = q.front(); q.pop();
			for (auto& i : g[u]) {
				if (lev[i.to] != -1 or (i.flow == i.cap)) continue;
				if (scaling and i.cap - i.flow < lim) continue;
				lev[i.to] = lev[u] + 1;
				q.push(i.to);
			}
		}
		return lev[t] != -1;
	}
	int dfs(int v, int s, int f = INF) {
		if (!f or v == s) return f;
		for (int& i = beg[v]; i < g[v].size(); i++) {
			auto& e = g[v][i];
			if (lev[e.to] != lev[v] + 1) continue;
			int foi = dfs(e.to, s, min(f, e.cap - e.flow));
			if (!foi) continue;
			e.flow += foi, g[e.to][e.rev].flow -= foi;
			return foi;
		}
		return 0;
	}
	ll max_flow(int s, int t) {
		for (lim = scaling ? (1<<30) : 1; lim; lim /= 2)
			while (bfs(s, t)) while (int ff = dfs(s, t)) F += ff;
		return F;
	}

	// arestas com fluxo
	vector<pii> flow_edges(int s, int t) {
		max_flow(s, t);
		vector<pii> ans;
		int n = g.size();
		for (int i = 0; i < n; i++) {
			for (auto edge : g[i]) {
				if (!edge.res && edge.flow) 
					ans.emplace_back(i, edge.to);
			}
		}
		return ans;
	}

	// arestas no min cut
	vector<pii> cut_edges(int s, int t) {
		max_flow(s, t);
		vector<pii> cut;
		vector<int> vis(g.size(), 0), st = {s};
		vis[s] = 1;
		while (st.size()) {
			int u = st.back(); st.pop_back();
			for (auto e : g[u]) if (!vis[e.to] and e.flow < e.cap)
				vis[e.to] = 1, st.push_back(e.to);
		}
		for (int i = 0; i < g.size(); i++) for (auto e : g[i])
			if (vis[i] and !vis[e.to] and !e.res) cut.emplace_back(i, e.to);
		return cut;
	}
};
\end{lstlisting}

\subsection{Dominator Tree - Kawakami}
\begin{lstlisting}
// build - O(n)
// dominates - O(1)
// c80920

// importante que os vertices sejam de 0 a n - 1
int n;

namespace d_tree {
	vector<int> g[MAXN];

	// The dominator tree
	// em alguns problemas vc usa o tamanho da arvore da source
	// ent vale lembrar que nem todos os vertices fazem parte da arvore da source
	// ent a dominator tree na real eh uma floresta
	vector<int> tree[MAXN];
	int dfs_l[MAXN], dfs_r[MAXN];

	// Auxiliary data
	vector<int> rg[MAXN], bucket[MAXN];
	int idom[MAXN], sdom[MAXN], prv[MAXN], pre[MAXN];
	int ancestor[MAXN], label[MAXN];
	vector<int> preorder;

	void dfs(int v) {
		static int t = 0;
		pre[v] = ++t;
		sdom[v] = label[v] = v;
		preorder.push_back(v);
		for (int nxt: g[v]) {
			if (sdom[nxt] == -1) {
				prv[nxt] = v;
				dfs(nxt);
			}
			rg[nxt].push_back(v);
		}
	}
	int eval(int v) {
		if (ancestor[v] == -1) return v;
		if (ancestor[ancestor[v]] == -1) return label[v];
		int u = eval(ancestor[v]);
		if (pre[sdom[u]] < pre[sdom[label[v]]]) label[v] = u;
		ancestor[v] = ancestor[u];
		return label[v];
	}
	void dfs2(int v) {
		static int t = 0;
		dfs_l[v] = t++;
		for (int nxt: tree[v]) dfs2(nxt);
		dfs_r[v] = t++;
	}
	void build(int s) {
		for (int i = 0; i < n; i++) {
			sdom[i] = pre[i] = ancestor[i] = -1;
			rg[i].clear();
			tree[i].clear();
			bucket[i].clear();
		}
		preorder.clear();
		dfs(s);
		if (preorder.size() == 1) return;
		for (int i = int(preorder.size()) - 1; i >= 1; i--) {
			int w = preorder[i];
			for (int v: rg[w]) {
				int u = eval(v);
				if (pre[sdom[u]] < pre[sdom[w]]) sdom[w] = sdom[u];
			}
			bucket[sdom[w]].push_back(w);
			ancestor[w] = prv[w];
			for (int v: bucket[prv[w]]) {
				int u = eval(v);
				idom[v] = (u == v) ? sdom[v] : u;
			}
			bucket[prv[w]].clear();
		}
		for (int i = 1; i < preorder.size(); i++) {
			int w = preorder[i];
			if (idom[w] != sdom[w]) idom[w] = idom[idom[w]];
			tree[idom[w]].push_back(w);
		}
		idom[s] = sdom[s] = -1;
		dfs2(s);
	}

	// Whether every path from s to v passes through u
	bool dominates(int u, int v) {
		if (pre[v] == -1) return 1; // vacuously true
		return dfs_l[u] <= dfs_l[v] && dfs_r[v] <= dfs_r[u];
	}
};
\end{lstlisting}

\subsection{Floyd Warshall}
\begin{lstlisting}

int n;
int dist[MAXN][MAXN];
 
void FW() {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            for (int k = 1; k <= n; k++) {
                dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);
            }
        }
    }
}
\end{lstlisting}

\subsection{Hungarian}
\begin{lstlisting}
// Resolve o problema de assignment (matriz n x n)
// Colocar os valores da matriz em 'a' (pode < 0)
// assignment() retorna um par com o valor do
// assignment minimo, e a coluna escolhida por cada linha
//
// O(n^3)
// 64c53e

template<typename T> struct hungarian {
	int n;
	vector<vector<T>> a;
	vector<T> u, v;
	vector<int> p, way;
	T inf;

	hungarian(int n_) : n(n_), u(n+1), v(n+1), p(n+1), way(n+1) {
		a = vector<vector<T>>(n, vector<T>(n));
		inf = numeric_limits<T>::max();
	}
	pair<T, vector<int>> assignment() {
		for (int i = 1; i <= n; i++) {
			p[0] = i;
			int j0 = 0;
			vector<T> minv(n+1, inf);
			vector<int> used(n+1, 0);
			do {
				used[j0] = true;
				int i0 = p[j0], j1 = -1;
				T delta = inf;
				for (int j = 1; j <= n; j++) if (!used[j]) {
					T cur = a[i0-1][j-1] - u[i0] - v[j];
					if (cur < minv[j]) minv[j] = cur, way[j] = j0;
					if (minv[j] < delta) delta = minv[j], j1 = j;
				}
				for (int j = 0; j <= n; j++)
					if (used[j]) u[p[j]] += delta, v[j] -= delta;
					else minv[j] -= delta;
				j0 = j1;
			} while (p[j0] != 0);
			do {
				int j1 = way[j0];
				p[j0] = p[j1];
				j0 = j1;
			} while (j0);
		}
		vector<int> ans(n);
		for (int j = 1; j <= n; j++) ans[p[j]-1] = j-1;
		return make_pair(-v[0], ans);
	}
};
\end{lstlisting}

\subsection{LCA}
\begin{lstlisting}

int dep[MAXN], tab[MAXL][MAXN];
vector<int> v[MAXN];

void dfs(int node, int pai = 0) {
    dep[node] = dep[pai] + 1;
    tab[0][node] = pai;
    for (int x : v[node]) {
        if (x != pai) dfs(x, node);
    }
}

void calcTab(int n) {
    for (int i = 1; i < MAXL; i++) {
        for (int j = 1; j <= n; j++) tab[i][j] = tab[i - 1][tab[i - 1][j]]; 
    }
}

int lca(int a, int b) {
    if (dep[a] < dep[b]) swap(a, b);
    for (int i = MAXL - 1; i >= 0; i--) {
        if (dep[a] - (1 << i) >= dep[b]) {
            a = tab[i][a];
        }
    }
    if (a == b) return a;
    for (int i = MAXL - 1; i >= 0; i--) {
        if (tab[i][a] != tab[i][b]) {
            a = tab[i][a];
            b = tab[i][b];
        }
    }
    return tab[0][a];
}
\end{lstlisting}

\subsection{Lower Bound Max Flow}
\begin{lstlisting}
// Max flow com lower bound nas arestas
// 
// add(a, b, l, r):
// 	adiciona aresta de a pra b, onde precisa passar f de fluxo, l <= f <= r
// add(a, b, c):
// 	adiciona aresta de a pra b com capacidade c
//
// Mesma complexidade do Dinic

// INF tem que ser int, de preferencia 1e9

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const int INF = 1e9;

struct dinic {
	const bool scaling = false;
	int lim;
	struct edge {
		int to, cap, rev, flow;
		bool res;
		edge(int to_, int cap_, int rev_, bool res_)
			: to(to_), cap(cap_), rev(rev_), flow(0), res(res_) {}
	};

	vector<vector<edge>> g;
	vector<int> lev, beg;
	ll F;
	dinic(int n) : g(n), F(0) {}

	void add(int a, int b, int c) {
		g[a].emplace_back(b, c, g[b].size(), false);
		g[b].emplace_back(a, 0, g[a].size()-1, true);
	}
	bool bfs(int s, int t) {
		lev = vector<int>(g.size(), -1); lev[s] = 0;
		beg = vector<int>(g.size(), 0);
		queue<int> q; q.push(s);
		while (q.size()) {
			int u = q.front(); q.pop();
			for (auto& i : g[u]) {
				if (lev[i.to] != -1 or (i.flow == i.cap)) continue;
				if (scaling and i.cap - i.flow < lim) continue;
				lev[i.to] = lev[u] + 1;
				q.push(i.to);
			}
		}
		return lev[t] != -1;
	}
	int dfs(int v, int s, int f = INF) {
		if (!f or v == s) return f;
		for (int& i = beg[v]; i < g[v].size(); i++) {
			auto& e = g[v][i];
			if (lev[e.to] != lev[v] + 1) continue;
			int foi = dfs(e.to, s, min(f, e.cap - e.flow));
			if (!foi) continue;
			e.flow += foi, g[e.to][e.rev].flow -= foi;
			return foi;
		}
		return 0;
	}
	ll max_flow(int s, int t) {
		for (lim = scaling ? (1<<30) : 1; lim; lim /= 2)
			while (bfs(s, t)) while (int ff = dfs(s, t)) F += ff;
		return F;
	}
};

struct lb_max_flow : dinic {
	vector<int> d;
	lb_max_flow(int n) : dinic(n + 2), d(n, 0) {}
	void add(int a, int b, int l, int r) {
		d[a] -= l;
		d[b] += l;
		dinic::add(a, b, r - l);
	}
	void add(int a, int b, int c) {
		dinic::add(a, b, c);
	}
	bool has_circulation() {
		int n = d.size();

		ll cost = 0;
		for (int i = 0; i < n; i++) {
			if (d[i] > 0) {
				cost += d[i];
				dinic::add(n, i, d[i]);
			} else if (d[i] < 0) {
				dinic::add(i, n+1, -d[i]);
			}
		}

		return (dinic::max_flow(n, n+1) == cost);
	}
	bool has_flow(int src, int snk) {
		dinic::add(snk, src, INF);
		return has_circulation();
	}
	ll max_flow(int src, int snk) {
		if (!has_flow(src, snk)) return -1;
		dinic::F = 0;
		return dinic::max_flow(src, snk);
	}
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

	// recebo o numero de vertices e m arestas do tipo
	// vai de a pra b e fluxo tem que estar entre [c, d]
	// note que nao preciso adicionar uma source nem uma sink
	// o algoritmo ja faz isso por mim
    int n, m;
	cin >> n >> m;
	lb_max_flow ber(n);
	map<pii, int> id;
	vector<int> ans(m);
	for (int i = 0; i < m; i++) {
		int a, b, c, d;
		cin >> a >> b >> c >> d;
		a--, b--;
		id[{a, b}] = i;
		ans[i] = c;
		ber.add(a, b, c, d);
	}

	// Se tem um fluxo que atende todas as exigencias
	if (ber.has_circulation()) {
		cout << "YES" << endl;
		
		// Importante: n eh a qtd de vertices
		for (int i = 0; i < n; i++) {
			for (auto edge : ber.g[i]) {
				if (edge.res) {
					int j = edge.to;
					if (j >= n) continue;
					ans[id[{j, i}]] -= edge.flow;
				}
			}
		}

		// imprime fluxo em cada aresta
		for (int x : ans) cout << x << '\n';
	}
	else {
		cout << "NO\n";
	}
    return 0;
}
\end{lstlisting}

\subsection{MinCostMaxFlow}
\begin{lstlisting}
// declara mcmf<int ou ll> nome(qtd de nodes)
// min_cost_flow(s, t, f) computa o par (fluxo, custo)
// com max(fluxo) <= f que tenha min(custo)
// min_cost_flow(s, t) -> Fluxo maximo de custo minimo de s pra t
// Se for um dag, da pra substituir o SPFA por uma DP pra nao
// para O(nm) no comeco
// Se nao tiver aresta com custo negativo, nao precisa do SPFA
//
// O(nm + f * m log n)
// 697b4c

template<typename T> struct mcmf {
	struct edge {
		int to, rev, flow, cap; // para, id da reversa, fluxo, capacidade
		bool res; // se eh reversa
		T cost; // custo da unidade de fluxo
		edge() : to(0), rev(0), flow(0), cap(0), cost(0), res(false) {}
		edge(int to_, int rev_, int flow_, int cap_, T cost_, bool res_)
			: to(to_), rev(rev_), flow(flow_), cap(cap_), res(res_), cost(cost_) {}
	};

	vector<vector<edge>> g;
	vector<int> par_idx, par;
	T inf;
	vector<T> dist;

	mcmf(int n) : g(n), par_idx(n), par(n), inf(numeric_limits<T>::max()/3) {}

	void add(int u, int v, int w, T cost) { // de u pra v com cap w e custo cost
		edge a = edge(v, g[v].size(), 0, w, cost, false);
		edge b = edge(u, g[u].size(), 0, 0, -cost, true);

		g[u].push_back(a);
		g[v].push_back(b);
	}

	vector<T> spfa(int s) { // nao precisa se nao tiver custo negativo
		deque<int> q;
		vector<bool> is_inside(g.size(), 0);
		dist = vector<T>(g.size(), inf);

		dist[s] = 0;
		q.push_back(s);
		is_inside[s] = true;

		while (!q.empty()) {
			int v = q.front();
			q.pop_front();
			is_inside[v] = false;

			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;

					if (is_inside[to]) continue;
					if (!q.empty() and dist[to] > dist[q.front()]) q.push_back(to);
					else q.push_front(to);
					is_inside[to] = true;
				}
			}
		}
		return dist;
	}
	bool dijkstra(int s, int t, vector<T>& pot) {
		priority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> q;
		dist = vector<T>(g.size(), inf);
		dist[s] = 0;
		q.emplace(0, s);
		while (q.size()) {
			auto [d, v] = q.top();
			q.pop();
			if (dist[v] < d) continue;
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				cost += pot[v] - pot[to];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
					q.emplace(dist[to], to);
					par_idx[to] = i, par[to] = v;
				}
			}
		}
		return dist[t] < inf;
	}

	pair<int, T> min_cost_flow(int s, int t, int flow = INF) {
		vector<T> pot(g.size(), 0);
		pot = spfa(s); // mudar algoritmo de caminho minimo aqui

		int f = 0;
		T ret = 0;
		while (f < flow and dijkstra(s, t, pot)) {
			for (int i = 0; i < g.size(); i++)
				if (dist[i] < inf) pot[i] += dist[i];

			int mn_flow = flow - f, u = t;
			while (u != s){
				mn_flow = min(mn_flow,
					g[par[u]][par_idx[u]].cap - g[par[u]][par_idx[u]].flow);
				u = par[u];
			}

			ret += pot[t] * mn_flow;

			u = t;
			while (u != s) {
				g[par[u]][par_idx[u]].flow += mn_flow;
				g[u][g[par[u]][par_idx[u]].rev].flow -= mn_flow;
				u = par[u];
			}

			f += mn_flow;
		}

		return make_pair(f, ret);
	}

	// Opcional: retorna as arestas originais por onde passa flow = cap
	vector<pair<int,int>> recover() {
		vector<pair<int,int>> used;
		for (int i = 0; i < g.size(); i++) for (edge e : g[i])
			if(e.flow == e.cap && !e.res) used.push_back({i, e.to});
		return used;
	}
};
\end{lstlisting}

\subsection{Topological Sort}
\begin{lstlisting}

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;

vector<int> v[MAXN], ans;
bool valid = true;
int cor[MAXN];
 
void dfs(int node) {
	cor[node] = 1;
	for (int x : v[node]) {
		if (cor[x] == 1) {
			valid = false;
			return;
		}
		if (!cor[x]) dfs(x);
	}
	cor[node] = 2;
	ans.push_back(node);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
	}
	for (int i = 1; i <= n && valid; i++) {
		if (!cor[i]) {
			dfs(i);
		}
	}
	if (!valid) cout << "IMPOSSIBLE\n";
	else {
		reverse(ans.begin(), ans.end());
		for (int x : ans) cout << x << ' ';
		cout << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{Tree diameter}
\begin{lstlisting}
// int a = bfs(1, 0);
// int diametro = bfs(a, 1);

vector<int> v[MAXN];
int n;
 
int bfs(int node, bool flag) {
    // flag = true se estou fazendo a segunda BFS
	
    queue<pii> q;
	vector<int> check(n+1);
	check[node] = 1;
	q.push({node, 0});
	int resp = 0, fim = node;
	while (!q.empty()) {
		pii atual = q.front();
		q.pop();
		for (int x : v[atual.first]) {
			if (!check[x]) {
				check[x] = 1;
				q.push({x, atual.second+1});
				if (atual.second + 1 > resp) {
					resp = atual.second + 1;
					fim = x;
				}
			}
		}
	}
	return (flag ? resp : fim);
}
\end{lstlisting}

\subsection{Tree Isomorphism}
\begin{lstlisting}
// Acha se duas arvores enraizadas sao isomorficas
// Usa hashing 
// Se nao forem enraizadas basta achar os centroides
// ai tenta ver se uma arvore enraizada em um centroide eh igual a outra enraizada em um dos 2 centroides
#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
vector<int> v[2][MAXN];
int id = 0;
map<vector<int>, int> mp;
 
int dfs(int node, int p, bool at) {
    vector<int> val;
    for (int x : v[at][node]) {
        if (x != p) {
            val.push_back(dfs(x, node, at));
        }
    }
    sort(val.begin(), val.end());
    if (!mp[val]) mp[val] = ++id;
    return mp[val];
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        mp.clear();
        id = 0;
        int n, a, b;
        cin >> n;
        for (int i = 0; i < 2; i++) {
            for (int j = 1; j <= n; j++) {
                v[i][j].clear();
            }
            for (int j = 0; j < n - 1; j++) {
                cin >> a >> b;
                v[i][a].push_back(b);
                v[i][b].push_back(a);
            }
        }
        int s0 = dfs(1, -1, 0);
        int s1 = dfs(1, -1, 1);
        cout << (s0 == s1 ? "YES\n" : "NO\n");
    }
    return 0;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Math
%
%%%%%%%%%%%%%%%%%%%%

\section{Math}

\subsection{Comb Template}
\begin{lstlisting}
// template para problemas de combinatoria
int fat[MAXN], inv[MAXN];

ll fexp(ll b, ll e) {
    ll ans = 1;
    while (e) {
        if (e&1) ans = (ans * b) % MOD;
        b = (b * b) % MOD;
        e >>= 1;
    }
    return ans;
}

void precalc() {
    fat[0] = 1;
    for (int i = 1; i < MAXN; i++) fat[i] = (1ll * i * fat[i - 1]) % MOD;
    inv[MAXN - 1] = fexp(fat[MAXN - 1], MOD - 2);
    for (int i = MAXN - 2; i >= 0; i--) inv[i] = ((i + 1ll) * inv[i + 1]) % MOD;
}

int nck(int n, int k) {
    if (k > n || k < 0 || n < 0) return 0;
    return (((1ll * fat[n] * inv[k]) % MOD) * 1ll * inv[n - k]) % MOD; 
}

void add(int &a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
    if (a < 0) a += MOD;
}

int mul(int a, int b) {
    return (1ll * a * b) % MOD;
}
\end{lstlisting}

\subsection{NTT}
\begin{lstlisting}
/**
 * NTT do KACTL
 * Description: ntt(a) computes $\hat f(k) = \sum_x a[x] g^{xk}$ for all $k$, where $g=\text{root}^{(MOD-1)/N}$.
 * N must be a power of 2.
 * Useful for convolution modulo specific nice primes of the form $2^a b+1$,
 * where the convolution result has size at most $2^a$. For arbitrary modulo, see FFTMod.
   \texttt{conv(a, b) = c}, where $c[x] = \sum a[i]b[x-i]$.
   For manual convolution: NTT the inputs, multiply
   pointwise, divide by n, reverse(start+1, end), NTT back.
 * Inputs must be in [0, MOD).
 * Time: O(N \log N)
 * Status: stress-tested
 */
const ll MOD = (119 << 23) + 1, root = 62; // = 998244353
// For p < 2^30 there is also e.g. 5 << 25, 7 << 26, 479 << 21
// and 483 << 21 (same root). The last two are > 10^9.
#pragma once

void ntt(vector<ll> &a) {
	int n = a.size(), L = 31 - __builtin_clz(n);
	static vector<ll> rt(2, 1);
	for (static int k = 2, s = 2; k < n; k *= 2, s++) {
		rt.resize(n);
		ll z[] = {1, fexp(root, MOD >> s)};
		for (int i = k; i < 2 * k; i++) rt[i] = rt[i / 2] * z[i & 1] % MOD;
	}
	vector<int> rev(n);
	for(int i = 0; i < n; i++) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;
	for(int i = 0; i < n; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
	for (int k = 1; k < n; k *= 2) {
		for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                ll z = rt[j + k] * a[i + j + k] % MOD, &ai = a[i + j];
                a[i + j + k] = ai - z + (z > ai ? MOD : 0);
                ai += (ai + z >= MOD ? z - MOD : z);
            }
		}
    }
}
vector<ll> conv(const vector<ll> &a, const vector<ll> &b) {
	if (a.empty() || b.empty()) return {};
	int s = a.size() + b.size() - 1, B = 32 - __builtin_clz(s), n = 1 << B;
	int inv = fexp(n, MOD - 2);
	vector<ll> L(a), R(b), out(n);
	L.resize(n), R.resize(n);
	ntt(L), ntt(R);
	for(int i = 0; i < n; i++) out[-i & (n - 1)] = (ll)L[i] * R[i] % MOD * inv % MOD;
	ntt(out);
	return {out.begin(), out.begin() + s};
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Problems
%
%%%%%%%%%%%%%%%%%%%%

\section{Problems}

\subsection{Dynamic Connectivity}
\begin{lstlisting}
// Two types of queries:
// A new edge is created between nodes a and b
// An existing edge between nodes a and b is removed.

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const int INF = 2e9;

int ans[MAXN], pai[MAXN], sz[MAXN], resp;
map<pii, int> mp;
stack<int> st;

// Seg

struct no {
    vector<pii> v;
    no() {
        v = vector<pii> ();
    }
} a[4 * MAXN];
 
void update(int node, int i, int j, int ini, int fim, pii val) {
    if (j < ini || i > fim) return;
    else if (ini <= i && j <= fim) {
        a[node].v.push_back(val);
    }
    else {
        int m = (i + j) / 2;
        update(2 * node, i, m, ini, fim, val);
        update(2 * node + 1, m + 1, j, ini, fim, val);
    }
}
 
// DSU
 
int find(int x) {
    if (x == pai[x]) return x;
    return find(pai[x]);
}
 
void join(int a, int b) {
    a = find(a), b = find(b);
    if (sz[a] < sz[b]) {
        swap(a, b);
    }
    pai[b] = a;
    sz[a] += sz[b];
    st.push(b);
    resp--;
}
 
void rollback() {
    int at = st.top();
    st.pop();
    sz[pai[at]] -= sz[at];
    pai[at] = at;
    resp++;
}
 
//
 
void dfs(int node, int i, int j) {
    int cnt = 0;
    for (auto x : a[node].v) {
        if (find(x.first) != find(x.second)) {
            join(x.first, x.second);
            cnt++;
        }
    }
    if (i == j) {
        ans[i] = resp;
    }
    else {
        int m = (i + j) / 2;
        dfs(2 * node, i, m);
        dfs(2 * node + 1, m + 1, j);
    }
    for (int i = 0; i < cnt; i++) {
        rollback();
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, k, tipo, a, b;
    cin >> n >> m >> k;
    resp = n;
    for (int i = 1; i <= n; i++) pai[i] = i, sz[i] = 1;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        if (a > b) swap(a, b);
        mp[{a, b}] = 0;
    }
    for (int i = 1; i <= k; i++) {
        // tempo i
 
        cin >> tipo >> a >> b;
        if (a > b) swap(a, b);
        if (tipo == 1) {
            mp[{a, b}] = i;
        }
        else {
            update(1, 0, k + 1, mp[{a, b}], i - 1, {a, b});
            mp[{a, b}] = -1;
        }
    }
    for (auto x : mp) {
        // se x.second nao for -1, preciso fechar o intervalo da aresta
        
        if (x.second == -1) continue;
        update(1, 0, k + 1, x.second, k + 1, x.first);
    }
    dfs(1, 0, k + 1);
    for (int i = 0; i <= k; i++) cout << ans[i] << ' ';
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Mo}
\begin{lstlisting}

const int X = 700;
 
struct que {
	int ans, l, r, b, id;
};
 
vector<que> qs;
 
int main() {
	int n, q;
	cin >> n >> q;
    // probably receive some input here
	que aux;
	for (int i = 0; i < q; i++) {
		cin >> aux.l >> aux.r;
		aux.id = i;
		aux.l--, aux.r--;
		aux.b = aux.l/X;
		qs.pb(aux);
	}
	sort(qs.begin(), qs.end(), [&] (que x, que y) {
		if (x.b != y.b) return x.b < y.b;
		return x.r < y.r;
	});
	int la, ra, resp;
	for (int i = 0; i < q; i++) {
		if (i == 0 || qs[i].b != qs[i-1].b) {
			// new batch
            // initialize resp
			resp = 0;
			for (int j = qs[i].l; j <= qs[i].r; j++) {
                // go forward
			}
		}
		else {
			for (int j = ra+1; j <= qs[i].r; j++) {
                // go forward
			}
			for (int j = la-1; j >= qs[i].l; j--) {
                // go backwards
			}
			for (int j = la; j < qs[i].l; j++) {
                // go forward
			}
		}
		qs[i].ans = resp;
		la = qs[i].l, ra = qs[i].r;
	}
	sort(qs.begin(), qs.end(), [&] (que x, que y) { return x.id < y.id; });
	for (que x : qs) cout << x.ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Mo + DSU}
\begin{lstlisting}

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 5e4 + 5;
const int INF = 2e9;
 
const int X = 225;

struct que {
	int ans, l, r, b, id;
};
 
int resp, ra, cnt;
vector<que> qs;
pii ed[MAXN];
int pai[MAXN], sz[MAXN];
stack<int> st;

int find(int x) {
    if (x == pai[x]) return x;
    return find(pai[x]);
}
 
void join(int a, int b) {
    a = find(a), b = find(b);
    if (sz[a] < sz[b]) {
        swap(a, b);
    }
    pai[b] = a;
    sz[a] += sz[b];
    st.push(b);
    resp--;
}

void rollback() {
    int at = st.top();
    st.pop();
    sz[pai[at]] -= sz[at];
    pai[at] = at;
    resp++;
}

int main() { 
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> ed[i].first >> ed[i].second;
	}
    int q;
    cin >> q;
    que aux;
	for (int i = 0; i < q; i++) {
		cin >> aux.l >> aux.r;
		aux.id = i;
		aux.b = aux.l/X;
		qs.push_back(aux);
	}
	sort(qs.begin(), qs.end(), [&] (que x, que y) {
		if (x.b != y.b) return x.b < y.b;
		return x.r < y.r;
	});
	for (int i = 0; i < q; i++) {
		if (i == 0 || qs[i].b != qs[i - 1].b) {
			// new batch
            while (!st.empty()) st.pop();
            for (int j = 1; j <= n; j++) {
                sz[j] = 1;
                pai[j] = j;
            }
			resp = n, ra = (qs[i].b + 1) * X - 1;
		}
        if (qs[i].r < (qs[i].b + 1) * X) {
            // naive
            for (int j = qs[i].l; j <= qs[i].r; j++) {
                if (find(ed[j].first) != find(ed[j].second)) {
                    cnt++;
                    join(ed[j].first, ed[j].second);
                }
            }
            qs[i].ans = resp;
            while (cnt) {
                rollback();
                cnt--;
            }
        }
        else {
            for (int j = ra + 1; j <= qs[i].r; j++) {
                if (find(ed[j].first) != find(ed[j].second)) {
                    join(ed[j].first, ed[j].second);
                }
            }
            for (int j = qs[i].l; j < (qs[i].b + 1) * X; j++) {
                if (find(ed[j].first) != find(ed[j].second)) {
                    cnt++;
                    join(ed[j].first, ed[j].second);
                }
            }
            ra = qs[i].r;
            qs[i].ans = resp;
            while (cnt) {
                rollback();
                cnt--;
            }
        }
	}

	sort(qs.begin(), qs.end(), [&] (que x, que y) { return x.id < y.id; });
	for (que x : qs) cout << x.ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Mo + DSU + Bipartition}
\begin{lstlisting}
#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const int INF = 2e9;
 
const int X = 400;

struct que {
	int ans, l, r, b, id;
};
 
int resp, ra, cnt;
vector<que> qs;
pii ed[MAXN];
int pai[MAXN], sz[MAXN], len[MAXN];
stack<pii> st;

pii find(int x) {
    if (x == pai[x]) return {x, len[x]};
    pii ans = find(pai[x]);
    return {ans.first, ans.second ^ len[x]};
}
 
void join(int a, int b) {
    pii c = find(a), d = find(b);
    if (sz[c.first] < sz[d.first]) {
        swap(c, d);
    }
    pai[d.first] = c.first;
    sz[c.first] += sz[d.first];
    st.push({d.first, len[d.first]});
    len[d.first] = 1 ^ c.second ^ d.second;
}

void rollback() {
    pii at = st.top();
    st.pop();
    if (at.first) {
        sz[pai[at.first]] -= sz[at.first];
        len[at.first] = at.second;
        pai[at.first] = at.first;
    }
    else resp = 1;
}

int main() { 
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m, q;
	cin >> n >> m >> q;
	for (int i = 1; i <= m; i++) {
		cin >> ed[i].first >> ed[i].second;
	}
    que aux;
	for (int i = 0; i < q; i++) {
		cin >> aux.l >> aux.r;
		aux.id = i;
		aux.b = aux.l/X;
		qs.push_back(aux);
	}
	sort(qs.begin(), qs.end(), [&] (que x, que y) {
		if (x.b != y.b) return x.b < y.b;
		return x.r < y.r;
	});
	for (int i = 0; i < q; i++) {
		if (i == 0 || qs[i].b != qs[i - 1].b) {
			// new batch
            while (!st.empty()) st.pop();
            for (int j = 1; j <= n; j++) {
                sz[j] = 1;
                pai[j] = j;
                len[j] = 0;
            }
			resp = 1, ra = (qs[i].b + 1) * X - 1;
		}
        if (qs[i].r < (qs[i].b + 1) * X) {
            // naive
            for (int j = qs[i].l; j <= qs[i].r; j++) {
                pii c = find(ed[j].first), d = find(ed[j].second);
                if (c.first != d.first) {
                    cnt++;
                    join(ed[j].first, ed[j].second);
                }
                else {
                    if (resp == 1 && c.second ^ d.second == 0) {
                        cnt++;
                        resp = 0;
                        st.push({0, 0});
                    }
                }
            }
            qs[i].ans = resp;
            while (cnt) {
                rollback();
                cnt--;
            }
        }
        else {
            for (int j = ra + 1; j <= qs[i].r; j++) {
                pii c = find(ed[j].first), d = find(ed[j].second);
                if (c.first != d.first) {
                    join(ed[j].first, ed[j].second);
                }
                else {
                    if (resp == 1 && c.second ^ d.second == 0) {
                        resp = 0;
                        st.push({0, 0});
                    }
                }
            }
            for (int j = qs[i].l; j < (qs[i].b + 1) * X; j++) {
                pii c = find(ed[j].first), d = find(ed[j].second);
                if (c.first != d.first) {
                    cnt++;
                    join(ed[j].first, ed[j].second);
                }
                else {
                    if (resp == 1 && c.second ^ d.second == 0) {
                        cnt++;
                        resp = 0;
                        st.push({0, 0});
                    }
                }
            }
            ra = qs[i].r;
            qs[i].ans = resp;
            while (cnt) {
                rollback();
                cnt--;
            }
        }
	}

	sort(qs.begin(), qs.end(), [&] (que x, que y) { return x.id < y.id; });
	for (que x : qs) cout << (x.ans ? "Possible\n" : "Impossible\n");
    return 0;
}
\end{lstlisting}

\subsection{Sqrt Min Vector Partition}
\begin{lstlisting}
// Sqrt RMQ

#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 10;
const int SQ = 326;
int v[MAXN], mx[SQ], bl[MAXN], e[SQ], d[SQ];
int main() {
	for(int i = 0; i < SQ; i++) e[i] = MAXN;
	for(int i = 0; i < MAXN; i++) {
		bl[i] = i / SQ;
		e[bl[i]] = min(i, e[bl[i]]);
		d[bl[i]] = max(d[bl[i]], i);
	}
	int t;
	scanf("%d", &t);
	for(int ab = 0; ab < t; ab++) {
		printf("Scenario #%d:\n", ab + 1);
		int n, q;
		for(int i = 0; i < SQ; i++) {
			mx[i] = 1123456789;
		}
		scanf("%d %d", &n, &q);
		for(int i = 0; i < n; i++) {
			scanf("%d", &v[i]);
			mx[bl[i]] = min(mx[bl[i]], v[i]);
		}
		for(int i = 0; i < q; i++) {
			int a, b;
			scanf("%d %d", &a, &b); a--; b--;
			int resp = 1123456789;
			if(bl[a] == bl[b]) {
				for(int j = a; j <= b; j++) {
					resp = min(v[j], resp);
				}
			}
			else {
				for(int j = a; j <= d[bl[a]]; j++) {
					resp = min(resp, v[j]);
				}
				for(int j = b; j >= e[bl[b]]; j--) {
					resp = min(resp, v[j]);
				}
				for(int j = bl[a] + 1; j <= bl[b] - 1; j++) {
					resp = min(mx[j], resp);
				}
			}
			printf("%d\n", resp);
		}
	}
	return 0;
} 
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Structures
%
%%%%%%%%%%%%%%%%%%%%

\section{Structures}

\subsection{Coordinate Compression}
\begin{lstlisting}
// 0 indexed
// if x is in arr, getL returns the compressed id of x and getR returns id + 1
// getR is unnecessary most times
// getVal returns the original value that corresponds to id

template<class T>
class CoordinateCompression {
public:
	CoordinateCompression(const vector<T> &a) {
		arr = a;
		sort(arr.begin(), arr.end());
		arr.resize(unique(arr.begin(), arr.end()) - arr.begin());
	}

	int getL(T x) { return lower_bound(arr.begin(), arr.end(), x) - arr.begin(); }
	int getR(T x) { return upper_bound(arr.begin(), arr.end(), x) - arr.begin(); }
    T getVal(int id) { return arr[id]; }
	int size() const { return (int) arr.size(); }
private:
	vector<T> arr;
};
\end{lstlisting}

\subsection{Fast RMQ using Sparse Table}
\begin{lstlisting}
// O(N) preprocessing, O(1) query Range Minimum Query
// qry(l, r) returns min from l to r - 1 (0 indexed)
template<class T>
class FastRMQ {
public:
	void init(const vector<T> &a) {
		original = a;
		int n = (int) a.size();
		if(n == 0) return;
		e = 1;
		while((1 << e) < n) e++;
		vector<T> groups;
		for(int i = 0; i < n; i++) {
			if(i % e == 0) {
				groups.push_back(a[i]);
			} else if(a[i] < groups.back()) {
				groups.back() = a[i];
			}
		}
		table.init(groups);
		mask.resize(n);
		for(int i = 0, curMask = 0; i < n; i++) {
			curMask = (curMask << 1) & ((1 << e) - 1);
			while(curMask) {
				int j = i - table.getPos(curMask & -curMask);
				if(a[i] < a[j]) {
					curMask ^= curMask & -curMask;
				} else {
					break;
				}
			}
			curMask |= 1;
			mask[i] = curMask;
		}
	}

	T qry(int l, int r) {
		// query in [l, r)
		if(r - l <= e) {
			return i_qry(r-1, r-l);
		} else {
			T ans = min(i_qry(l+e-1, e), i_qry(r-1, e));
			if(l / e + 1 < r / e) {
				ans = min(ans, table.qry(l / e + 1, r / e));
			}
			return ans;
		}
	}
private:
	int e;
	SparseTable<T> table;
	vector<T> original;
	vector<int> mask;

	T i_qry(int r, int size) {
		int curMask = mask[r] & ((1 << size) - 1);
		int pos = r - table.getPos(curMask);
		return original[pos];
	}
};
\end{lstlisting}

\subsection{Fenwick Tree (BIT)}
\begin{lstlisting}

template <class T>
class FenwickTree {
public:
	void init(int _n) {
		this->n = _n;
		bit.assign(n + 1, 0);
	}

	void init(const vector<T> &a) {
		n = a.size();
		bit.assign(n + 1, 0);
		for(int i = 1; i <= n; i++) {
			bit[i] += a[i - 1];
			if(i + (i & -i) <= n) {
				bit[i + (i & -i)] += bit[i];
			}
		}
	}

	T qry(int x) {
		x = min(x, (int)bit.size() - 1);
		T ans = 0;
		for(; x > 0; x -= x & -x) {
			ans += bit[x];
		}
		return ans;
	}

	void upd(int x, T v) {
		if(x <= 0) return;
		for(; x <= n; x += x & -x) {
			bit[x] += v;
		}
	}
private:
	int n;
	vector<T> bit;
};
\end{lstlisting}

\subsection{Max Queue}
\begin{lstlisting}

template <class T, class C = less<T>>
struct MaxQueue {
	MaxQueue() {
		clear();
	}

	void clear() {
		id = 0;
		q.clear();
	}

	void push(T x) {
		pair<int, T> nxt(1, x);
		while(q.size() > id && cmp(q.back().second, x)) {
			nxt.first += q.back().first;
			q.pop_back();
		}
		q.push_back(nxt);
	}

	T qry() {
		return q[id].second;
	}

	void pop() {
		q[id].first--;
		if(q[id].first == 0) {
			id++;
		}
	}
private:
	vector<pair<int, T>> q;
	int id;
	C cmp;
};
\end{lstlisting}

\subsection{Sparse Table}
\begin{lstlisting}
// don't know how to use without FastRMQ.cpp

template<class T>
struct Minimizer {
	T operator() (T a, T b) { return min(a, b); }
};

template <class T, class Merger = Minimizer<T>>
class SparseTable {
public:
	void init(const vector<T> &a) {
		int e = 0;
		int n = a.size();
		while((1 << e) / 2 < n) {
			e++;
		}
		table.assign(e, vector<T>(n));
		get.assign(n + 1, -1);
		for(int i = 0; i < n; i++) {
			table[0][i] = a[i];
			get[i+1] = get[(i+1)/2] + 1;
		}
		for(int i = 0; i + 1 < e; i++) {
			for(int j = 0; j + (1 << i) < n; j++) {
				table[i+1][j] = merge(table[i][j], table[i][j + (1 << i)]);
			}
		}
	}
	
	T qry(int l, int r) {
		int e = get[r - l];
		return merge(table[e][l], table[e][r - (1 << e)]);
	}

	int getPos(int x) {
		while(x >= (int) get.size()) get.push_back(get[(int) get.size() / 2] + 1);
		return get[x];
	}
private:
	vector<vector<T>> table;
	vector<int> get;
	Merger merge;
};
\end{lstlisting}

\subsection{Trie}
\begin{lstlisting}
// trie T() constroi uma trie para o alfabeto das letras minusculas
// trie T(tamanho do alfabeto, menor caracter) tambem pode ser usado
// 
// T.insert(s) - O(|s|*sigma)
// T.erase(s) - O(|s|)
// T.find(s) retorna a posicao, 0 se nao achar - O(|s|)
// T.count_pref(s) numero de strings que possuem s como prefixo - O(|s|)
//
// Nao funciona para string vazia
// 979609

struct trie {
	vector<vector<int>> to;
	vector<int> end, pref;
	int sigma; char norm;
	trie(int sigma_=26, char norm_='a') : sigma(sigma_), norm(norm_) {
		to = {vector<int>(sigma)};
		end = {0}, pref = {0};
	}
	void insert(string s) {
		int x = 0;
		for(auto c : s) {
			int &nxt = to[x][c-norm];
			if(!nxt) {
				nxt = to.size();
				to.push_back(vector<int>(sigma));
				end.push_back(0), pref.push_back(0);
			}
			x = nxt, pref[x]++;
		}
		end[x]++;
	}
	void erase(string s) {
		int x = 0;
		for(char c : s) {
			int &nxt = to[x][c-norm];
			x = nxt, pref[x]--;
			if(!pref[x]) nxt = 0;
		}
		end[x]--;
	}
	int find(string s) {
		int x = 0;
		for(auto c : s) {
			x = to[x][c-norm];
			if(!x) return 0;
		}
		return x;
	}
	int count_pref(string s) {
		return pref[find(s)];
	}
};
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% CSES-Solutions
%
%%%%%%%%%%%%%%%%%%%%

\section{CSES-Solutions}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1752
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
vector<int> v[MAXN], ord;
int sz[MAXN], to[20][MAXN], dist[20][MAXN], dep[MAXN], pai[MAXN], ans[MAXN], lvl[MAXN], n, d, tot;
bool vis[MAXN], usei[MAXN];
 
// preprocess
void dfs(int node, int p = 0) {
    if (!p) to[0][node] = node;
    else to[0][node] = p;
    dep[node] = dep[p] + 1;
    for (int x : v[node]) {
        if (x != p) dfs(x, node);
    }
}
void preprocess() {
    dfs(1);
    for (int i = 1; i < 20; i++) {
        for (int j = 1; j <= n; j++) to[i][j] = to[i - 1][to[i - 1][j]];
    }
}
int lca(int a, int b) {
    if (dep[a] < dep[b]) swap(a, b);
    for (int i = 19; i >= 0; i--) {
        if (dep[a] - (1 << i) >= dep[b]) {
            a = to[i][a];
        }
    }
    if (a == b) return a;
    for (int i = 19; i >= 0; i--) {
        if (to[i][a] != to[i][b]) {
            a = to[i][a];
            b = to[i][b];
        }
    }
    return to[0][a];
}
 
 
// centroid decomposition
int subtree(int node, int p = 0) {
    sz[node] = 1;
    for (int x : v[node]) {
        if (!vis[x] && x != p) {
            sz[node] += subtree(x, node);
        }
    }
    return sz[node];
}
int centroid(int node, int desired, int p = 0) {
    for (int x : v[node]) {
        if (!vis[x] && x != p && sz[x] > desired) {
            return centroid(x, desired, node);
        }
    }
    return node;
}
void dfs1(int node, int p, int l, int d) {
    dist[l][node] = d;
    for (int x : v[node]) {
        if (!vis[x] && x != p) {
            dfs1(x, node, l, d + 1);
        }
    }
}
void solve(int node, int p = 0) {
    int c = centroid(node, subtree(node) / 2);
    vis[c] = true;
    if (p == 0) {
        pai[c] = c;
        lvl[c] = 0;
    } 
    else {
        pai[c] = p;
        lvl[c] = lvl[p] + 1;
    }
    dfs1(c, p, lvl[c], 0);
    for (int x : v[c]) {
        if (!vis[x]) {
            solve(x, c);
        }
    }
}
 
 
// queries
void upd(int node) {
    tot++;
    usei[node] = true;
    int x = node;
    while (true) {
        ans[x] = min(ans[x], dist[lvl[x]][node]);
        if (x == pai[x]) break;
        x = pai[x];
    }
}
int query(int node) {
    int mn = n + 5, x = node;
    while (true) {
        mn = min(mn, ans[x] + dist[lvl[x]][node]);
        if (x == pai[x]) break;
        x = pai[x];
    }
    return mn;
}
 
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> d;
    int a, b;
    for (int i = 0; i < n - 1; i++) {
        cin >> a >> b;
        v[a].push_back(b);
        v[b].push_back(a);
    }
    preprocess();
    solve(1);
    for (int i = 1; i <= n; i++) {
        ans[i] = 1e9;
        ord.push_back(i);
    }
    sort(ord.begin(), ord.end(), [&] (int a, int b){
        return dep[a] > dep[b];
    }); 
    upd(ord[0]);
    for (int i = 1; i < n; i++) {
        if (query(ord[i]) >= d) {
            upd(ord[i]);
        }
    }
    cout << tot << '\n';
    for (int i = 1; i <= n; i++) {
        if (usei[i]) cout << i << ' ';
    }
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2072
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const ll INF = 2e18;
 
struct node {
    node *L, *R;
    int prio, sz;
    char c;
    node (char _c) {
        L = NULL, R = NULL, prio = rng(), sz = 1, c = _c;
    }
};
 
int size(node *treap) {
    if (treap == NULL) return 0;
    return treap->sz;
}
 
void recalc(node *&treap) {
    if (treap == NULL) return;
    treap->sz = size(treap->L) + size(treap->R) + 1;
}
 
void split(node *treap, node *&L, node *&R, int k) {
    if (treap == NULL) {
        L = R = NULL;
    }
    else {
        if (size(treap->L) >= k) {
            split(treap->L, L, treap->L, k);
            R = treap;
        }
        else {
            split(treap->R, treap->R, R, k - size(treap->L) - 1);
            L = treap;
        }
        recalc(treap);
    }
}
 
void merge(node *&treap, node *L, node *R) {
    if (L == NULL) treap = R;
    else if (R == NULL) treap = L;
    else {
        if (L->prio > R->prio) {
            merge(L->R, L->R, R);
            treap = L;
        }
        else {
            merge(R->L, L, R->L);
            treap = R;
        }
        recalc(treap);
    }
}
 
void print(node *treap) {
    if (treap == NULL) return;
    print(treap->L);
    cout << treap->c;
    print(treap->R);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, l, r;
    string s;
    cin >> n >> m >> s;
    node *root = 0;
    for (int i = 0; i < n; i++) {
        merge(root, root, new node(s[i]));
    }
    for (int i = 0; i < m; i++) {
        cin >> l >> r;
        node *a, *b, *c, *d;
        split(root, a, b, l - 1);
        split(b, c, d, r - l + 1);
        merge(root, a, d);
        merge(root, root, c);
    }
    print(root);
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2064
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> fat(2, 1);
 
int fexp(ll b, int e) {
    ll resp = 1;
    while(e) {
        if(e&1) resp = (resp * b) % M;
        b = (b*b) % M;
        e = (e>>1);
    }
    return resp;
}
 
int main () { _
    int n;
    ll f = 1;
    for (int i = 2; i < 3e6; i++) {
        f = (f*i) % M;
        fat.pb(f);
    }
    cin >> n;
    if (n&1) cout << "0\n";
    else {
        n /= 2;
        ll ans = ((ll)fat[2*n] * fexp(fat[n], M-2)) % M;
        ans = (ans * fexp(n+1, M-2)) % M;
        ans = (ans * fexp(fat[n], M-2)) % M;
        cout << ans << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1757
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
vector<int> v[MAXN];
int deg[MAXN], ans1[MAXN], ans2[MAXN];
 
int main () { _
	int n, m;
	cin >> n >> m;
	set<int> s;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[b].pb(a);
		deg[a]++;
	}
	for (int i = 1; i <= n; i++) 
		if (!deg[i]) s.insert(i);
	int cnt = n;
	while (!s.empty()) {
		auto x = s.end();
		x--;
		int a = *x;
		s.erase(a);
		ans1[a] = cnt--;
		for (int x : v[a]) {
			deg[x]--;
			if (!deg[x]) s.insert(x);
		}
	}
	for (int i = 1; i <= n; i++) ans2[ans1[i]] = i;
	for (int i = 1; i <= n; i++) cout << ans2[i] << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1756
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
vector<int> v[MAXN];
vector<pii> edg;
int lvl[MAXN];
 
void dfs(int node, int pai) {
	lvl[node] = lvl[pai]+1;
	for (int x : v[node]) 
		if (!lvl[x]) dfs(x, node);
}
 
int main () { _
	int n, m, a, b;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
		edg.pb({a, b});
	}
	for (int i = 1; i <= n; i++) if (!lvl[i]) dfs(i, 0);
	for (pii x : edg) {
		if (lvl[x.F] > lvl[x.S]) cout << x.S << ' ' << x.F << '\n';
		else cout << x.F << ' ' << x.S << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2205
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
 
using namespace std;
typedef long long int lli;
 
vector <string> v(MAXN);
 
int main() { _
    int n, atual = 2, tam = 2;
    cin >> n;
    v[0] = '0';
    v[1] = '1';
    while (atual <= n) {
        for (int i = 0; i < tam; i++) {
            v[2*tam-i-1] = v[i];
            v[i].push_back('0');
            v[2*tam-i-1].push_back('1');
        }
        tam *= 2;
        atual++;
    }
    for (int i = 0; i < tam; i++) {
        cout << v[i] << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1755
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
 
using namespace std;
typedef long long int lli;
 
const int big = 1e9+7;
 
int c[27], impar = 0, id_i;
 
int main() { _
    string s;
    vector<char> pa;
    cin >> s;
    for (int i = 0; i < (int)s.size(); i++) {
        c[s.at(i)-64]++;
    }
    for (int i = 1; i <= 26; i++) {
        if (c[i] % 2 != 0) {
            impar++;
            id_i = i;
        }
    }
    if (impar > 1) cout << "NO SOLUTION" << endl;
    else {
        for (int i = 1; i <= 26; i++) {
            for (int j = 0; j < c[i]/2; j++) {
                pa.push_back(i+64);
            }
        }
        for (int i = 0; i < (int)pa.size(); i++) {
            cout << pa[i];
        }
        if (impar == 1) cout << (char)(id_i+64);
        for (int i = (int)pa.size()-1; i >= 0; i--) {
            cout << pa[i];
        }
        cout << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1754
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
const int big = 1e9+7;
 
int main() { _
    int t, a, b;
    bool ber;
    cin >> t;
    for (int i = 0; i < t; i++) {
        ber = true;
        cin >> a >> b;
        int mod1 = a%3;
        int mod2 = b%3;
        if (a > 2*b or b > 2*a) ber = false;
        if ((mod1 == 0 and mod2 != 0) or (mod2 == 0 and mod1 != 0)) ber = false;
        if ((mod1 == 1 and mod2 != 2) or (mod2 == 1 and mod1 != 2)) ber = false;
        if ((mod1 == 2 and mod2 != 1) or (mod2 == 2 and mod1 != 1)) ber = false;
        if (ber) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1753
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int pre[MAXN], pwr[MAXN];
 
int main () { _
	string s1, s2;
	cin >> s1 >> s2;
	int tam1 = (int)s1.size(), tam2 = (int)s2.size();
	if (tam2 > tam1) cout << "0\n";
	else {
		pwr[0] = 1;
		int h = 0;
		for (int i = 1; i <= 1e6; i++) pwr[i] = (1ll * pwr[i-1] * 31) % M;
		for (int i = 0; i < tam1; i++) {
			if (i < tam2) 
				h = (h + (s2[i] - 'a' + 1ll) * pwr[i]) % M;
			pre[i] = ((!i ? 0 : pre[i-1]) + (s1[i] - 'a' + 1ll) * pwr[i]) % M;
		}
		int ans = 0;
		for (int i = tam2-1; i < tam1; i++) {
			ans += (((pre[i] - (i == tam2-1 ? 0 : pre[i-tam2]) + M) % M) == ((1ll * h * pwr[i-tam2+1]) % M));
		}
		cout << ans << '\n';
	}
 
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2073
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const ll INF = 2e18;
 
struct node {
    node *L, *R;
    int prio, sz;
    char c;
    bool rev;
    node (char _c) {
        L = 0, R = 0, prio = rng(), sz = 1, c = _c, rev = false;
    }
};
 
int size(node *treap) {
    if (!treap) return 0;
    return treap->sz;
}
 
void push(node *treap) {
    if (treap && treap->rev) {
        treap->rev = false;
        swap(treap->L, treap->R);
        if (treap->L) treap->L->rev ^= true;
        if (treap->R) treap->R->rev ^= true;
    }
}
 
void recalc(node *&treap) {
    if (!treap) return;
    treap->sz = size(treap->L) + size(treap->R) + 1;
}
 
void split(node *treap, node *&L, node *&R, int k) {
    if (!treap) {
        L = R = 0;
    }
    else {
        push(treap);
        if (size(treap->L) >= k) {
            split(treap->L, L, treap->L, k);
            R = treap;
        }
        else {
            split(treap->R, treap->R, R, k - size(treap->L) - 1);
            L = treap;
        }
        recalc(treap);
    }
}
 
void merge(node *&treap, node *L, node *R) {
    if (!L) treap = R;
    else if (!R) treap = L;
    else {
        push(L), push(R);
        if (L->prio > R->prio) {
            merge(L->R, L->R, R);
            treap = L;
        }
        else {
            merge(R->L, L, R->L);
            treap = R;
        }
        recalc(treap);
    }
}
 
void print(node *treap) {
    if (!treap) return;
    push(treap);
    print(treap->L);
    cout << treap->c;
    print(treap->R);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, l, r;
    string s;
    cin >> n >> m >> s;
    node *root = 0;
    for (int i = 0; i < n; i++) {
        merge(root, root, new node(s[i]));
    }
    for (int i = 0; i < m; i++) {
        cin >> l >> r;
        node *a, *b, *c;
        split(root, a, b, l - 1);
        split(b, b, c, r - l + 1);
        b->rev ^= true;
        merge(root, a, b);
        merge(root, root, c);
    }
    print(root);
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1751
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int dist[MAXN], v[MAXN], cor[MAXN];
 
void dfs(int node) {
	cor[node] = 1;
	if (cor[v[node]] == 0) {
		dfs(v[node]);
		if (!dist[node]) dist[node] = dist[v[node]]+1;
	}
	else if (cor[v[node]] == 1) {
		// ciclo
		int atual = node, p = 0;
		do {
			p++;
			atual = v[atual];
		} while (atual != node);
		do {
			dist[atual] = p;
			atual = v[atual];
		} while (atual != node);
	}
	else {
		dist[node] = dist[v[node]]+1;
	}
	cor[node] = 2;
}
 
int main() { _
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> v[i];
	for (int i = 1; i <= n; i++) {
		if (!cor[i]) dfs(i);
	}
	for (int i = 1; i <= n; i++) cout << dist[i] << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1750
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int tab[31][MAXN];
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> tab[0][i];
	}
	for (int i = 1; i < 31; i++) {
		for (int j = 1; j <= n; j++) {
			tab[i][j] = tab[i-1][tab[i-1][j]];
		}
	}
	for (int i = 0; i < q; i++) {
		int a, b;
		cin >> a >> b;
		int atual = a;
		for (int j = 0; j < 31; j++) {
			if (b & (1<<j)) atual = tab[j][atual];
		}
		cout << atual << '\n';
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1749
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int a[4*MAXN];
 
void build(int node, int i, int j) {
	if (i == j) a[node] = 1;
	else {
		int m = (i+j)/2;
		build(2*node, i, m);
		build(2*node+1, m+1, j);
		a[node] = a[2*node] + a[2*node+1];
	}
}
 
int ans(int node, int i, int j, int k) {
	a[node]--;
	if (i == j) {
		return i;
	}
	else {
		int m = (i+j)/2;
		if (a[2*node] >= k) 
			return ans(2*node, i, m, k);
		else 
			return ans(2*node+1, m+1, j, k-a[2*node]);
	}
}
 
int main () { _
	int n, aux;
	cin >> n;
	vector<int> v(n+1);
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	build(1, 1, n);
	for (int i = 0; i < n; i++) {
		cin >> aux;
		cout << v[ans(1, 1, n, aux)] << ' ';
	}	
	cout << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1748
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
ll a[MAXN], dp[MAXN];
int v[MAXN];
 
void upd(int pos, ll val) { for (; pos < MAXN; pos += (pos & -pos)) a[pos] = (a[pos] + val) % M; }
 
ll sum(int pos) {
	ll ans = 1;
	for (; pos > 0; pos -= (pos & -pos)) {
		ans += a[pos];
		if (ans >= M) ans -= M;
	}
	return ans;
}
 
int main () { _
	int n;
	cin >> n;
	vector<int> w;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		w.pb(v[i]);
	}
	sort(w.begin(), w.end());
	w.erase(unique(w.begin(), w.end()), w.end());
	for (int i = 1; i <= n; i++) {
		v[i] = upper_bound(w.begin(), w.end(), v[i]) - w.begin();
	}
	for (int i = 1; i <= n; i++) {
		dp[i] += sum(v[i]-1);
		dp[i] %= M;
		upd(v[i], dp[i]);
	}
	cout << sum(MAXN-1) - 1 << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1747
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
int a[MAXN];
 
void add(int pos, int val) {
    for (; pos < MAXN; pos += (pos & -pos)) a[pos] += val;
}
 
int sum(int pos) {
    int ans = 0;
    for (; pos; pos -= (pos & -pos)) ans += a[pos];
    return ans;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    vector<pii> v(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i].first;
        v[i].second = i + 1;
        add(i + 1, 1);
    }
    sort(v.begin(), v.end());
    ll ans = 0;
    for (int i = 0; i < n; i++) {
        ans += min(sum(n) - sum(v[i].second), sum(v[i].second - 1));
        add(v[i].second, -1);
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1746
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, m;
    cin >> n >> m;
    vector<int> v(n);
    for (int i = 0; i < n; i++) cin >> v[i];
    vector<vector<ll>> dp(n+1, vector<ll> (m+2, 0));
    for (int i = 1; i <= m; i++) {
        if (!v[0] || v[0] == i) dp[0][i] = 1;
    }    
    for (int i = 1; i < n; i++) {
        for (int j = 1; j <= m; j++) {
            if (!v[i] || v[i] == j) {
                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1]) % M;
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= m; i++) {
        if (v[n-1] == i || !v[n-1]) {
            ans += dp[n-1][i];
            if (ans >= M) ans -= M;
        }
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1745
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n;
    cin >> n;
    vector<int> v(n);
    for (int i = 0; i < n; i++) cin >> v[i];
    vector<int> dp(1e5 + 5);
    dp[0] = 1;
    int c = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 1e5; j >= 0; j--) {
            if (dp[j] && j+v[i] <= 1e5) {
                c += (dp[j+v[i]] == 0);
                dp[j+v[i]] = 1;
            }
        }
    }
    cout << c << '\n';
    for (int i = 1; i <= 1e5; i++) 
        if (dp[i]) cout << i << ' ';
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1744
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int a, b;
    cin >> a >> b;
    vector<vector<int>> dp(505, vector<int> (505, INF));
    for (int i = 1; i <= a; i++) {
        dp[i][i] = 0;
        for (int j = 1; j <= b; j++) {
            for (int k = 1; k < j; k++) {
                dp[i][j] = min(dp[i][j], 1 + dp[i][j-k] + dp[i][k]);
            }
            for (int k = 1; k < i; k++) {
                dp[i][j] = min(dp[i][j], 1 + dp[i-k][j] + dp[k][j]);
            }
        }
    }
    cout << dp[a][b] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2084
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2105
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
void count_sort(vector<int> &p, vector<int> &c) {
    int n = p.size();
    vector<int> cnt(n);
    for (auto x : c) cnt[x]++;
    vector<int> p_new(n), pos(n);
    pos[0] = 0;
    for (int i = 1; i < n; i++) {
        pos[i] = pos[i - 1] + cnt[i - 1];
    }
    for (auto x : p) {
        p_new[pos[c[x]]] = x;
        pos[c[x]]++;
    }
    p = p_new;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    s += '$';
    int n = s.size();
    vector<int> p(n), c(n);
    {
        vector<pair<char, int>> a(n);
        for (int i = 0; i < n; i++) a[i] = {s[i], i};
        sort(a.begin(), a.end());
        for (int i = 0; i < n; i++) p[i] = a[i].second;
        c[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            if (a[i - 1].first == a[i].first) c[p[i]] = c[p[i - 1]];
            else c[p[i]] = c[p[i - 1]] + 1;
        }
    }
    int k = 0;
    while ((1 << k) < n) {
        for (int i = 0; i < n; i++) p[i] = (p[i] - (1 << k) + n) % n;
        count_sort(p, c);
        vector<int> c_new(n);
        c_new[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            pii prev = {c[p[i - 1]], c[(p[i - 1] + (1 << k)) % n]};
            pii now = {c[p[i]], c[(p[i] + (1 << k)) % n]};
            if (prev == now) c_new[p[i]] = c_new[p[i - 1]];
            else c_new[p[i]] = c_new[p[i - 1]] + 1;
        }
        c = c_new;
        k++;
    }
    vector<int> lcp(n);
    k = 0;
    for (int i = 0; i < n - 1; i++) {
        int pi = c[i];
        int j = p[pi - 1];
        while (s[i + k] == s[j + k]) k++;
        lcp[pi] = k;
        k = max(k - 1, 0);
    }
    ll ans = (1ll * n * (n - 1)) / 2;
    for (int i = 1; i < n; i++) ans -= lcp[i];
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2104
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
 
#define PB push_back
 
string S;
int K, I = 1, ans[500005], sz[500005];
 
vector<int> adj[500005];
 
struct node {
    int fail, ch[26] = {}, cnt = 1e9;
    vector<int> word;
} T[500005];
 
void insert(string s, int i) {
    int x = 1;
    for (int i = 0; i < s.size(); i++) {
        if (T[x].ch[s[i] - 'a'] == 0)
            T[x].ch[s[i] - 'a'] = ++I;
        x = T[x].ch[s[i] - 'a'];
    }
    T[x].word.PB(i);
}
 
void build() {
    queue<int> Q;
    int x = 1; 
    T[1].fail = 1;
    for (int i = 0; i < 26; i++) {
        if (T[x].ch[i])
            T[T[x].ch[i]].fail = x, Q.push(T[x].ch[i]);
        else 
            T[x].ch[i] = 1;
    }
    while (!Q.empty()) {
        x = Q.front(); Q.pop();
        for (int i = 0; i < 26; i++) {
            if (T[x].ch[i])
                T[T[x].ch[i]].fail = T[T[x].fail].ch[i], Q.push(T[x].ch[i]);
            else 
                T[x].ch[i] = T[T[x].fail].ch[i];
        }
    }
    for (int i = 2; i <= I; i++)
        adj[T[i].fail].PB(i);
}
 
void run(string s) {
    for (int i = 0, x = 1; i < s.size(); i++) {
        x = T[x].ch[s[i] - 'a'];
        T[x].cnt = min(T[x].cnt, i);
    }
}
 
int dfs(int u) {
    int res = T[u].cnt;
    for (int v : adj[u])
        res = min(res, dfs(v));
    for (int w : T[u].word)
        ans[w] = res;
    return res;
}
 
int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    
    cin >> S >> K;
    for (int i = 0; i < K; i++) {
        string s; cin >> s;
        sz[i] = s.size();
        insert(s, i);
    }
 
    build();
    run(S);
    dfs(1);
 
    for (int i = 0; i < K; i++)
        cout << (ans[i] == 1e9 ? -1 : ans[i] - sz[i] + 2) << '\n';
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2103
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
 
#define PB push_back
 
string S;
int K, I = 1, ans[500005];
 
vector<int> adj[500005];
 
struct node {
    int fail, ch[26] = {}, cnt = 0;
    vector<int> word;
} T[500005];
 
void insert(string s, int i) {
    int x = 1;
    for (int i = 0; i < s.size(); i++) {
        if (T[x].ch[s[i] - 'a'] == 0)
            T[x].ch[s[i] - 'a'] = ++I;
        x = T[x].ch[s[i] - 'a'];
    }
    T[x].word.PB(i);
}
 
void build() {
    queue<int> Q;
    int x = 1; 
    T[1].fail = 1;
    for (int i = 0; i < 26; i++) {
        if (T[x].ch[i])
            T[T[x].ch[i]].fail = x, Q.push(T[x].ch[i]);
        else 
            T[x].ch[i] = 1;
    }
    while (!Q.empty()) {
        x = Q.front(); Q.pop();
        for (int i = 0; i < 26; i++) {
            if (T[x].ch[i])
                T[T[x].ch[i]].fail = T[T[x].fail].ch[i], Q.push(T[x].ch[i]);
            else 
                T[x].ch[i] = T[T[x].fail].ch[i];
        }
    }
    for (int i = 2; i <= I; i++)
        adj[T[i].fail].PB(i);
}
 
void run(string s) {
    for (int i = 0, x = 1; i < s.size(); i++) {
        x = T[x].ch[s[i] - 'a'];
        T[x].cnt++;
    }
}
 
int dfs(int u) {
    int res = T[u].cnt;
    for (int v : adj[u])
        res += dfs(v);
    for (int w : T[u].word)
        ans[w] = res;
    return res;
}
 
int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    
    cin >> S >> K;
    for (int i = 0; i < K; i++) {
        string s; cin >> s;
        insert(s, i);
    }
 
    build();
    run(S);
    dfs(1);
 
    for (int i = 0; i < K; i++)
        cout << ans[i] << '\n';
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2102
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
 
#define PB push_back
 
string S;
int K, I = 1, ans[500005];
 
vector<int> adj[500005];
 
struct node {
    int fail, ch[26] = {}, cnt = 0;
    vector<int> word;
} T[500005];
 
void insert(string s, int i) {
    int x = 1;
    for (int i = 0; i < s.size(); i++) {
        if (T[x].ch[s[i] - 'a'] == 0)
            T[x].ch[s[i] - 'a'] = ++I;
        x = T[x].ch[s[i] - 'a'];
    }
    T[x].word.PB(i);
}
 
void build() {
    queue<int> Q;
    int x = 1; 
    T[1].fail = 1;
    for (int i = 0; i < 26; i++) {
        if (T[x].ch[i])
            T[T[x].ch[i]].fail = x, Q.push(T[x].ch[i]);
        else 
            T[x].ch[i] = 1;
    }
    while (!Q.empty()) {
        x = Q.front(); Q.pop();
        for (int i = 0; i < 26; i++) {
            if (T[x].ch[i])
                T[T[x].ch[i]].fail = T[T[x].fail].ch[i], Q.push(T[x].ch[i]);
            else 
                T[x].ch[i] = T[T[x].fail].ch[i];
        }
    }
    for (int i = 2; i <= I; i++)
        adj[T[i].fail].PB(i);
}
 
void run(string s) {
    for (int i = 0, x = 1; i < s.size(); i++) {
        x = T[x].ch[s[i] - 'a'];
        T[x].cnt++;
    }
}
 
int dfs(int u) {
    int res = T[u].cnt;
    for (int v : adj[u])
        res += dfs(v);
    for (int w : T[u].word)
        ans[w] = res;
    return res;
}
 
int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    
    cin >> S >> K;
    for (int i = 0; i < K; i++) {
        string s; cin >> s;
        insert(s, i);
    }
 
    build();
    run(S);
    dfs(1);
 
    for (int i = 0; i < K; i++)
        cout << (ans[i] ? "YES\n" : "NO\n");
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2101
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
int sz[MAXN], pai[MAXN], te[MAXN];
 
int find(int x) {
    if (x == pai[x]) return x;
    return find(pai[x]);
}
 
void join(int a, int b, int t) {
    a = find(a), b = find(b);
    if (a == b) return;
    if (sz[a] < sz[b]) swap(a, b);
    pai[b] = a;
    if (sz[a] == sz[b]) sz[a]++;
    te[b] = t;
}
 
int query(int a, int b) {
    int ans = 0;
    if (find(a) != find(b)) return -1;
    while (a != b) {
        if (te[a] > te[b]) {
            ans = te[b];
            b = pai[b];
        }
        else {
            ans = te[a];
            a = pai[a];
        }
    }
    return ans;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, q, a, b;
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++) pai[i] = i, sz[i] = 1, te[i] = m + 1;
    for (int i = 1; i <= m; i++) {
        cin >> a >> b;
        join(a, b, i);
    }
    for (int i = 0; i < q; i++) {
        cin >> a >> b;
        cout << query(a, b) << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2088
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int v[5050], pos[5050][5050];
ll dp[5050][5050], pre[5050];
 
int main () { _
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		pre[i] = pre[i-1] + v[i];
		pos[i][i] = i;
	}
	for (int tam = 1; tam < n; tam++) {
		for (int i = 1; i+tam <= n; i++) {
			int j = i+tam;
			dp[i][j] = dp[i][pos[i][j-1]] + dp[pos[i][j-1]+1][j] + pre[j] - pre[i-1];
			pos[i][j] = pos[i][j-1];
			for (int k = pos[i][j]+1; k <= pos[i+1][j]; k++) {
				if (dp[i][k] + dp[k+1][j] + pre[j] - pre[i-1] < dp[i][j]) {
					dp[i][j] = dp[i][k] + dp[k+1][j] + pre[j] - pre[i-1];
					pos[i][j] = k;
				}
			}
		} 
	}
	cout << dp[1][n] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2087
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2086
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1743
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
vector<int> v(26);
string s;
 
bool valid(int n) {
    int maxi = 0;
    for (int i = 0; i < 26; i++) maxi = max(maxi, v[i]);
    if (maxi > n - maxi + 1) return false;
    return true;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> s;
    int maxi = 0, n = s.size();
    for (auto x : s) {
        v[x-'A']++;
        maxi = max(maxi, v[x-'A']);
    }
    if (maxi > n - maxi + 1) cout << "-1\n";
    else {
        string ans;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < 26; j++) {
                if (v[j] && (!i ? true : (ans[i-1] != (('A' + j))))) {
                    v[j]--;
                    ans += ('A'+j);
                    if (valid(n - i - 1)) break;
                    else {
                        v[j]++;
                        ans.pop_back();
                    }
                }
            }
        }
        cout << ans << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2081
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
vector<int> v[MAXN];
int sz[MAXN], n, k1, k2, mx;
ll ans, a[MAXN];
bool vis[MAXN];
 
void upd(int pos, int val) {
    for (pos++; pos < MAXN; pos += pos & -pos) a[pos] += val;
}
 
ll query(int l, int r) {
    ll ans = 0;
    for (; l; l -= l & -l) ans -= a[l];
    for (r++; r; r -= r & -r) ans += a[r];
    return ans;
}
 
int subtree(int node, int pai = 0) {
    sz[node] = 1;
    for (int x : v[node]) {
        if (!vis[x] && x != pai) {
            sz[node] += subtree(x, node);
        }
    }
    return sz[node];
}
 
int centroid(int node, int desired, int pai = 0) {
    for (int x : v[node]) {
        if (!vis[x] && x != pai && sz[x] >= desired) {
            return centroid(x, desired, node);
        }
    }
    return node;
}
 
void get_cnt(int node, int pai, bool filling, int depth) {
    if (depth > k2) return;
    mx = max(mx, depth);
    if (filling) {
        upd(depth, 1);
    }
    else {
        ans += query(max(0, k1 - depth), k2 - depth);
    }
    for (int x : v[node]) {
        if (!vis[x] && x != pai) {
            get_cnt(x, node, filling, depth + 1);
        }
    }
}
 
void solve(int node) {
    int c = centroid(node, subtree(node) / 2);
    vis[c] = true;
    mx = 0;
    for (int x : v[c]) {
        if (!vis[x]) {
            get_cnt(x, c, false, 1);
            get_cnt(x, c, true, 1);
        }
    }
    for (int i = 1; i <= mx; i++) upd(i, -query(i, i));
    for (int x : v[c]) {
        if (!vis[x]) {
            solve(x);
        }
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> k1 >> k2;
    int a, b;
    for (int i = 0; i < n - 1; i++) {
        cin >> a >> b;
        v[a].push_back(b);
        v[b].push_back(a);
    }
    upd(0, 1);
    solve(1);
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2080
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
vector<int> v[MAXN];
int sz[MAXN], cnt[MAXN]{1}, n, k, mx;
ll ans;
bool vis[MAXN];
 
int subtree(int node, int pai = 0) {
    sz[node] = 1;
    for (int x : v[node]) {
        if (!vis[x] && x != pai) {
            sz[node] += subtree(x, node);
        }
    }
    return sz[node];
}
 
int centroid(int node, int desired, int pai = 0) {
    for (int x : v[node]) {
        if (!vis[x] && x != pai && sz[x] > desired) {
            return centroid(x, desired, node);
        }
    }
    return node;
}
 
void get_cnt(int node, int pai, bool filling, int depth) {
    if (depth > k) return;
    mx = max(mx, depth);
    if (filling) {
        cnt[depth]++;
    }
    else {
        ans += cnt[k - depth];
    }
    for (int x : v[node]) {
        if (!vis[x] && x != pai) {
            get_cnt(x, node, filling, depth + 1);
        }
    }
}
 
void solve(int node) {
    int c = centroid(node, subtree(node) / 2);
    vis[c] = true;
    mx = 0;
    for (int x : v[c]) {
        if (!vis[x]) {
            get_cnt(x, c, false, 1);
            get_cnt(x, c, true, 1);
        }
    }
    fill(cnt + 1, cnt + mx + 1, 0);
    for (int x : v[c]) {
        if (!vis[x]) {
            solve(x);
        }
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> k;
    int a, b;
    for (int i = 0; i < n - 1; i++) {
        cin >> a >> b;
        v[a].push_back(b);
        v[b].push_back(a);
    }
    solve(1);
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2079
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M1 = 1e9+7, M2 = 998244353;
 
vector<int> v[MAXN];
int dp[MAXN], valid[MAXN], n;
 
void dfs(int node, int pai) {
	dp[node] = 1;
	bool ok = true;
	for (int x : v[node]) {
		if (x != pai) {
			dfs(x, node);
			dp[node] += dp[x];
			ok &= (dp[x] <= (n/2));
		}
	}
	ok &= (n - dp[node] <= (n/2));
	valid[node] = ok;
}
 
int main() { _
	cin >> n;
	for (int i = 0; i < n-1; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	dfs(1, -1);
	for (int i = 1; i <= n; i++) 
		if (valid[i]) {
			cout << i << '\n';
			break;
		}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2078
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int fexp(ll b, int e) {
	if (e < 0) return 1;
	ll resp = 1;
	while (e) {
		if (e&1) resp = (resp * b) % M;
		b = (b * b) % M;
		e >>= 1;
	}
	return resp;
}
 
vector<int> v[MAXN];
int vis[MAXN];
 
void dfs(int node) {
	vis[node] = 1;
	for (int x : v[node]) {
		if (!vis[x]) dfs(x);
	}
}
 
int main() { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	int cnt = 0;
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			cnt++;
			dfs(i);
		}
	}
	cout << fexp(2, m - n + cnt) << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2077
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
vector<int> v[MAXN];
int low[MAXN], nec[MAXN], cnt = 0, vis[MAXN];
 
void dfs(int node, int pai) {
	vis[node] = ++cnt;
	low[node] = cnt;
	int filhos = 0;
	for (int x : v[node]) {
		if (!vis[x]) {
			filhos++;
			dfs(x, node);
			low[node] = min(low[node], low[x]);
		}
		else if (x != pai) low[node] = min(low[node], vis[x]);
	}
	if (node == 1) nec[node] = (filhos > 1);
	else if (low[node] >= vis[pai] && pai > 1) nec[pai] = 1;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	dfs(1, -1);
	vector<int> ans;
	for (int i = 1; i <= n; i++) 
		if (nec[i]) ans.push_back(i);
	cout << ans.size() << '\n';
	for (auto x : ans) cout << x << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2076
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
vector<int> v[MAXN];
vector<pii> edges;
int vis[MAXN], dp[MAXN], dep[MAXN];
 
void dfs(int node, int pai) {
	dep[node] = dep[pai] + 1;
	vis[node] = 1;
	for (int x : v[node]) {
		if (x == pai) continue;
		if (vis[x]) {
			if (dep[node] > dep[x]) dp[node]--;
			else dp[node]++;
		}
		else {
			dfs(x, node);
			dp[node] += dp[x];
		}
	}
	if (!dp[node] && node > 1) edges.emplace_back(node, pai);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	dfs(1, -1);
	cout << edges.size() << '\n';
	for (auto x : edges) cout << x.first << ' ' << x.second << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2075
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
struct node {
    node *L, *R;
    int prio, sz, val, mn;
    bool rev;
    node (int _val = MAXN) {
        L = 0, R = 0, prio = rng(), sz = 1, val = mn = _val, rev = false;
    }
};
 
int size(node *treap) {
    if (!treap) return 0;
    return treap->sz;
}
 
int mini(node *treap) {
    if (!treap) return MAXN;
    return treap->mn;
}
 
void push(node *treap) {
    if (treap && treap->rev) {
        treap->rev = false;
        swap(treap->L, treap->R);
        if (treap->L) treap->L->rev ^= true;
        if (treap->R) treap->R->rev ^= true;
    }
}
 
void recalc(node *&treap) {
    if (!treap) return;
    treap->sz = size(treap->L) + size(treap->R) + 1;
    treap->mn = min({treap->val, mini(treap->L), mini(treap->R)});
}
 
void split(node *treap, node *&L, node *&R, int k) {
    if (!treap) {
        L = R = 0;
    }
    else {
        push(treap);
        if (size(treap->L) >= k) {
            split(treap->L, L, treap->L, k);
            R = treap;
        }
        else {
            split(treap->R, treap->R, R, k - size(treap->L) - 1);
            L = treap;
        }
        recalc(treap);
    }
}
 
void merge(node *&treap, node *L, node *R) {
    if (!L) treap = R;
    else if (!R) treap = L;
    else {
        push(L), push(R);
        if (L->prio > R->prio) {
            merge(L->R, L->R, R);
            treap = L;
        }
        else {
            merge(R->L, L, R->L);
            treap = R;
        }
        recalc(treap);
    }
}
 
int query(node *treap) {
    push(treap);
    int a = mini(treap->L), b = treap->val, c = mini(treap->R), d = min({a, b, c});
    if (a == d) return query(treap->L);
    else if (b == d) return size(treap->L) + 1;
    else return size(treap->L) + 1 + query(treap->R);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, x;
    cin >> n;
    node *root = 0;
    for (int i = 1; i <= n; i++) {
        cin >> x;
        merge(root, root, new node(x));
    }
    cout << n << endl;
    for (int i = 1; i <= n; i++) {
        //put i in its place
        
        node *a, *b, *c;
        split(root, a, b, i - 1);
        int pos = query(b);
        split(b, b, c, pos);
        b->rev ^= true;
        merge(b, b, c);
        merge(root, a, b);
        cout << i << ' ' << pos + i - 1 << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2074
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const ll INF = 2e18;
 
struct node {
    node *L, *R;
    int prio, sz, val; 
    ll sum;
    bool rev;
    node (int _val = 0) {
        L = 0, R = 0, prio = rng(), sz = 1, val = sum = _val, rev = false;
    }
};
 
int size(node *treap) {
    if (!treap) return 0;
    return treap->sz;
}
 
ll sum(node *treap) {
    if (!treap) return 0ll;
    return treap->sum;
}
 
void push(node *treap) {
    if (treap && treap->rev) {
        treap->rev = false;
        swap(treap->L, treap->R);
        if (treap->L) treap->L->rev ^= true;
        if (treap->R) treap->R->rev ^= true;
    }
}
 
void recalc(node *&treap) {
    if (!treap) return;
    treap->sz = size(treap->L) + size(treap->R) + 1;
    treap->sum = sum(treap->L) + sum(treap->R) + treap->val;
}
 
void split(node *treap, node *&L, node *&R, int k) {
    if (!treap) {
        L = R = 0;
    }
    else {
        push(treap);
        if (size(treap->L) >= k) {
            split(treap->L, L, treap->L, k);
            R = treap;
        }
        else {
            split(treap->R, treap->R, R, k - size(treap->L) - 1);
            L = treap;
        }
        recalc(treap);
    }
}
 
void merge(node *&treap, node *L, node *R) {
    if (!L) treap = R;
    else if (!R) treap = L;
    else {
        push(L), push(R);
        if (L->prio > R->prio) {
            merge(L->R, L->R, R);
            treap = L;
        }
        else {
            merge(R->L, L, R->L);
            treap = R;
        }
        recalc(treap);
    }
}
 
ll query(node *treap, int k) {
    if (!treap) return 0;
    else {
        push(treap);
        if (size(treap->L) >= k) {
            return query(treap->L, k);
        }
        else {
            return sum(treap->L) + query(treap->R, k - size(treap->L) - 1) + treap->val;
        }
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, tipo, l, r;
    cin >> n >> m;
    node *root = 0;
    for (int i = 0; i < n; i++) {
        cin >> tipo;
        merge(root, root, new node(tipo));
    }
    for (int i = 0; i < m; i++) {
        node *a, *b, *c;
        cin >> tipo >> l >> r;
        if (tipo == 1) {
            split(root, a, b, l - 1);
            split(b, b, c, r - l + 1);
            b->rev ^= true;
            merge(root, a, b);
            merge(root, root, c);
        }
        else {
            cout << query(root, r) - query(root, l - 1) << '\n';
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1707
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2505
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
vector<int> v[MAXN];
int dist[MAXN];
 
int main() { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	int ans = MAXN;
	for (int i = 1; i <= n; i++) {
		memset(dist, -1, sizeof(dist));
		dist[i] = 0;
		queue<int> fila;
		fila.push(i);
		int achei = MAXN, atual;
		while (!fila.empty() && dist[atual] <= achei) {
			atual = fila.front();
			fila.pop();
			for (int x : v[atual]) {
				if (dist[x] == -1) {
					dist[x] = dist[atual]+1;
					fila.push(x);
				}
				else if (dist[x] >= dist[atual]) {
					ans = min(ans, dist[x] + dist[atual] + 1);
					achei = dist[atual];
				}
			}
		}
	}
	cout << (ans==MAXN ? -1 : ans) << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1722
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
typedef vector<vector<ll>> matriz;
 
matriz mat;
 
matriz mult(matriz a, matriz b) {
	matriz c(2, vector<ll> (2));
	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < 2; j++) {
			for (int k = 0; k < 2; k++) {
				c[i][j] = (c[i][j] + (a[i][k] * b[k][j]) % M) % M;
			}
		}
	}
	return c;
}
 
matriz expo(matriz a, ll e) {
	if (e == 1) return a;
	matriz ans = expo(a, e/2);
	ans = mult(ans, ans);
	if (e&1) ans = mult(ans, a);
	return ans;
}
 
int main () { _
	ll n;
	cin >> n;
	if (!n) cout << "0\n";
	else if (n == 1) cout << "1\n";
	else {
		matriz c (2, vector<ll> (2)); 
		c = {{1, 1}, {1, 0}};
		c = expo(c, n-1);
		cout << c[0][0] % M << '\n';
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1717
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n;
    cin >> n;
    ll ans = 0;
    for (int i = 2; i <= n; i++) {
        ans = (ans * i + (i&1 ? - 1 : 1)) % M;
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1716
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> fat(2, 1);
 
int fexp(ll b, int e) {
    ll resp = 1;
    while(e) {
        if(e&1) resp = (resp * b) % M;
        b = (b*b) % M;
        e = (e>>1);
    }
    return resp;
}
 
int main () { _
    ll f = 1;
    for (int i = 2; i < 3e6; i++) {
        f = (f*i) % M;
        fat.pb(f);
    }
    int n, m;
    cin >> n >> m;
    ll ans = ((ll)fat[n+m-1] * fexp(fat[n-1], M-2)) % M;
    ans = (ans * fexp(fat[m], M-2)) % M;
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1715
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, int e) {
    ll resp = 1;
    while (e) {
        if (e&1) resp = (resp * b) % M;
        e >>= 1;
        b = (b * b) % M;
    }
    return resp;
}
 
int main () { _
    string s;
    cin >> s;
    vector<int> v(30), fat(1e6+10);
    int n = (int)s.size();
    for (int i = 0; i < n; i++) {
        v[s[i] - 'a']++;
    }
    ll ans = 1;
    fat[0] = fat[1] = 1;
    for (int i = 2; i <= n; i++) {
        ans = (ans * i) % M;
        fat[i] = ans;
    }
    for (int i = 0; i < 30; i++) {
        ans = (ans * fexp(fat[v[i]], M-2)) % M;
    }
    cout << ans << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1713
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int t;
    cin >> t;
    vector<int> div(MAXN, 1);
    for (int i = 2; i < 1e6+1; i++) {
        for (int j = i; j < 1e6+1; j+=i) div[j]++;
    }
    while (t--) {
        int n;
        cin >> n;
        cout << div[n] << '\n';
    }    
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1712
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 10010
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, int e, int MOD) {
    ll resp = 1;
    while (e) {
        if (e&1) {
            resp = (resp * b) % MOD;
        }
        e = (e >> 1);
        b = (b * b) % MOD;
    }
    return resp;
}
 
int main () { _
    int n;
    cin >> n;
    while(n--) {
        int a, b, c;
        cin >> a >> b >> c;
        cout << fexp(a, fexp(b, c, M-1), M) << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1711
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int n;
int vis[505], mat[505][505];
vector<vector<int>> residualGraph;
 
bool bfs(vector<vector<int>>& residualGraph, vector<int>& level, int source, int sink) {
    fill(level.begin(), level.end(), -1);
	level[source] = 0;
	
	queue<int> q;
	q.push(source);
 
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		for (int v=0; v < n; v++)
		{
			if (u != v && residualGraph[u][v] > 0 && level[v] < 0)
			{
 
				level[v] = level[u] + 1;
				q.push(v);
			}
		}
	}
	return level[sink] < 0 ? false : true ;
}
 
int sendFlow(vector<vector<int>>& residualGraph, vector<int>& level, vector<int>& count, int u, int sink, int flow) {
	if (u == sink)
		return flow;
 
    if (count[u] == (int)residualGraph[u].size())
	    return 0;
 
	for (int v=0; v < n; v++)
	{
		if (residualGraph[u][v] > 0)
		{
		    count[u]++;
			if (level[v] == level[u]+1)
			{
			 	int curr_flow = min(flow, residualGraph[u][v]);
 
			    int min_cap = sendFlow(residualGraph, level, count, v, sink, curr_flow);
			    if (min_cap > 0)
			    {
                    residualGraph[u][v] -= min_cap;
                    residualGraph[v][u] += min_cap;
					mat[u][v] = -1;
					mat[v][u] = 1;
				    return min_cap;
			    }
			}
		}
	}
	return 0;
}
 
int dinic_algorithm(vector<vector<int>>& graph, int source, int sink) {
	if (source == sink)
		return -1;
 
	int max_flow = 0;
    residualGraph = graph;
    vector<int> level(n, -1);
 
	while (bfs(residualGraph, level, source, sink) == true)
	{
		vector<int> count(n, 0);
 
		while (int flow = sendFlow(residualGraph, level, count, source, sink, INT_MAX))
			max_flow += flow;
	}
	return max_flow;
}
 
void addEdge(vector<vector<int>>& graph, int u, int v, int w) {
    graph[u][v] = w;
}
 
queue<int> pil;
 
void dfs(int node) {
	pil.push(node);
	vis[node] = 1;
	if (node == n-1) return;
	for (int i = n-1; i > 0; i--) {
		if (!vis[i] && mat[node][i] == -1) {
			vis[i] = 1;
			mat[node][i] = 1;
			dfs(i);
			return;
		}
	}
}
 
int main() { _
	int m;
	cin >> n >> m;
    vector<vector<int>> graph(n, vector<int> (n, 0));
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		a--, b--;
		addEdge(graph, a, b, 1);
		mat[a][b] = 1;
	}
	int tot = dinic_algorithm(graph, 0, n-1);
	cout << tot << '\n';
	while (tot--) {
		memset(vis, 0, sizeof(vis));
		dfs(0);
		cout << pil.size() << '\n';
		while (!pil.empty()) {
			cout << pil.front()+1 << ' ';
			pil.pop();
		}
		cout << '\n';
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1709
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int n;
int vis[505];
vector<vector<int>> residualGraph;
 
bool bfs(vector<vector<int>>& residualGraph, vector<int>& level, int source, int sink) {
    fill(level.begin(), level.end(), -1);
	level[source] = 0;
	
	queue<int> q;
	q.push(source);
 
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		for (int v=0; v < n; v++)
		{
			if (u != v && residualGraph[u][v] > 0 && level[v] < 0)
			{
 
				level[v] = level[u] + 1;
				q.push(v);
			}
		}
	}
	return level[sink] < 0 ? false : true ;
}
 
int sendFlow(vector<vector<int>>& residualGraph, vector<int>& level, vector<int>& count, int u, int sink, int flow) {
	if (u == sink)
		return flow;
 
    if (count[u] == (int)residualGraph[u].size())
	    return 0;
 
	for (int v=0; v < n; v++)
	{
		if (residualGraph[u][v] > 0)
		{
		    count[u]++;
			if (level[v] == level[u]+1)
			{
			 	int curr_flow = min(flow, residualGraph[u][v]);
 
			    int min_cap = sendFlow(residualGraph, level, count, v, sink, curr_flow);
			    if (min_cap > 0)
			    {
                    residualGraph[u][v] -= min_cap;
                    residualGraph[v][u] += min_cap;
				    return min_cap;
			    }
			}
		}
	}
	return 0;
}
 
int dinic_algorithm(vector<vector<int>>& graph, int source, int sink) {
	if (source == sink)
		return -1;
 
	int max_flow = 0;
    residualGraph = graph;
    vector<int> level(n, -1);
 
	while (bfs(residualGraph, level, source, sink) == true)
	{
		vector<int> count(n, 0);
 
		while (int flow = sendFlow(residualGraph, level, count, source, sink, INT_MAX))
			max_flow += flow;
	}
	return max_flow;
}
 
void addEdge(vector<vector<int>>& graph, int u, int v, int w) {
    graph[u][v] = w;
}
 
int main() { _
	cin >> n;
	int tam = n;
	n = 2*n+2;
    vector<vector<int>> graph(n, vector<int> (n, 0));
	for (int i = 1; i <= tam; i++) {
		addEdge(graph, 0, i, 1);
		addEdge(graph, i+tam, n-1, 1);
		for (int j = tam+1; j <= 2*tam; j++) {
			char c;
			cin >> c;
			if (c == 'o') addEdge(graph, i, j, 200);
		}
	}
	cout <<  dinic_algorithm(graph, 0, n-1) << '\n';
	memset(vis, 0, sizeof(vis));
	queue<int> fila;
	fila.push(0);
	vis[0] = 1;
	while (!fila.empty()) {
		int atual = fila.front();
		fila.pop();
		for (int i = 1; i < n; i++) {
			if (!vis[i] && residualGraph[atual][i]) {
				vis[i] = 1;
				fila.push(i);
			}
		}
	}
	for (int i = 1; i <= tam; i++) {
		if (vis[0] != vis[i]) cout << "1 " << i << '\n';
	}
	for (int i = tam+1; i <= 2*tam; i++) {
		if (vis[n-1] != vis[i]) cout << "2 " << i-tam << '\n';
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1723
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 3e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
typedef vector<vector<ll>> matriz;
 
int n;
 
matriz mult(matriz a, matriz b) {
	matriz c(n, vector<ll> (n));
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			for (int k = 0; k < n; k++) {
				c[i][j] += (a[i][k] * b[k][j]) % M;
				if (c[i][j] >= M) c[i][j] -= M; 
			}
		}
	}
	return c;
}
 
matriz expo(matriz a, ll e) {
	if (e == 1) return a;
	matriz ans = expo(a, e/2);
	ans = mult(ans, ans);
	if (e&1) ans = mult(ans, a);
	return ans;
}
 
int main () { _
	int m, k;
	cin >> n >> m >> k;
	matriz v(n, vector<ll> (n));
	for (int i = 0; i < m; i++) {
		ll a, b;
		cin >> a >> b;
		v[a-1][b-1]++;
	}
	v = expo(v, k);
	cout << v[0][n-1] << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1706
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
vector<int> v[MAXN], vals;
int vis[MAXN], cnt, dp[MAXN], used[MAXN], have[MAXN];
 
void dfs(int node) {
	cnt++;
	vis[node] = 1;
	for (int x : v[node]) 
		if (!vis[x]) dfs(x);
}
 
int main() { _
	int n, m, a, b;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			cnt = 0;
			dfs(i);
			vals.pb(cnt);
		}
	}
	sort(vals.begin(), vals.end());
	for (int x : vals) have[x]++;
	vals.erase(unique(vals.begin(), vals.end()), vals.end());
	dp[0] = 1;
	for (int x : vals) {
		memset(used, 0, sizeof(used));
		for (int i = 0; i <= n; i++) {
			if (i + x > n) break;
			if (dp[i] && !dp[i+x] && used[i] < have[x]) {
				used[i+x] = used[i]+1;
				dp[i+x] = 1;
			}
		}
	}
	for (int i = 1; i <= n; i++) cout << dp[i];
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1704
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
vector<int> v[MAXN], fol;
 
void dfs(int node, int pai) {
	for (int x : v[node]) {
		if (x != pai) dfs(x, node);
	}
	if ((int)v[node].size() == 1) fol.push_back(node);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n;
	cin >> n;
	for (int i = 0; i < n-1; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	dfs(1, 0);
	// cnt eh o numero de filhos da raiz
	int tam = (int)fol.size();
	if (tam&1) fol.push_back(fol[0]), tam++;
	cout << tam/2 << '\n';
	for (int i = 0; i < tam/2; i++) {
		cout << fol[i] << ' ' << fol[i+tam/2] << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1702
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
int pre[MAXN], in[MAXN], mapa[MAXN];
 
void build(int i1, int f1, int i2, int f2) {
    if (i1 > f1) return;
    int root = mapa[pre[i2]], tam = (root-i1);
    build(i1, root-1, i2+1, i2+tam);
    build(root+1, f1, i2+tam+1, f2);
    cout << in[root] << ' ';
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) cin >> pre[i];
    for (int i = 0; i < n; i++) {
        cin >> in[i];
        mapa[in[i]] = i;
    }
    build(0, n-1, 0, n-1);
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1701
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
vector<int> v[2][MAXN];
int id = 0, dp[2][MAXN], n;
map<vector<int>, int> mp;
 
int dfs(int node, int p, bool at) {
    dp[at][node] = 1;
    vector<int> val;
    for (int x : v[at][node]) {
        if (x != p) {
            val.push_back(dfs(x, node, at));
            dp[at][node] += dp[at][x];
        }
    }
    sort(val.begin(), val.end());
    if (!mp[val]) mp[val] = ++id;
    return mp[val];
}
 
void dfs2(int node, int p, int at) {
    dp[at][node] = 1;
    for (int x : v[at][node]) {
        if (x != p) {
            dfs2(x, node, at);
            dp[at][node] += dp[at][x];
        }
    }
}
 
vector<int> ctd(int node, int p, bool at) {
    vector<int> ans;
    bool ok = true;
    for (int x : v[at][node]) {
        if (x != p) {
            vector<int> a = ctd(x, node, at);
            for (int x : a) ans.push_back(x);
            ok &= (dp[at][x] <= (n / 2));
        }
    }
    ok &= (n - dp[at][node] <= (n/2));
    if (ok) ans.push_back(node);
    return ans;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        mp.clear();
        id = 0;
        int a, b;
        cin >> n;
        for (int i = 0; i < 2; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = 0;
                v[i][j].clear();
            }
            for (int j = 0; j < n - 1; j++) {
                cin >> a >> b;
                v[i][a].push_back(b);
                v[i][b].push_back(a);
            }
        }
        dfs2(1, -1, 0), dfs2(1, -1, 1);
        vector<int> c0 = ctd(1, -1, 0), c1 = ctd(1, -1, 1);
        int s0 = dfs(c0[0], -1, 0);
        bool ok = false;
        for (int x : c1) {
            if (dfs(x, -1, 1) == s0) ok = true;
        }
        cout << (ok ? "YES\n" : "NO\n");
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1700
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
vector<int> v[2][MAXN];
int id = 0;
map<vector<int>, int> mp;
 
int dfs(int node, int p, bool at) {
    vector<int> val;
    for (int x : v[at][node]) {
        if (x != p) {
            val.push_back(dfs(x, node, at));
        }
    }
    sort(val.begin(), val.end());
    if (!mp[val]) mp[val] = ++id;
    return mp[val];
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        mp.clear();
        id = 0;
        int n, a, b;
        cin >> n;
        for (int i = 0; i < 2; i++) {
            for (int j = 1; j <= n; j++) {
                v[i][j].clear();
            }
            for (int j = 0; j < n - 1; j++) {
                cin >> a >> b;
                v[i][a].push_back(b);
                v[i][b].push_back(a);
            }
        }
        int s0 = dfs(1, -1, 0);
        int s1 = dfs(1, -1, 1);
        cout << (s0 == s1 ? "YES\n" : "NO\n");
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1699
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 10;
const ll INF = 2e18;
 
vector<int> v[MAXN], w[MAXN], cmp[MAXN];
int at = 0, vis[MAXN];
 
void dfs(int node) {
    vis[node] = 1;
    cmp[at].push_back(node);
    for (int x : w[node]) {
        if (!vis[x]) dfs(x);
    }
}
 
bool dfs2(int node) {
    bool cic = false;
    vis[node] = 1;
    for (int x : v[node]) {
        if (vis[x] == 1) cic = true;
        if (!vis[x]) cic |= dfs2(x);
    }
    vis[node] = 2;
    return cic;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
    cin >> n >> m;
    int a, b;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        v[a].push_back(b);
        w[a].push_back(b);
        w[b].push_back(a);
    }
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) {
            dfs(i);
            at++;
        }
    }
    memset(vis, 0, sizeof(vis));
    int ans = 0;
    for (int i = 0; i < at; i++) {
        bool cic = false;
        for (int x : cmp[i]) {
            if (!vis[x]) cic |= dfs2(x);
        }
        if (cic) ans += cmp[i].size();
        else ans += cmp[i].size() - 1;
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1698
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
int v[MAXN], vis[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	vector<vector<int>> cic;
	vector<int> sz;
	int mx = 0;
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			vector<int> nv;
			vis[i] = 1;
			nv.push_back(i);
			int bg = i, at = v[i];
			while (at != bg) {
				vis[at] = 1;
				nv.push_back(at);
				at = v[at];
			}
			cic.push_back(nv);
			sz.push_back(nv.size());
			mx = max(mx, (int)nv.size());
		}
	}
	memset(vis, 0, sizeof(vis));
	int ans = min(2, (int)ceil(log2(mx)));
	cout << ans << '\n';
	int qtd = 0;
	for (int j = 0; j < (int)cic.size(); j++) {
		qtd += sz[j] / 2;
	}
	cout << qtd << '\n';
	for (int j = 0; j < (int)cic.size(); j++) {
		int tam = cic[j].size();
		if (sz[j] > 1) {
			for (int k = 0; k < tam / 2; k++) {
				cout << cic[j][k] << ' ' << cic[j][tam - k - 1] << '\n'; 
				swap(v[cic[j][k]], v[cic[j][tam - k - 1]]);
			}
		}
	}
	if (ans == 2) {
		qtd = 0;
		for (int i = 1; i <= n; i++) {
			if (v[i] != i) qtd++;
		}
		cout << qtd / 2 << '\n';
		for (int i = 1; i <= n; i++) {
			if (v[i] != i && !vis[i]) {
				cout << i << ' ' << v[i] << '\n';
				vis[i] = vis[v[i]] = 1;
			}
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1697
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int v[MAXN];
 
int main () { _
	int n;
	cin >> n;
	priority_queue<pii> fila;
	int tot = 0;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		if (v[i]) fila.push({v[i], i});
		tot = (v[i]&1 ? 1-tot : tot);
	}
	if (tot&1) cout << "IMPOSSIBLE\n";
	else {
		pii a1, a2;
		bool ok = true;
		vector<pii> ans;
		while (!fila.empty()) {
			a1 = fila.top();
			fila.pop();
			vector<pii> falta;
			while (v[a1.S]) {
				if (fila.empty()) {
					ok = false;
					break;
				}
				a2 = fila.top();
				fila.pop();
				v[a1.S]--, v[a2.S]--;
				ans.pb({a1.S, a2.S});
				if (v[a2.S]) falta.pb({v[a2.S], a2.S});
			}
			for (pii x : falta) fila.push(x);
		}
		if (!ok) cout << "IMPOSSIBLE\n";
		else {
			cout << ans.size() << '\n';
			for (pii x : ans) cout << x.F << ' ' << x.S << '\n';
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1732
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int pre[MAXN], pwr[MAXN];
 
int main () { _
	string s1;
	cin >> s1;
	int tam1 = (int)s1.size();
	pwr[0] = 1;
	for (int i = 1; i <= 1e6; i++) pwr[i] = (1ll * pwr[i-1] * 31) % M;
	for (int i = 0; i < tam1; i++) {
		pre[i] = ((!i ? 0 : pre[i-1]) + (s1[i] - 'a' + 1ll) * pwr[i]) % M;
	}
	vector<int> ans;
	for (int i = 0; i < tam1-1; i++) {
		if ((1ll * pre[i] * pwr[tam1-i-1]) % M == (pre[tam1-1] - pre[tam1-i-2] + M) % M)
			ans.pb(i+1);
	}
	for (int x : ans) cout << x << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1741
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const int INF = 2e9;
 
struct op {
    int x, y1, y2;
    bool open;
    op(int _x = 0, int _y1 = 0, int _y2 = 0, bool _open = false) {
        x = _x, y1 = _y1, y2 = _y2, open = _open;
    }
};
 
bool comp(op a, op b) {
    if (a.x != b.x) return a.x < b.x;
    return a.open > b.open;
}
 
struct no {
    int mn, qtd, lz;
    no(int _mn = 0, int _qtd = 0, int _lz = 0) {
        mn = _mn, qtd = _qtd, lz = _lz;
    }
    no operator + (const no &x) const {
        no aux;
        if (mn < x.mn) {
            aux.mn = mn;
            aux.qtd = qtd;
        }
        else if (mn == x.mn) {
            aux.mn = mn;
            aux.qtd = qtd + x.qtd;
        }
        else {
            aux.mn = x.mn;
            aux.qtd = x.qtd;
        }
        aux.lz = lz;
        return aux;
    }
}a[4 * MAXN];
 
void build(int node, int i, int j) {
    if (i == j) {
        a[node] = no(0, 1, 0);
    }
    else {
        int m = (i + j) / 2;
        build(2 * node, i, m), build(2 * node + 1, m + 1, j);
        a[node] = a[2 * node] + a[2 * node + 1];
    }
}
 
void push(int node, int i, int j) {
    if (a[node].lz) {
        a[node].mn += a[node].lz;
        if (i != j) {
            a[2 * node].lz += a[node].lz;
            a[2 * node + 1].lz += a[node].lz;
        }
        a[node].lz = 0;
    }
}
 
void update(int node, int i, int j, int ini, int fim, int val) {
    push(node, i, j);
    if (j < ini || i > fim) return;
    else if (ini <= i && j <= fim) {
        a[node].lz += val;
        push(node, i, j);
    }
    else {
        int m = (i + j) / 2;
        update(2 * node, i, m, ini, fim, val);
        update(2 * node + 1, m + 1, j, ini, fim, val);
        a[node] = a[2 * node] + a[2 * node + 1];
    }
}
 
ll query(int node, int i, int j) {
    push(node, i, j);
    return a[1].qtd;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, a, b, c, d;
    cin >> n;
    build(1, 0, 2000000);
    vector<op> v(2 * n);
    for (int i = 0; i < n; i++) {
        cin >> a >> b >> c >> d;
        b += 1000000, d += 1000000 - 1;
        v[2 * i] = op(a, b, d, true), v[2 * i + 1] = op(c, b, d, false);
    }
    sort(v.begin(), v.end(), comp);
    int lst = -1000000;
    ll ans = (2000001ll) * (2000001ll);
    for (auto o : v) {
        if (o.x != lst) {
            // novo x
            ans -= query(1, 0, 2000000) * (o.x - lst);
            lst = o.x;
        }
        if (o.open) {
            // comeco de intervalo
            update(1, 0, 2000000, o.y1, o.y2, 1);
        }
        else {
            // fim de intervalo
            update(1, 0, 2000000, o.y1, o.y2, -1);
        }
    }
    cout << ans - query(1, 0, 2000000) * (1000000 - lst + 1) << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1740
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
struct line {
	int x1, x2, y1, y2, hor, take;
};
 
ll a[MAXN];
vector<line> l[MAXN];
 
void upd(int pos, int val) {for (; pos < MAXN; pos += (pos & -pos)) a[pos]+=val; }
 
ll sum(int pos) {
	ll ans = 0;
	for (; pos; pos -= (pos & -pos)) ans += a[pos];
	return ans;
}
 
int main () { _
	int n;
	cin >> n;
	line aux;
	for (int i = 0; i < n; i++) {
		cin >> aux.x1 >> aux.y1 >> aux.x2 >> aux.y2;
		aux.x1 += 1e6, aux.x2 += 1e6, aux.y1 += 1e6, aux.y2 += 1e6;
		aux.hor = (aux.y1 == aux.y2);
		aux.take = 1;
		l[aux.x1].pb(aux);
	}
	ll ans = 0;
	for (int i = 0; i <= 2e6; i++) {
		if (!l[i].empty()) {
			sort(l[i].begin(), l[i].end(), [&] (line a, line b) { return a.hor > b.hor; });
			for (line &x : l[i]) {
				if (x.hor) {
					upd(x.y1, x.take);
					if (x.take == 1) {
						x.take = -1;
						l[x.x2].pb(x);
					}
				}
				else ans += sum(x.y2) - sum(x.y1-1);
			}
		}
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1739
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1010
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int bit[MAXN][MAXN];
char m[MAXN][MAXN];
 
void upd(int x, int y, int val) {
	for (int i = x; i < MAXN; i += (i & -i)) {
		for (int j = y; j < MAXN; j += (j & -j)) bit[i][j] += val;
	}
}
 
int sum(int x, int y) {
	int resp = 0;
	for (int i = x; i > 0; i -= (i & -i)) {
		for (int j = y; j > 0; j -= (j & -j)) resp += bit[i][j];
	}
	return resp;
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> m[i][j];
			if (m[i][j] == '*') upd(i, j, 1);
		}
	}
	int tipo, x1, x2, y1, y2;
	for (int i = 0; i < q; i++) {
		cin >> tipo;
		if (tipo == 1) {
			cin >> x1 >> y1;
			if (m[x1][y1] == '*') {
				upd(x1, y1, -1);
				m[x1][y1] = '.';
			}
			else {
				upd(x1, y1, 1);
				m[x1][y1] = '*';
			}
		}
		else {
			cin >> x1 >> y1 >> x2 >> y2;
			cout << sum(x2, y2) + sum(x1-1, y1-1) - sum(x2, y1-1) - sum(x1-1, y2) << '\n';
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1737
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 5e6 + 5;
const ll INF = 2e18;
 
ll esq[MAXN], dir[MAXN], a[MAXN];
int raiz[(int)2e5 + 5], v[(int)2e5 + 5], disp = 0, lst = 2;
 
void build(int node, int i, int j) {
    if (i == j) {
        a[node] = v[i];
        disp = max((int)disp, node);
    }
    else {
        int m = (i + j) / 2;
        build(2 * node, i, m);
        build(2 * node + 1, m + 1, j);
        esq[node] = 2 * node;
        dir[node] = 2 * node + 1;
        a[node] = a[2 * node] + a[2 * node + 1];
    }
}
 
ll query(int node, int i, int j, int ini, int fim) {
    if (i > fim || j < ini) return 0;
    else if (ini <= i && j <= fim) return a[node];
    else {
        int m = (i + j) / 2;
        return query(esq[node], i, m, ini, fim) + query(dir[node], m + 1, j, ini, fim);
    }
}
 
int upd(int node, int i, int j, int pos, int val) {
    int novo = disp++;
    if (i == j) {
        a[novo] = val;
        return novo;
    }
    int m = (i + j) / 2;
    if (m >= pos) {
        esq[novo] = upd(esq[node], i, m, pos, val);
        dir[novo] = dir[node];
    }
    else {
        dir[novo] = upd(dir[node], m + 1, j, pos, val);
        esq[novo] = esq[node];
    }
    a[novo] = a[esq[novo]] + a[dir[novo]];
    return novo;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> v[i];
    raiz[1] = 1;
    build(1, 1, n);
    disp++;
    int tipo, ar, x, y;
    for (int i = 0; i < q; i++) {
        cin >> tipo;
        switch(tipo) {
            case 1:
                cin >> ar >> x >> y;
                raiz[ar] = upd(raiz[ar], 1, n, x, y);
                break;
            case 2:
                cin >> ar >> x >> y;
                cout << query(raiz[ar], 1, n, x, y) << '\n';
                break;
            case 3:
                cin >> ar;
                raiz[lst++] = disp;
                esq[disp] = esq[raiz[ar]];
                dir[disp] = dir[raiz[ar]];
                a[disp] = a[esq[disp]] + a[dir[disp]];
                disp++;
                break;
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1736
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
ll v[MAXN], a[4*MAXN];
pll lz[4*MAXN];
 
void build(int node, int i, int j) {
	if (i == j) a[node] = v[i];
	else {
		int m = (i+j)/2;
		build(2*node, i, m), build(2*node+1, m+1, j);
		a[node] = a[2*node] + a[2*node+1];
	}
}
 
void push(int node, int i, int j) {
	a[node] += lz[node].F * 1ll * (j-i+1);
	a[node] += lz[node].S * (1ll * (j-i+1) * (j-i) / 2);
	if (i != j && lz[node].F) {
		int m = (i+j)/2;
		lz[2*node] = {lz[2*node].F + lz[node].F, lz[2*node].S + lz[node].S};
		lz[2*node+1] = {lz[2*node+1].F + lz[node].F + 1ll * (m-i+1) * lz[node].S, lz[2*node+1].S + lz[node].S};
	}
	lz[node] = {0, 0};
}
 
void upd(int node, int i, int j, int ini, int fim) {
	push(node, i, j);
	if (j < ini || i > fim) return;
	if (ini <= i && j <= fim) {
		lz[node].S++;
		lz[node].F += (i-ini+1);
		push(node, i, j);
	}
	else {
		int m = (i+j)/2;
		upd(2*node, i, m, ini, fim);
		upd(2*node+1, m+1, j, ini, fim);
		a[node] = a[2*node] + a[2*node+1];
	}
}
 
ll query(int node, int i, int j, int ini, int fim) {
	push(node, i, j);
	if (j < ini || i > fim) return 0;
	if (ini <= i && j <= fim) return a[node];
	else {
		int m = (i+j)/2;
		return query(2*node, i, m, ini, fim) + query(2*node+1, m+1, j, ini, fim);
	}
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) cin >> v[i];
	build(1, 1, n);
	int tipo, a, b;
	for (int i = 0; i < q; i++) {
		cin >> tipo >> a >> b;
		if (tipo == 1) 
			upd(1, 1, n, a, b);
		if (tipo == 2) 
			cout << query(1, 1, n, a, b) << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1735
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
ll v[MAXN], a[4*MAXN], lz1[4*MAXN], lz2[4*MAXN], a1[4*MAXN], a2[4*MAXN];
 
void build(int node, int i, int j) {
	if (i == j) a[node] = v[i];
	else {
		int m = (i+j)/2;
		build(2*node, i, m), build(2*node+1, m+1, j);
		a[node] = a[2*node] + a[2*node+1];
	}
}
 
void push(int node, int i, int j) {
	if (a1[node]) {
		a[node] = (j-i+1) * lz1[node];
		if (i != j) {
			lz1[2*node] = lz1[2*node+1] = lz1[node];
			a1[2*node] = a1[2*node+1] = 1;
			lz2[2*node] = lz2[2*node+1] = a2[2*node] = a2[2*node+1] = 0;
		}
		lz2[node] = lz1[node] = a2[node] = a1[node] = 0;
	}
	if (a2[node]) {
		a[node] += (j-i+1) * lz2[node];
		if (i != j) {
			if (lz1[2*node]) {
				lz1[2*node] += lz2[node];
				lz2[2*node] = 0;
				a2[2*node] = 0;
			}
			else {
				lz2[2*node] += lz2[node];
				a2[2*node] = 1;
			}
			if (lz1[2*node+1]) {
				lz1[2*node+1] += lz2[node];
				lz2[2*node+1] = 0;
				a2[2*node+1] = 0;
			}
			else {
				lz2[2*node+1] += lz2[node];
				a2[2*node+1] = 1;
			}
		}
		lz2[node] = 0;
		a2[node] = 0;
	}
}
 
void upd(int node, int i, int j, int ini, int fim, int val, bool set) {
	push(node, i, j);
	if (j < ini || i > fim) return;
	if (ini <= i && j <= fim) {
		if (set) {
			lz1[node] = val;
			a1[node] = true;
		}
		else {
			if (a1[node]) lz1[node] += val;
			else {
				lz2[node] += val;
				a2[node] = true;
			}
		}
		push(node, i, j);
	}
	else {
		int m = (i+j)/2;
		upd(2*node, i, m, ini, fim, val ,set);
		upd(2*node+1, m+1, j, ini, fim, val, set);
		a[node] = a[2*node] + a[2*node+1];
	}
}
 
ll query(int node, int i, int j, int ini, int fim) {
	push(node, i, j);
	if (j < ini || i > fim) return 0;
	if (ini <= i && j <= fim) return a[node];
	else {
		int m = (i+j)/2;
		return query(2*node, i, m, ini, fim) + query(2*node+1, m+1, j, ini, fim);
	}
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) cin >> v[i];
	build(1, 1, n);
	int tipo, a, b, val;
	for (int i = 0; i < q; i++) {
		cin >> tipo >> a >> b;
		if (tipo == 1) {
			cin >> val;
			upd(1, 1, n, a, b, val, false);
		}
		if (tipo == 2) {
			cin >> val;
			upd(1, 1, n, a, b, val, true);
		}
		if (tipo == 3) {
			cout << query(1, 1, n, a, b) << '\n';
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1734
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
const int X = 700;
 
struct que {
	int l, r, id, ans;
};
 
int a[MAXN], v[MAXN];
vector<que> qs;
vector<int> c, vals[MAXN];
 
void upd(int pos, int val) {
	for (int i = pos; i < MAXN; i += (i & -i)) 
		a[i] += val;
}
 
int sum(int pos) {
	int ans = 0;
	for (int i = pos; i > 0; i -= (i & -i))
		ans += a[i];
	return ans;
}
 
int main() { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		c.pb(v[i]);
	}
	sort(c.begin(), c.end());
	c.erase(unique(c.begin(), c.end()), c.end());
	for (int i = 1; i <= n; i++) {
		v[i] = upper_bound(c.begin(), c.end(), v[i]) - c.begin();
		if (vals[v[i]].empty()) upd(i, 1);
		vals[v[i]].pb(i);
	}
	que aux;
	for (int i = 0; i < q; i++) {
		cin >> aux.l >> aux.r;
		aux.id = i;
		qs.pb(aux);
	}
	sort(qs.begin(), qs.end(), [&] (que x, que y) { return x.l < y.l; });
	int last = 1, np;
	for (int i = 0; i < q; i++) {
		while (qs[i].l > last) {
			upd(last, -1);
			np = upper_bound(vals[v[last]].begin(), vals[v[last]].end(), last) - vals[v[last]].begin();
			if (np < (int)vals[v[last]].size()) upd(vals[v[last]][np], 1);
			last++;
		}
		qs[i].ans = sum(qs[i].r);
	}
	sort(qs.begin(), qs.end(), [&] (que x, que y) { return x.id < y.id; });
	for (que x : qs) cout << x.ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1733
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int pre[MAXN], pwr[MAXN], ja[MAXN];
 
int main () { _
	string s1;
	cin >> s1;
	int tam1 = (int)s1.size();
	pwr[0] = 1;
	for (int i = 1; i <= 1e6; i++) pwr[i] = (1ll * pwr[i-1] * 31) % M;
	for (int i = 0; i < tam1; i++) {
		pre[i] = ((!i ? 0 : pre[i-1]) + (s1[i] - 'a' + 1ll) * pwr[i]) % M;
	}
	for (int i = 1; i <= tam1; i++) {
		if (!ja[i]) {
			bool ok = true;
			for (int j = i; j < tam1 && ok; j+=i) {
				if (j + i >= tam1) 
					ok &= ((1ll * pre[tam1-j-1] * pwr[j]) % M == (pre[tam1-1] - pre[j-1] + M) % M);
				else ok &= ((1ll * pre[i-1] * pwr[j]) % M == (pre[j+i-1] - pre[j-1] + M) % M);
			}
			if (ok) {
				for (int j = i; j <= tam1; j+=i) ja[j] = 1;
			}
		}
	}
	for (int i = 1; i <= tam1; i++) 
		if (ja[i]) cout << i << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2106
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
void count_sort(vector<int> &p, vector<int> &c) {
    int n = p.size();
    vector<int> cnt(n);
    for (auto x : c) cnt[x]++;
    vector<int> p_new(n), pos(n);
    pos[0] = 0;
    for (int i = 1; i < n; i++) {
        pos[i] = pos[i - 1] + cnt[i - 1];
    }
    for (auto x : p) {
        p_new[pos[c[x]]] = x;
        pos[c[x]]++;
    }
    p = p_new;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    s += '$';
    int n = s.size();
    vector<int> p(n), c(n);
    {
        vector<pair<char, int>> a(n);
        for (int i = 0; i < n; i++) a[i] = {s[i], i};
        sort(a.begin(), a.end());
        for (int i = 0; i < n; i++) p[i] = a[i].second;
        c[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            if (a[i - 1].first == a[i].first) c[p[i]] = c[p[i - 1]];
            else c[p[i]] = c[p[i - 1]] + 1;
        }
    }
    int k = 0;
    while ((1 << k) < n) {
        for (int i = 0; i < n; i++) p[i] = (p[i] - (1 << k) + n) % n;
        count_sort(p, c);
        vector<int> c_new(n);
        c_new[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            pii prev = {c[p[i - 1]], c[(p[i - 1] + (1 << k)) % n]};
            pii now = {c[p[i]], c[(p[i] + (1 << k)) % n]};
            if (prev == now) c_new[p[i]] = c_new[p[i - 1]];
            else c_new[p[i]] = c_new[p[i - 1]] + 1;
        }
        c = c_new;
        k++;
    }
    vector<int> lcp(n);
    k = 0;
    for (int i = 0; i < n - 1; i++) {
        int pi = c[i];
        int j = p[pi - 1];
        while (s[i + k] == s[j + k]) k++;
        lcp[pi] = k;
        k = max(k - 1, 0);
    }
    int max = 0, id = -1;
    for (int i = 0; i < n; i++) {
        if (lcp[i] > max) {
            max = lcp[i];
            id = p[i];
        }
    }
    if (!max) cout << "-1\n";
    else {
        for (int i = id; i < id + max; i++) cout << s[i];
        cout << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1731
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int dp[5050], trie[MAXN][26], quant[MAXN], fim[MAXN], cnt = 0, n;
string s;
 
void insert(string &a) {
	int node = 0;
	for (char c : a) {
		quant[node]++;
		if (!trie[node][c-'a']) trie[node][c-'a'] = ++cnt;
		node = trie[node][c - 'a'];
	}
	quant[node]++;
	fim[node]++;
}
 
int query(int x) {
	int ans = 0, node = 0;
	for (int i = x; i < n; i++) {
		if (!trie[node][s[i] - 'a']) return ans;
		node = trie[node][s[i] - 'a'];
		ans = (ans + 1ll * fim[node] * dp[i+1]) % M;
	}
	return ans;
}
 
int main () { _
	string aux;
	cin >> s;
	n = (int)s.size();
	int k;
	cin >> k;
	for (int i = 0; i < k; i++) {
		cin >> aux;
		insert(aux);
	}
	dp[n] = 1;
	for (int i = n-1; i >= 0; i--) 
		dp[i] = query(i);
	
	cout << dp[0] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1730
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int t;
    cin >> t;
    while (t--) {
        int n, aux, ans = 0;
        cin >> n;
        for (int i = 0; i < n; i++) {
            cin >> aux;
            ans ^= aux;
        }
        cout << (ans ? "first\n" : "second\n");
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1729
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, k;
    cin >> n >> k;
    vector<int> v(k), ans(n+1);
    for (int i = 0; i < k; i++) {
        cin >> v[i];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < k; j++) {
            if (i - v[j] >= 0 && !ans[i-v[j]]) {
                ans[i] = 1;
                break;
            }
        }        
        cout << (ans[i] ? 'W' : 'L');
    }
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1728
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
	int n;
	cin >> n;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	vector<vector<double>> dp(105, vector<double> (105));
	vector<double> prob(105);
	for (int i = 1; i < v[0]; i++) {
		prob[i] += ((double)v[0] - i) / v[0];
	}
	for (int i = 1; i < n; i++) {
		for (int j = 1; j <= v[i]; j++) {
			dp[i][j] = prob[j];
			for (int k = 1; k <= v[i-1]; k++) {
				dp[i][j] += (dp[i-1][k]) / v[i-1];
			}
		}
		for (int j = 1; j < v[i]; j++) {
			prob[j] += ((double)v[i] - j) / v[i];
		}
	}
	double ans = 0;
	for (int i = 1; i <= v[n-1]; i++) ans += dp[n-1][i];
	cout << setprecision(6) << fixed;
	cout << ans / v[n-1] << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1727
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
	int n, x;
	cin >> n >> x;
	vector<vector<double>> dp(105, vector<double> (105));
	for (int i = 1; i <= x; i++) dp[n][i] = i;
	for (int i = n-1; i >= 0; i--) {
		for (int j = 1; j <= x; j++) {
			for (int k = 1; k <= x; k++) {
				dp[i][j] += 1.0 * dp[i+1][max(j, k)] / x;
			}
		}
	}
	cout << setprecision(6) << fixed;
	cout << dp[0][1] << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1726
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int dx[4] = {1, -1, 0, 0};
int dy[4] = {0, 0, 1, -1};
 
bool valid(int x, int y) { return (x >= 0 && x < 8 && y >= 0 && y < 8); }
 
int main () { _
	int n;
	cin >> n;
	vector<vector<int>> count(8, vector<int> (8));
	vector<vector<vector<pii>>> moves(8, vector<vector<pii>> (8));
	for (int i = 0; i < 8; i++) {
		for (int j = 0; j < 8; j++) {
			for (int k = 0; k < 4; k++) {
				if (valid(i + dx[k], j + dy[k])) {
					count[i][j]++;
					moves[i][j].pb({i+dx[k], j+dy[k]});
				}
			}
		}
	}
	vector<vector<double>> ans(8, vector<double> (8, 1.0));
	for (int l = 0; l < 8; l++) {
		for (int m = 0; m < 8; m++) {
			vector<vector<double>> v(8, vector<double> (8)), w(8, vector<double> (8));
			v[l][m] = 1;
			for (int k = 0; k < n; k++) {
				for (int i = 0; i < 8; i++) {
					for (int j = 0; j < 8; j++) {
						for (int a = 0; a < (int)moves[i][j].size(); a++) {
							w[moves[i][j][a].F][moves[i][j][a].S] += v[i][j] / count[i][j];
						}
					}
				}
				v = w;
				fill(w.begin(), w.end(), vector<double> (8));
			}
			for (int i = 0; i < 8; i++) {
				for (int j = 0; j < 8; j++) {
					ans[i][j] *= (1.0 - v[i][j]);
				}
			}
		}
	}
	double resp = 0;
	for (int i = 0; i < 8; i++) {
		for (int j = 0; j < 8; j++) {
			resp += ans[i][j];
		}
	}
	cout << setprecision(6) << fixed;
	cout << resp << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1725
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
	int n, a, b;
	cin >> n >> a >> b;
	vector<double> dp(605), ini(7);
	dp[0] = 1;
	for (int i = 1; i <= 6; i++) ini[i] = 1.0 / 6;
	for (int i = 0; i < n; i++) {
		for (int j = 600; j >= 0; j--) {
			dp[j] = 0;
			for (int k = j-1; k >= max(0, j-6); k--) {
				dp[j] += ini[j-k] * dp[k];
			}
		}
	}
	double ans = 0;
	for (int i = a; i <= b; i++) ans += dp[i];
	cout << setprecision(6) << fixed;
	cout << ans << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1724
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 3e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const ll M = 4294967296;
 
typedef vector<vector<ll>> matriz;
 
int n;
 
matriz mult(matriz a, matriz b) {
	matriz c(n, vector<ll> (n, INF));
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			for (int k = 0; k < n; k++) {
				c[i][j] = min(c[i][j], a[i][k] + b[k][j]);
			}
		}
	}
	return c;
}
 
matriz expo(matriz a, ll e) {
	if (e == 1) return a;
	matriz ans = expo(a, e/2);
	ans = mult(ans, ans);
	if (e&1) ans = mult(ans, a);
	return ans;
}
 
int main () { _
	int m, k;
	cin >> n >> m >> k;
	matriz v(n, vector<ll> (n, INF));
	for (int i = 0; i < m; i++) {
		ll a, b, c;
		cin >> a >> b >> c;
		v[a-1][b-1] = min(v[a-1][b-1], c);
	}
	v = expo(v, k);
	if (v[0][n-1] > 1e18) cout << "-1\n";
	else cout << v[0][n-1] << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2195
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
ll cross(pll a, pll b, pll c, pll d) {
	return (a.F - b.F) * (c.S - d.S) - (a.S - b.S) * (c.F - d.F);
}
 
void CH(vector<pll> &v) {
	 int n = (int) v.size(), k = 0;
	vector<pll> h(2 * n);
	sort(v.begin(), v.end());
	// lower hull
	for (int i = 0; i < n; i++) {
		while (k >= 2 && cross(h[k - 1], h[k - 2], v[i], h[k - 2]) < 0) k--;
		h[k++] = v[i];
	}
	// upper hull
	for (int i = n - 2, t = k + 1; i >= 0; i--) {
		while (k >= t && cross(h[k - 1], h[k - 2], v[i], h[k - 2]) < 0) {
			k--;
		}
		h[k++] = v[i];
	}
	reverse(h.begin(), h.begin() + k);
	h.resize(k - 1);
	v = h;
}
 
int main () { _
	int n;
	cin >> n;
	vector<pll> v(n);
	for (int i = 0; i < n; i++) cin >> v[i].F >> v[i].S;
	CH(v);
	cout << v.size() << '\n';
	for (auto a : v) cout << a.F << ' ' << a.S << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2216
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n;
	cin >> n;
	vector<pii> v(n);
	for (int i = 0; i < n; i++) {
		cin >> v[i].F; 
		v[i].S = i;
	}
	sort(v.begin(), v.end());
	int resp = 1;
	for (int i = 1; i < n; i++) {
		resp += (v[i].S < v[i-1].S);
	}
	cout << resp << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2215
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 4e5 + 5;
const ll INF = 2e18;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        if (k < ceil(sqrt(n))) {
            cout << "IMPOSSIBLE\n";
        }
        else {
            vector<int> ans(n);
            int a = ceil(sqrt(n));
            for (int i = k; i > 0; i--) cout << i << ' ';
            int temos = n - k, grupos = a - 1;
            if (grupos == 0) {
                cout << '\n';
                continue;
            }
            for (int i = 0; i < temos % grupos; i++) {
                for (int j = 0; j < temos / grupos + 1; j++) {
                    cout << k + (temos / grupos + 1) * (i + 1) - j << ' ';
                }
            }
            int lst = k + (temos / grupos + 1) * (temos % grupos);
            for (int i = 0; i < grupos - temos % grupos; i++) {
                for (int j = 0; j < temos / grupos; j++) {
                    cout << lst + (temos / grupos) * (i + 1) - j << ' ';
                }
            }
            cout << '\n';
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2214
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    ll n, k;
    cin >> n >> k;
    vector<int> v;
    int at = n-1;
    while (k) {
        if (k - at >= 0) {
            k -= at;
            v.push_back(at);
        }
        at--;
    }
    int baixo = 1, cima = n, id = 0;
    vector<int> perm(n);
    for (int i = n-1; i >= 0; i--) {
        if (id < (int)v.size() && i == v[id]) {
            perm[i] = baixo;
            baixo++;
            id++;
        }
        else {
            perm[i] = cima;
            cima--;
        }
    }
    for (int x : perm) cout << x << ' ';
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2210
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
ll fexp(ll b, int e) {
    ll resp = 1;
    while(e) {
        if(e&1) resp = (resp * b) % M;
        b = (b*b) % M;
        e = (e>>1);
    }
    return resp;
}
 
int main () { _
    ll n;
    cin >> n;
    if (n == 1) cout << "2\n";
    else {
        ll total = (n*n);
        ll ans = fexp(2, total % (M-1));
        ans += 2*fexp(2, (total/4 + (n&1)) % (M-1));
        ans += fexp(2, (total/2 + (n&1)) % (M-1));
        cout << (ans * fexp(4, M-2)) % M << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2209
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, int e) {
    ll resp = 1;
    while(e) {
        if(e&1) resp = (resp * b) % M;
        b = (b*b) % M;
        e = (e>>1);
    }
    return resp;
}
 
int main () { _
    int n, m;
    cin >> n >> m;
    ll ans = 0;
    for (int i = 1; i <= n; i++) {
        ans += fexp(m, __gcd(i, n));
        if (ans >= M) ans -= M;
    }
    cout << (ans * fexp(n, M-2)) % M << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2208
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int t;
    cin >> t;
    while (t--) {
        int n, aux;
        cin >> n;
        bool ans = false;
        for (int i = 0; i < n; i++) {
            cin >> aux;
            ans |= (aux&1);
        }
        cout << (ans ? "first\n" : "second\n");
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2207
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int t;
    cin >> t;
    vector<int> v(2050);
    for (int i = 3; i <= 2000; i++) {
        vector<int> aux;
        for (int j = i-1; j > i-j; j--) {
           aux.pb(v[j] ^ v[i-j]);
        }
        sort(aux.begin(), aux.end());
        int resp = 0;
        for (auto x : aux) {
            if (x > resp) break;
            else if (x == resp) resp++;
        }
        v[i] = resp;
    }
    while (t--) {
        int n;
        cin >> n;
        if (n <= 2000) {
            cout << (v[n] ? "first\n" : "second\n");
        }
        else cout << "first\n";
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2206
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int a1[4*MAXN], a0[4*MAXN], v[MAXN], n, q;
 
void build(int node, int i, int j, bool a) {
	if (i == j) {
		if (a) a1[node] = v[i] + i;
		else a0[node] = v[i] + n - i;
	}
	else {
		int m = (i+j)/2;
		build(2*node, i, m, a);
		build(2*node+1, m+1, j, a);
		if (a) a1[node] = min(a1[2*node], a1[2*node+1]);
		else a0[node] = min(a0[2*node], a0[2*node+1]);
	}
}
 
void upd(int node, int i, int j, int pos, bool a) {
	if (i == j) {
		if (a) a1[node] = v[pos] + pos;
		else a0[node] = v[pos] + n - pos;
	}
	else {
		int m = (i+j)/2;
		if (pos <= m) upd(2*node, i, m, pos, a);
		else upd(2*node+1, m+1, j, pos, a);
		if (a) a1[node] = min(a1[2*node], a1[2*node+1]);
		else a0[node] = min(a0[2*node], a0[2*node+1]);
	}
}
 
int ans(int node, int i, int j, int ini, int fim, bool a) {
	if (j < ini || i > fim) return 2e9;
	if (ini <= i && j <= fim) return (a ? a1[node] : a0[node]);
	else {
		int m = (i+j)/2;
		return min(ans(2*node, i, m, ini, fim, a), ans(2*node+1, m+1, j, ini, fim, a));
	}
}
 
int main () { _
	cin >> n >> q;
	for (int i = 1; i <= n; i++) cin >> v[i];
	build(1, 1, n, true);
	build(1, 1, n, false);
	int tipo, x, y;
	for (int i = 0; i < q; i++) {
		cin >> tipo;
		if (tipo == 1) {
			cin >> x >> y;
			v[x] = y;
			upd(1, 1, n, x, 0);
			upd(1, 1, n, x, 1);
		}
		else {
			cin >> x;
			cout << min(ans(1, 1, n, x, n, 1) - x, ans(1, 1, n, 1, x, 0) - n + x) << '\n';
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2217
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 300100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
map<int, int> mp;
 
int count(int a, int b, vector<int> &w) {
    if (a > b) swap(a, b);
    int ans = 0;
    ans += w[a-1] > w[a];
    ans += w[b] > w[b+1];
    if (a+1 == b) {
        ans += w[a] > w[b];
    }
    else {
        ans += w[a] > w[a+1];
        ans += w[b-1] > w[b];
    }
    return ans;
}
 
int main() { _
    int n, m;
    cin >> n >> m;
    vector<pii> v(n+2);
    vector<int> w;
    for (int i = 1; i <= n; i++) {
        cin >> v[i].F;
        v[i].S = i;
        mp[i] = v[i].F; 
    }
    v[n+1] = {n+1, n+1};
    sort(v.begin(), v.end());
    for (int i = 0; i < n+2; i++) {
        w.pb(v[i].S);
    }
    int resp = 1;
    for (int i = 1; i <= n; i++) {
        resp += (w[i-1] > w[i]);
    }
    for (int i = 0; i < m; i++) {
        int a, b, ma, mb, aux;
        cin >> a >> b;
        ma = mp[a], mb = mp[b];
        aux = ma;
        mp[a] = mp[b];
        mp[b] = aux;
        int antes = count(ma, mb, w);
        swap(w[ma], w[mb]);
        int dif = count(ma, mb, w) - antes;
        resp += dif;
        cout << resp << '\n';
    }
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2194
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
ll dist(pll a, pll b) {
	return (a.F - b.F) * (a.F - b.F) + (a.S - b.S) * (a.S - b.S);
}
 
int main () { _
	int n;
	cin >> n;
	vector<pll> v(n);
	for (int i = 0; i < n; i++) cin >> v[i].S >> v[i].F;
	sort(v.begin(), v.end(), [&] (pll a, pll b) { return a.S < b.S; });
	ll ans = 9e18;
	ll d = 1e10;
	set<pll> s;
	s.insert(v[0]);
	for (int i = 1; i < n; i++) {
		while (!s.empty() && abs(v[i].S - s.begin()->S) > d)
			s.erase(*s.begin());
		auto it = s.lower_bound({v[i].F - d + 1, v[i].S});
		while (it != s.end() && it->F < v[i].F + d - 1) {
			if (dist(*it, v[i]) < ans) {
				ans = dist(*it, v[i]);
				d = ceil(sqrt(ans));
			}
			it++;
		}
		s.insert(v[i]);
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2193
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	int n;
	cin >> n;
	vector<pll> v(n);
	for (int i = 0; i < n; i++) cin >> v[i].F >> v[i].S;
	ll area = 0, pts = 0;
	for (int i = 0; i < n; i++) {
		pll last = v[(i+1) % n];
		area += (last.F - v[i].F) * (last.S + v[i].S);
		pts += __gcd(abs(last.F - v[i].F), abs(last.S - v[i].S));
	}
	area = abs(area);
	ll ipts = area + 2 - pts;
	cout << ipts/2 << ' ' << pts << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2192
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
ll cross(pll a, pll b, pll c, pll d) {
	ll val = (a.F - b.F) * (c.S - d.S) - (a.S - b.S) * (c.F - d.F);
	if (!val) return 0;
	if (val > 0) return 1;
	else return -1;
}
 
bool mid(pll a, pll b, pll c) {
	return (min(a.F, b.F) <= c.F && max(a.F, b.F) >= c.F && min(a.S, b.S) <= c.S && max(a.S, b.S) >= c.S);
}
 
bool valid(pll a, pll b, pll c, pll d) {
	ll c1, c2, c3, c4;
	c1 = cross(a, b, a, c);
	c2 = cross(a, b, a, d);
	c3 = cross(c, d, c, a);
	c4 = cross(c, d, c, b);
	if (c1 != c2 && c3 != c4) return true;
	if (!c1 && mid(a, b, c)) return true;
	if (!c2 && mid(a, b, d)) return true;
	if (!c3 && mid(c, d, a)) return true;
	if (!c4 && mid(c, d, b)) return true;
	return false;
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	vector<pll> pol(n);
	for (int i = 0; i < n; i++) 
		cin >> pol[i].F >> pol[i].S;
	pll a, aux = {1e9+2, 1e9+1};
	for (int i = 0; i < m; i++) {
		cin >> a.F >> a.S;
		aux = {a.F+1, 1e9+7};
		bool bound = false;
		for (int j = 0; j < n; j++) {
			if (cross(pol[j], (!j ? pol[n-1] : pol[j-1]), pol[j], a) == 0) {
				if (mid(pol[j], (!j ? pol[n-1] : pol[j-1]), a)) bound = true;
			}
		}
		if (bound) cout << "BOUNDARY\n";
		else {
			int cnt = 0;
			for (int j = 0; j < n; j++) {
				cnt += valid(a, aux, pol[j], (!j ? pol[n-1] : pol[j-1]));
			}
			cout << (cnt&1 ? "INSIDE\n" : "OUTSIDE\n");
		}
 
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2191
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	int n;
	cin >> n;
	vector<pii> v(n);
	for (int i = 0; i < n; i++) cin >> v[i].F >> v[i].S;
	ll ans = 0;
	for (int i = 0; i < n; i++) {
		pii last = (!i ? v[n-1] : v[i-1]);
		ans += 1ll * (last.F - v[i].F) * (last.S + v[i].S);
	}
	cout << abs(ans) << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2190
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
ll cross(ll ax, ll ay, ll bx, ll by, ll cx, ll cy, ll dx, ll dy) {
	ll val = (ax - bx) * (cy - dy) - (ay - by) * (cx - dx);
	if (!val) return 0;
	if (val > 0) return 1;
	else return -1;
}
 
bool mid(ll ax, ll ay, ll bx, ll by, ll cx, ll cy) {
	return (min(ax, bx) <= cx && max(ax, bx) >= cx && min(ay, by) <= cy && max(ay, by) >= cy);
}
 
bool valid() {
	ll x1, x2, x3, x4, y1, y2, y3, y4;
	cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;
	ll c1, c2, c3, c4;
	c1 = cross(x1, y1, x2, y2, x1, y1, x3, y3);
	c2 = cross(x1, y1, x2, y2, x1, y1, x4, y4);
	c3 = cross(x3, y3, x4, y4, x3, y3, x1, y1);
	c4 = cross(x3, y3, x4, y4, x4, y4, x2, y2);
	if (c1 != c2 && c3 != c4) return true;
	if (!c1 && mid(x1, y1, x2, y2, x3, y3)) return true;
	if (!c2 && mid(x1, y1, x2, y2, x4, y4)) return true;
	if (!c3 && mid(x3, y3, x4, y4, x1, y1)) return true;
	if (!c4 && mid(x3, y3, x4, y4, x2, y2)) return true;
	return false;
}
 
int main () { _
	int t;
	cin >> t;
	while (t--) {
		cout << (valid() ? "YES\n" : "NO\n");
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2189
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	int t;
	cin >> t;
	while (t--) {
		int x1, x2, x3, y1, y2, y3;
		cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;
		ll val = 1ll * (x2-x1) * (y3-y1) - 1ll * (y2-y1) * (x3-x1);
		if (val == 0) cout << "TOUCH\n";
		if (val < 0) cout << "RIGHT\n";
		if (val > 0) cout << "LEFT\n";
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2187
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
	int n;
	string s;
	cin >> n >> s;
	int x = 0, y = 0;
	bool valid = true;
	for (int i = 0; i < (int)s.size(); i++) {
		x += (s[i] == '(');
		y += (s[i] == ')');
		valid &= (x >= y);
	}
	vector<ll> fat(2e6+10, 1), inv(1e6+10);
	for (int i = 2; i <= 2e6; i++) {
		fat[i] = (fat[i-1] * i) % M;
	}	
	ll b = fat[1e6], e = M-2, resp = 1;
	while (e) {
		if (e&1) resp = resp * b % M;
		e = (e>>1);
		b = b * b % M;
	}
	inv[1e6] = resp;
	for (int i = 1e6-1; i >= 0; i--) {
		inv[i] = (inv[i+1] * (i+1)) % M;
	}
	if (!valid || x > n/2 || n&1) cout << "0\n";
	else if (x == n/2) cout << "1\n";
	else {
		ll ans = fat[n - x - y] * inv[n/2 - x] % M;
		ans = ans * inv[n/2 - y] % M;
		ll tira = fat[n - x - y] * inv[n/2 - y + 1] % M;
		tira = tira * inv[n/2 - x - 1] % M;
		ans -= tira;
		if (ans < 0) ans += M;
		cout << ans << '\n';
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2186
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 4e5 + 5;
const ll INF = 2e18;
 
map<vector<int>, int> mp;
map<char, int> mapao;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    int n = s.size();
    set<char> st;
    for (auto x : s) st.insert(x);
    int tam = st.size();
    vector<int> v(tam);
    mp[v] = 1;
    ll ans = 0;
    int cnt = 0;
    for (auto x : st) {
        mapao[x] = cnt;
        cnt++;
    }
    for (int i = 0; i < n; i++) {
        v[mapao[s[i]]]++;
        vector<int> nv = v;
        int mn = *min_element(v.begin(), v.end());
        for (int j = 0; j < tam; j++) nv[j] -= mn;
        ans += mp[nv];
        mp[nv]++;
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2420
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 4e5 + 5;
const ll INF = 2e18;
 
int pre[MAXN], pwr[MAXN], a[MAXN];
 
void add(int pos, int val) {
    pos+=2;
    for (; pos < MAXN; pos += (pos & -pos)) {
        a[pos] += val;
        if (a[pos] >= MOD) a[pos] -= MOD;
        if (a[pos] < 0) a[pos] += MOD;
    }
}
 
int ans(int pos) {
    int ans = 0;
    pos+=2;
    for (; pos; pos -= (pos & -pos)) {
        ans += a[pos];
        if (ans >= MOD) ans -= MOD;
        if (ans < 0) ans += MOD;
    }
    return ans;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
    string s, ns;
    cin >> n >> m >> s;
    ns = s;
    reverse(ns.begin(), ns.end());
    s += ns;
    pwr[0] = 1;
    for (int i = 1; i < MAXN; i++) pwr[i] = (1ll * pwr[i-1] * 29) % MOD;
    for (int i = 0; i < 2 * n; i++) {
        add(i, ((s[i] - 'a' + 1ll) * pwr[i]) % MOD); 
    }
    int tipo, a, b;
    char c;
    for (int i = 0; i < m; i++) {
        cin >> tipo;
        if (tipo == 1) {
            cin >> a >> c;
            a--;
            add(a, -1 * (((s[a] - 'a' + 1ll) * pwr[a]) % MOD));
            add(2 * n - a - 1, -1 * (((s[2 * n - a - 1] - 'a' + 1ll) * pwr[2 * n - a - 1]) % MOD));
            s[a] = s[2 * n - a - 1] = c;
            add(a, ((s[a] - 'a' + 1ll) * pwr[a]) % MOD);
            add(2 * n - a - 1, ((s[2 * n - a - 1] - 'a' + 1ll) * pwr[2 * n - a - 1]) % MOD);
        }
        else {
            cin >> a >> b;
            a--, b--;
            int val1 = (ans(b) - ans(a - 1) + MOD) % MOD;
            int val2 = (ans(2 * n - a - 1) - ans(2 * n - b - 2) + MOD) % MOD;
            val1 = (1ll * val1 * pwr[2 * n - a - b - 1]) % MOD;
            cout << (val1 == val2 ? "YES\n" : "NO\n");
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2432
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 4e5 + 5;
const ll INF = 2e18;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    priority_queue<pii> fila;
    pii aux;
    vector<int> linha(n);
    for (int i = 0; i < n; i++) {
        cin >> linha[i];
        aux.first = linha[i];
        aux.second = i;
        fila.push(aux);
    }
    vector<vector<char>> ans(n, vector<char> (n, '.'));
    int a;
    for (int i = 0; i < n; i++) {
        cin >> a;
        vector<pii> b;
        for (int j = 0; j < a; j++) {
            b.push_back(fila.top());
            fila.pop();
        } 
        for (auto x : b) {
            ans[x.second][i] = 'X';
            x.first--;
            fila.push(x);
        }
    }
    bool ok = true;
    for (int i = 0; i < n; i++) {
        int cnt = 0;
        for (int j = 0; j < n; j++) {
            cnt += ans[i][j] == 'X';
        }
        ok &= cnt == linha[i];
    }
    if (!ok) cout << "-1\n";
    else {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                cout << ans[i][j];
            }
            cout << '\n';
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2431
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int q;
	cin >> q;
	while (q--) {
		ll k;
		cin >> k;
		ll count = 1, minus = 9;
		while (k - minus > 0) {
			k -= minus;
			minus /= count;
			count++;
			minus *= 10 * count;
		}
		ll num = (k-1)/count + 1;
		ll base = 0, soma = 9;
		for (int i = 0; i < count-1; i++) {
			base += soma;
			soma *= 10;
		}
		string ans = to_string(base+num);
		int alga;
		if (k % count == 0) alga = count-1;
		else alga = k % count - 1;
		cout << ans[alga] << endl;
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2430
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 5e5 + 5;
const ll INF = 1e18;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    int mn = n + 1, ans = -1;
    for (int i = 0; i <= n / 2; i++) {
        // try i and n - i
        int cnt = 0;
        int a = i, b = n - i;
        bool ok = true;
        while (a || b) {
            if (a < b) swap(a, b);
            if (a == b) {
                ok = false;
                break;
            }
            cnt += a / (b + 1);
            a %= (b + 1);
        }
        if (ok && cnt < mn) {
            mn = cnt;
            ans = i;
        } 
    }
    string s;
    int a = ans, b = n - a, z = 0;
    while (a || b) {
        if (a < b) {
            swap(a, b);
            z ^= 1;
        }
        int tot = a / (b + 1);
        for (int i = 0; i < tot; i++) s += '0' + z;
        a %= (b + 1);
    }
    cout << s << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2428
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n, k;
	cin >> n >> k;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	map<int, int> mapa;
	ll resp = 0;
	int r = 0, dist = 0;
	for (int l = 0; l < n; l++) {
		while (r < n && dist <= k) {
			mapa[v[r]]++;
			if (mapa[v[r]] == 1) dist++;
			r++;
		}
		resp += (r-l);
		if (dist > k) resp--;
		mapa[v[l]]--;
		if (mapa[v[l]] == 0) dist--;
	}
	cout << resp << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2426
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 10;
const ll INF = 2e18;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int p, a, n;
    cin >> p >> a >> n;
    vector<pii> v(n);
    for (auto &x : v) cin >> x.first >> x.second;
    sort(v.rbegin(), v.rend());
    if (!p) {
        priority_queue<int> fila;
        for (auto x : v) fila.push(x.second);
        ll ans = 0;
        for (int i = 0; i < a; i++) {
            ans += fila.top();
            fila.pop();
        }
        cout << ans << '\n';
        return 0;
    }
    vector<ll> pre(n + 1), suf(n + 1);
    
    // pegar 0 dos p primeiros, 1 dos p + 1...
    priority_queue<ll> fila;
    ll tot = 0;
    for (int i = 0; i < p; i++) {
        tot += v[i].first;
        fila.push(v[i].second - v[i].first);
        pre[i] = tot;
    } 
    for (int i = p; i < p + a; i++) {
        ll mx = fila.top();
        fila.pop();
        tot += mx + v[i].first;
        pre[i] = tot;
        fila.push(v[i].second - v[i].first);
    }
 
    while (!fila.empty()) fila.pop();
    for (int i = n - 1; i >= p + a; i--) {
        fila.push(v[i].second);
    }
    tot = 0;
    for (int i = p + a - 1; i >= p; i--) {
        fila.push(v[i].second);
        ll mx = fila.top();
        fila.pop();
        tot += mx;
        suf[i] = tot;
    }
    ll ans = 0;
    for (int i = max(0, p - 1); i < p + a; i++) {
        ans = max(ans, pre[i] + suf[i + 1]);
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2425
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
ll lz[4 * MAXN], a[2][4 * MAXN];
 
void push(int node, int i, int j) {
	a[0][node] += lz[node];
	a[1][node] += lz[node];
	if (i != j) {
		lz[2 * node] += lz[node];
		lz[2 * node + 1] += lz[node];
	}
	lz[node] = 0;
}
 
void upd(int node, int i, int j, int ini, int fim, int val) {
	push(node, i, j);
	if (ini <= i && j <= fim) {
		lz[node] += val;
		push(node, i, j);
	}
	else if (j < ini || i > fim) return;
	else {
		int m = (i + j) / 2;
		upd(2 * node, i, m, ini, fim, val);
		upd(2 * node + 1, m + 1, j, ini, fim, val);
		a[0][node] = min(a[0][2 * node], a[0][2 * node + 1]);
		a[1][node] = max(a[1][2 * node], a[1][2 * node + 1]);
	}
}
 
 
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
	cin >> n;
	int pos, st;
	for (int i = 0; i < n; i++) {
		cin >> pos >> st;
		upd(1, 1, n, 1, pos, (st == 1 ? -1 : 1));
		int mn = a[0][1];
		int mx = a[1][1];
		if (mn >= 0 && mx >= 0) cout << "<\n";
		else if (mn <= 0 && mx <= 0) cout << ">\n";
		else cout << "?\n";
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2423
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
 
int v[105][105];
string impar[] = {
	"ABBAA",
	"AABAB",
	"BBABB",
	"ABAAC",
	"AABCC",
	"CBBDD",
	"CCAAD",
	"ABBAC",
	"AABCC"
};
 
void even(int x, int y, int n, int m) {
	for (int i = x; i < n; i += 3) {
		for (int j = y; j < m; j += 2) {
			
			// preencher um 3x2
			set<int> st;
			st.insert(v[i - 1][j]);
			st.insert(v[i - 1][j + 1]);
			st.insert(v[i][j - 1]);
			st.insert(v[i + 1][j - 1]);
			int cor;
			for (int k = 0; k <= 4; k++) {
				if (st.count(k) == 0) {
					cor = k;
					break;
				}
			}
			v[i][j] = v[i + 1][j] = v[i][j + 1] = cor;
			st.clear();
			st.insert(cor);
			st.insert(v[i + 2][j - 1]);
			for (int k = 0; k <= 2; k++) {
				if (st.count(k) == 0) {
					cor = k;
					break;
				}
			}
			v[i + 2][j] = v[i + 1][j + 1] = v[i + 2][j + 1] = cor;
		}
	}
}
 
void odd(int x, int j, int n, int m) {
	for (int i = x; i < n; i += 2) {
		set<int> st;
		st.insert(v[i - 1][j]);
		st.insert(v[i - 1][j + 1]);
		st.insert(v[i][j - 1]);
		st.insert(v[i + 1][j - 1]);
		int cor;
		for (int k = 0; k <= 4; k++) {
			if (st.count(k) == 0) {
				cor = k;
				break;
			}
		}
		v[i][j] = v[i + 1][j] = v[i][j + 1] = cor;
		st.clear();
		st.insert(cor);
		st.insert(v[i - 1][j + 2]);
		for (int k = 0; k <= 2; k++) {
			if (st.count(k) == 0) {
				cor = k;
				break;
			}
		}
		v[i][j + 2] = v[i + 1][j + 1] = v[i + 1][j + 2] = cor;
	}
	even(x, j + 3, n, m);
}
 
void oodd(int x, int y, int n, int m) {
	for (int i = x; i < x + 9; i++) {
		for (int j = y; j < y + 5; j++) v[i][j] = impar[i - x][j - y] - 'A';
	}
	odd(x + 9, y, n, y + 5);
	even(x, y + 5, n, m);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
	cin >> t;
	while (t--) {
		int n, m;
		cin >> n >> m;
		bool sw = false, ok = false;
		if (n % 3 != 0) {
			swap(n, m);
			sw = true;
		}
		if (n % 3 != 0 || min(n, m) < 2) cout << "NO\n";
		else if (m % 2 == 0) {
			// m par e n par ou impar
			
			ok = true;
			even(1, 1, n + 1, m + 1);
 
		}
		else if (n % 2 == 0) {
			// n par e m impar
			
			ok = true;	
			odd(1, 1, n + 1, m + 1);
		}
		else {
			// ambos impares
			
			if (n < 9 || m < 5) cout << "NO\n";
			else {
				ok = true;
				oodd(1, 1, n + 1, m + 1);
			}
		}
		if (ok) {
			cout << "YES\n";
			if (sw) {
				for (int i = 1; i <= m; i++) {
					for (int j = 1; j <= n; j++) cout << char('A' + v[j][i]);
					cout << '\n';
				}
			}
			else {
				for (int i = 1; i <= n; i++) {
					for (int j = 1; j <= m; j++) cout << char('A' + v[i][j]);
					cout << '\n';
				}
			}
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2422
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	ll n;
	cin >> n;
	ll l = 0, r = n * n;
	while (r > l + 1) {
		ll m = (r + l) / 2;
		ll sum = 0;
		for (int i = 1; i <= n; i++) {
			sum += min(m/i, n);
		}
		if (sum >= (n * n) / 2 + 1) r = m;
		else l = m;
	}
	cout << r << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2185
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    ll n;
	int k;
	cin >> n >> k;
	vector<ll> v(k), l(k);
	for (int i = 0; i < k; i++) cin >> v[i];
	sort(v.begin(), v.end());
	for (int i = 0; i < k; i++) l[i] = n/v[i] + 1;
	ll ans = 0;
	for (int i = 1; i < (1<<k); i++) {
		ll tot = 1;
		bool par = true;
		for (int j = 0; j < k; j++) {
			if (i & (1<<j)) {
				par = 1-par;
				if (tot > l[j]) {
					tot = 0;
					break;	
				}
				tot *= v[j];
			}
		}
		if (tot) tot = n/tot;
		ans += (par ? -tot : tot);
	}
	cout << ans << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2419
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int main () { _
	int n;
	cin >> n;
	vector<int> v(n), par(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	// par[i] = 1 if i submask de n
	for (int i = 0; i < n; i++) {
		par[i] = ((i & (n-1)) == i);
	}
	int ans = 0;
	for (int i = 0; i < n; i++) {
		ans ^= par[i] * v[i];
	}
	cout << ans << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2417
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	ll n, aux;
	cin >> n;
	vector<ll> c(1e6+10), t(1e6+10, -1), p(1e6+10, 1);
	for (int i = 0; i < n; i++) {
		cin >> aux;
		c[aux]++;
	}
	ll ans = (n * (n-1)) / 2;
	ll valid = 0;
	for (int i = 2; i <= 1e6; i++) {
		if (p[i]) {
			t[i] = 1;
			for (int j = 2*i; j <= 1e6; j+=i) {
				p[j] = 0;
				if (j/i % i == 0) t[j] = 0;
				else t[j] = 0 - t[j];
			}
		}
	}
	for (int i = 2; i <= 1e6; i++) {
		if (t[i]) {
			ll total = 0;
			for (int j = i; j <= 1e6; j+=i) total += c[j];
			valid += t[i] * (total * (total-1)) / 2;
		}
	}
	cout << ans - valid << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2416
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
struct que{
	int l, r, id;
};
 
ll v[MAXN], a[MAXN], pre[MAXN], cb[MAXN], resp[MAXN];
vector<que> qs[MAXN];
 
void upd(int pos, ll val) { for (int i = pos; i < MAXN; i += (i & -i)) a[i] += val; }
 
ll sum(int pos) {
	ll ans = 0;
	for (int i = pos; i > 0; i -= (i & -i)) ans += a[i];
	return ans;
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		pre[i] = v[i] + pre[i-1];
	}
	v[n+1] = INF;
	pre[n+1] = v[n+1] + pre[n];
	que aux;
	for (int i = 0; i < q; i++) {
		cin >> aux.l >> aux.r;
		aux.id = i;
		qs[aux.l].pb(aux);
	}
	deque<int> sk(1, n+1);
	for (int i = n; i > 0; i--) {
		while (v[i] > v[sk.front()]) {
			upd(sk.front(), -cb[sk.front()]);
			sk.pop_front();
		}
		cb[i] = 1ll * (sk.front() - i - 1) * v[i] - (pre[sk.front() - 1] - pre[i]);
		upd(i, cb[i]);
		sk.push_front(i);
		for (que x : qs[i]) {
			int pos = upper_bound(sk.begin(), sk.end(), x.r) - sk.begin() - 1;
			ll ans = sum(sk[pos]) - 1ll * (sk[pos+1] - x.r - 1) * v[sk[pos]] + (pre[sk[pos+1]-1] - pre[x.r]); 
			resp[x.id] = ans;
		}
	}
	for (int i = 0; i < q; i++) cout << resp[i] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2414
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 10;
const ll INF = 2e18;
 
vector<int> v;
int n;
 
bool check(int a0) {
    multiset<int> st;
    for (int x : v) st.insert(x);
    vector<int> ans(1, a0);
    for (int i = 1; i < n; i++) {
        int bg = *st.begin();
        ans.push_back(bg - a0);
        st.erase(st.begin());
        for (int j = 1; j < (int)ans.size() - 1; j++) {
            if (st.find(ans.back() + ans[j]) == st.end())
                return false;
            else st.erase(st.find(ans.back() + ans[j]));
        }
    }
    for (int x : ans) cout << x << ' ';
    cout << '\n';
    return true;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n;
    int tam = n * (n - 1) / 2;
    v.resize(tam);
    for (int &x : v) cin >> x;
    sort(v.begin(), v.end());
    for (int i = 2; i < tam; i++) {
        // brute a1 + a2 = v[i]
        int a2 = (v[1] - v[0] + v[i]) / 2;
        int a1 = v[i] - a2, a0 = v[0] - a1;
        if (check(a0)) return 0;
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2413
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int t;
    cin >> t;
    vector<vector<ll>> dp(1e6+5, vector<ll> (5));
    dp[1][0] = 2, dp[1][1] = dp[1][2] = dp[1][3] = dp[1][4] = 1;
    for (int i = 1; i <= 1e6; i++) {
        dp[i+1][0] = (2*dp[i][0] + dp[i][1] + dp[i][2] + dp[i][3] + dp[i][4]) % M;
        dp[i+1][1] = (dp[i][0] + dp[i][1] + dp[i][2] + dp[i][3]) % M;
        dp[i+1][2] = dp[i+1][1];
        dp[i+1][3] = (dp[i][0] + dp[i][1] + dp[i][2] + dp[i][3]) % M;
        dp[i+1][4] = (dp[i][0] + dp[i][4]) % M;
    }
    while (t--) {
        int n;
        cin >> n;
        cout << dp[n][0] << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2229
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
int dp[126000], pre[126000];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, k;
    cin >> n >> k;
    dp[0] = 1;
    pre[0] = pre[1] = 1;
    for (int i = 2; i <= n; i++) {
        int lim = (i * (i-1)) / 2;
        for (int j = 0; j <= lim; j++) {
            dp[j] = pre[j] - (j-i >= 0 ? pre[j-i] : 0);
            if (dp[j] < 0) dp[j] += MOD;
            if (dp[j] >= MOD) dp[j] -= MOD;
        }
        lim = (i * (i+1)) / 2;
        for (int j = 0; j <= lim; j++) {
            pre[j] = dp[j] + (!j ? 0 : pre[j-1]);
            if (pre[j] >= MOD) pre[j] -= MOD;
        }
    }
    cout << dp[k] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2228
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e6 + 5;
const ll INF = 2e18;
 
int fat[MAXN], inv[MAXN];
 
int fexp(ll b, int e) {
    ll ans = 1;
    while (e) {
        if (e & 1) ans = (ans * b) % MOD;
        b = (b * b) % MOD;
        e >>= 1;
    }
    return ans;
}
 
void init() {
    fat[0] = 1;
    for (int i = 1; i < MAXN; i++) fat[i] = (1ll * fat[i - 1] * i) % MOD;
    inv[MAXN - 1] = fexp(fat[MAXN - 1], MOD - 2);
    for (int i = MAXN - 2; i >= 0; i--) inv[i] = (1ll * inv[i + 1] * (i + 1)) % MOD;
}
 
int mul(int a, int b) {
    return 1ll * a * b % MOD;
}
 
void add(int &a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
    if (a < 0) a += MOD;
}
 
int nck(int n, int k) {
    if (k > n || k < 0) return 0;
    return (((1ll * fat[n] * inv[k]) % MOD) * 1ll * inv[n - k]) % MOD;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    init();
    int n, k;
    cin >> n >> k;
    int ans = 0;
    for (int i = 0; i < k; i++) {
        add(ans, (i % 2 == 0 ? 1 : -1) * mul(fexp(k - i, n), nck(k, k - i)));
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2220
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
char cnum[10] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
string a, b;
ll dp[20][11][2][2][2];
// pos na string, ultimo digito, flag de ultrapassar, flag pra qual string estamos vendo, flag pra se ja teve num > 0
 
ll count(int pos, int ult, bool flag, bool pri, bool ja) {
    ll &resp = dp[pos][ult][flag][pri][ja];
    if (resp >= 0) return resp;
    if ((pri ? pos == (int)a.size() : pos == (int)b.size())) return 1ll;
    ll ans = 0;
    if (pri) {
        for (int i = 0; i < 10; i++) {
            if (cnum[i] > a[pos] && flag) break;
            if (cnum[i] == a[pos] && i != ult) {
                ans += count(pos+1, (!i && !ja ? 10 : i), flag, pri, (!i ? ja : true));
            }
            else if ((cnum[i] < a[pos] || !flag) && i != ult) {
                ans += count(pos+1, (!i && !ja ? 10 : i), false, pri, (!i ? ja : true));
            }
        }
    }
    else {
        for (int i = 0; i < 10; i++) {
            if (cnum[i] > b[pos] && flag) break;
            if (cnum[i] == b[pos] && i != ult) {
                ans += count(pos+1, (!i && !ja ? 10 : i), flag, pri, (!i ? ja : true));
            }
            else if ((cnum[i] < b[pos] || !flag) && i != ult) {
                ans += count(pos+1, (!i && !ja ? 10 : i), false, pri, (!i ? ja : true));
            }
        }
    }
    return resp = ans;
}
 
int main () { _
    ll c;
    memset(dp, -1, sizeof(dp));
    cin >> c >> b;
    c--;
    a = to_string(c);
    ll ans = count(0, 10, true, false, false) - (c >= 0 ? count(0, 10, true, true, false) : 0ll);
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2121
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
// MinCostMaxFlow
//
// min_cost_flow(s, t, f) computa o par (fluxo, custo)
// com max(fluxo) <= f que tenha min(custo)
// min_cost_flow(s, t) -> Fluxo maximo de custo minimo de s pra t
// Se for um dag, da pra substituir o SPFA por uma DP pra nao
// para O(nm) no comeco
// Se nao tiver aresta com custo negativo, nao precisa do SPFA
//
// O(nm + f * m log n)
// 697b4c
 
template<typename T = int> struct mcmf {
	struct edge {
		int to, rev, flow, cap; // para, id da reversa, fluxo, capacidade
		bool res; // se eh reversa
		T cost; // custo da unidade de fluxo
		edge() : to(0), rev(0), flow(0), cap(0), cost(0), res(false) {}
		edge(int to_, int rev_, int flow_, int cap_, T cost_, bool res_)
			: to(to_), rev(rev_), flow(flow_), cap(cap_), res(res_), cost(cost_) {}
	};
 
	vector<vector<edge>> g;
	vector<int> par_idx, par;
	T inf;
	vector<T> dist;
 
	mcmf(int n) : g(n), par_idx(n), par(n), inf(numeric_limits<T>::max()/3) {}
 
	void add(int u, int v, int w, T cost) { // de u pra v com cap w e custo cost
		edge a = edge(v, g[v].size(), 0, w, cost, false);
		edge b = edge(u, g[u].size(), 0, 0, -cost, true);
 
		g[u].push_back(a);
		g[v].push_back(b);
	}
 
	vector<T> spfa(int s) { // nao precisa se nao tiver custo negativo
		deque<int> q;
		vector<bool> is_inside(g.size(), 0);
		dist = vector<T>(g.size(), inf);
 
		dist[s] = 0;
		q.push_back(s);
		is_inside[s] = true;
 
		while (!q.empty()) {
			int v = q.front();
			q.pop_front();
			is_inside[v] = false;
 
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
 
					if (is_inside[to]) continue;
					if (!q.empty() and dist[to] > dist[q.front()]) q.push_back(to);
					else q.push_front(to);
					is_inside[to] = true;
				}
			}
		}
		return dist;
	}
	bool dijkstra(int s, int t, vector<T>& pot) {
		priority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> q;
		dist = vector<T>(g.size(), inf);
		dist[s] = 0;
		q.emplace(0, s);
		while (q.size()) {
			auto [d, v] = q.top();
			q.pop();
			if (dist[v] < d) continue;
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				cost += pot[v] - pot[to];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
					q.emplace(dist[to], to);
					par_idx[to] = i, par[to] = v;
				}
			}
		}
		return dist[t] < inf;
	}
 
	pair<int, T> min_cost_flow(int s, int t, int flow) {
		vector<T> pot(g.size(), 0);
		pot = spfa(s); // mudar algoritmo de caminho minimo aqui
 
		int f = 0;
		T ret = 0;
		while (f < flow and dijkstra(s, t, pot)) {
			for (int i = 0; i < g.size(); i++)
				if (dist[i] < inf) pot[i] += dist[i];
 
			int mn_flow = flow - f, u = t;
			while (u != s){
				mn_flow = min(mn_flow,
					g[par[u]][par_idx[u]].cap - g[par[u]][par_idx[u]].flow);
				u = par[u];
			}
 
			ret += pot[t] * mn_flow;
 
			u = t;
			while (u != s) {
				g[par[u]][par_idx[u]].flow += mn_flow;
				g[u][g[par[u]][par_idx[u]].rev].flow -= mn_flow;
				u = par[u];
			}
 
			f += mn_flow;
		}
 
		return make_pair(f, ret);
	}
 
	// Opcional: retorna as arestas originais por onde passa flow = cap
	vector<pair<int,int>> recover() {
		vector<pair<int,int>> used;
		for (int i = 0; i < g.size(); i++) for (edge e : g[i])
			if(e.flow == e.cap && !e.res) used.push_back({i, e.to});
		return used;
	}
};
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, k, a, b, c, d;
    cin >> n >> m >> k;
    mcmf ber(n + 2);
    ber.add(0, 1, k, 0);
    ber.add(n, n + 1, k, 0);
    for (int i = 0; i < m; i++) {
        cin >> a >> b >> c >> d;
        ber.add(a, b, c, d);
    }
    pii ans = ber.min_cost_flow(0, n + 1, ber.inf);
    if (ans.first < k) cout << "-1\n";
    else cout << ans.second << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2137
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#pragma GCC target("popcnt")
#include <iostream>
#include <bitset>
using namespace std;
const int N = 3000;
bitset<N> v[N];
string s;
int main () {
	int n;
	string s;
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> s;
		v[i] = bitset<N>(s);
	}
	long long int ans = 0;
	for (int i = 0; i < n; i++) {
		for (int j = i+1; j < n; j++) {
			int tot = (v[i] & v[j]).count();
			ans += (tot * (tot-1))/2;
		}
	}
	cout << ans << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2136
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n, k;
	cin >> n >> k;
	vector<pii> v(n);
	string s;
	cin >> s;
	v[0].S = stoi(s, nullptr, 2);
	int resp = k;
	for (int i = 1; i < n; i++) {
		cin >> s;
		v[i].S = stoi(s, nullptr, 2);
		v[i].F = __builtin_popcount(v[0].S ^ v[i].S);
		resp = min(resp, v[i].F);
	}	
	sort(v.begin(), v.end());
	for (int i = 1; i < n; i++) {
		for (int j = i+1; j < n; j++) {
			if (v[j].F < v[i].F + resp) {
				resp = min(resp, __builtin_popcount(v[j].S ^ v[i].S));
			}
			else break;
		}
	}
	cout << resp << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2134
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const int INF = 2e9;
 
vector<int> g[MAXN];
int pos[MAXN], sz[MAXN], pai[MAXN], peso[MAXN];
int h[MAXN], t, n;
int seg[2 * MAXN];
 
void build() {
	for (int i = n - 1; i; i--) seg[i] = max(seg[2*i], seg[2*i+1]);
}
 
int query(int a, int b) {
	int ret = 0;
	for(a += n, b += n; a <= b; ++a /= 2, --b /= 2) {
		if (a % 2 == 1) ret = max(ret, seg[a]);
		if (b % 2 == 0) ret = max(ret, seg[b]);
	}
	return ret;
}
 
void upd(int p, int x) {
	seg[p += n] = x;
	while (p /= 2) seg[p] = max(seg[2*p], seg[2*p+1]);
}
 
void dfs(int node, int p = -1) {
    sz[node] = 1;
    for (int& x : g[node]) {
        if (x == p) continue;
        dfs(x, node);
        sz[node] += sz[x];
        if (sz[x] > sz[g[node][0]] || g[node][0] == p) swap(x, g[node][0]);
    }
}
 
void build_hld(int k, int p = -1) {
    pos[k] = t++;
    seg[pos[k] + n] = peso[k];
    for (auto& i : g[k]) {
        if (i != p) {
            pai[i] = k;
            h[i] = (i == g[k][0] ? h[k] : i);
            build_hld(i, k); 
        }
    }
}
 
int query_path(int a, int b) {
    if (pos[a] < pos[b]) swap(a, b);
    int ans = 0;
    while (h[a] != h[b]) {
        if (pos[a] < pos[b]) swap(a, b);
        ans = max(ans, query(pos[h[a]], pos[a]));
        a = pai[h[a]];
    }
    if (pos[a] < pos[b]) swap(a, b);
    return max(ans, query(pos[b], pos[a]));
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> peso[i];
    int tipo, a, b;
    for (int i = 0; i < n - 1; i++) {
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    dfs(1);
    h[1] = 1;
    build_hld(1);
    build();
    for (int i = 0; i < q; i++) {
        cin >> tipo >> a >> b;
        if (tipo == 1) {
            upd(pos[a], b);
        }
        else {
            cout << query_path(a, b) << '\n';
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2133
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const int INF = 2e9;
 
// Seg
 
struct no {
    vector<pii> v;
    no() {
        v = vector<pii> ();
    }
} a[4 * MAXN];
 
void update(int node, int i, int j, int ini, int fim, pii val) {
    if (j < ini || i > fim) return;
    else if (ini <= i && j <= fim) {
        a[node].v.push_back(val);
    }
    else {
        int m = (i + j) / 2;
        update(2 * node, i, m, ini, fim, val);
        update(2 * node + 1, m + 1, j, ini, fim, val);
    }
}
 
int ans[MAXN], pai[MAXN], sz[MAXN], resp;
map<pii, int> mp;
stack<int> st;
 
// DSU
 
int find(int x) {
    if (x == pai[x]) return x;
    return find(pai[x]);
}
 
void join(int a, int b) {
    a = find(a), b = find(b);
    if (sz[a] < sz[b]) {
        swap(a, b);
    }
    pai[b] = a;
    sz[a] += sz[b];
    st.push(b);
    resp--;
}
 
void rollback() {
    int at = st.top();
    st.pop();
    sz[pai[at]] -= sz[at];
    pai[at] = at;
    resp++;
}
 
//
 
void dfs(int node, int i, int j) {
    int cnt = 0;
    for (auto x : a[node].v) {
        if (find(x.first) != find(x.second)) {
            join(x.first, x.second);
            cnt++;
        }
    }
    if (i == j) {
        ans[i] = resp;
    }
    else {
        int m = (i + j) / 2;
        dfs(2 * node, i, m);
        dfs(2 * node + 1, m + 1, j);
    }
    for (int i = 0; i < cnt; i++) {
        rollback();
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, k, tipo, a, b;
    cin >> n >> m >> k;
    resp = n;
    for (int i = 1; i <= n; i++) pai[i] = i, sz[i] = 1;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        if (a > b) swap(a, b);
        mp[{a, b}] = 0;
    }
    for (int i = 1; i <= k; i++) {
        // tempo i
 
        cin >> tipo >> a >> b;
        if (a > b) swap(a, b);
        if (tipo == 1) {
            mp[{a, b}] = i;
        }
        else {
            update(1, 0, k + 1, mp[{a, b}], i - 1, {a, b});
            mp[{a, b}] = -1;
        }
    }
    for (auto x : mp) {
        if (x.second == -1) continue;
        update(1, 0, k + 1, x.second, k + 1, x.first);
    }
    dfs(1, 0, k + 1);
    for (int i = 0; i <= k; i++) cout << ans[i] << ' ';
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2132
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
priority_queue<int> fila;
 
int main () { _
	int n, aux;
	cin >> n;
	ll ans = 0;
	for (int i = 0; i < n; i++) {
		cin >> aux;
		fila.push(aux);
		ans += fila.top() - aux;
		fila.pop();
		fila.push(aux);
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2131
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
// MinCostMaxFlow
//
// min_cost_flow(s, t, f) computa o par (fluxo, custo)
// com max(fluxo) <= f que tenha min(custo)
// min_cost_flow(s, t) -> Fluxo maximo de custo minimo de s pra t
// Se for um dag, da pra substituir o SPFA por uma DP pra nao
// para O(nm) no comeco
// Se nao tiver aresta com custo negativo, nao precisa do SPFA
//
// O(nm + f * m log n)
// 697b4c
 
template<typename T = int> struct mcmf {
	struct edge {
		int to, rev, flow, cap; // para, id da reversa, fluxo, capacidade
		bool res; // se eh reversa
		T cost; // custo da unidade de fluxo
		edge() : to(0), rev(0), flow(0), cap(0), cost(0), res(false) {}
		edge(int to_, int rev_, int flow_, int cap_, T cost_, bool res_)
			: to(to_), rev(rev_), flow(flow_), cap(cap_), res(res_), cost(cost_) {}
	};
 
	vector<vector<edge>> g;
	vector<int> par_idx, par;
	T inf;
	vector<T> dist;
 
	mcmf(int n) : g(n), par_idx(n), par(n), inf(numeric_limits<T>::max()/3) {}
 
	void add(int u, int v, int w, T cost) { // de u pra v com cap w e custo cost
		edge a = edge(v, g[v].size(), 0, w, cost, false);
		edge b = edge(u, g[u].size(), 0, 0, -cost, true);
 
		g[u].push_back(a);
		g[v].push_back(b);
	}
 
	vector<T> spfa(int s) { // nao precisa se nao tiver custo negativo
		deque<int> q;
		vector<bool> is_inside(g.size(), 0);
		dist = vector<T>(g.size(), inf);
 
		dist[s] = 0;
		q.push_back(s);
		is_inside[s] = true;
 
		while (!q.empty()) {
			int v = q.front();
			q.pop_front();
			is_inside[v] = false;
 
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
 
					if (is_inside[to]) continue;
					if (!q.empty() and dist[to] > dist[q.front()]) q.push_back(to);
					else q.push_front(to);
					is_inside[to] = true;
				}
			}
		}
		return dist;
	}
	bool dijkstra(int s, int t, vector<T>& pot) {
		priority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> q;
		dist = vector<T>(g.size(), inf);
		dist[s] = 0;
		q.emplace(0, s);
		while (q.size()) {
			auto [d, v] = q.top();
			q.pop();
			if (dist[v] < d) continue;
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				cost += pot[v] - pot[to];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
					q.emplace(dist[to], to);
					par_idx[to] = i, par[to] = v;
				}
			}
		}
		return dist[t] < inf;
	}
 
	pair<int, T> min_cost_flow(int s, int t, int flow) {
		vector<T> pot(g.size(), 0);
		pot = spfa(s); // mudar algoritmo de caminho minimo aqui
 
		int f = 0;
		T ret = 0;
		while (f < flow and dijkstra(s, t, pot)) {
			for (int i = 0; i < g.size(); i++)
				if (dist[i] < inf) pot[i] += dist[i];
 
			int mn_flow = flow - f, u = t;
			while (u != s){
				mn_flow = min(mn_flow,
					g[par[u]][par_idx[u]].cap - g[par[u]][par_idx[u]].flow);
				u = par[u];
			}
 
			ret += pot[t] * mn_flow;
 
			u = t;
			while (u != s) {
				g[par[u]][par_idx[u]].flow += mn_flow;
				g[u][g[par[u]][par_idx[u]].rev].flow -= mn_flow;
				u = par[u];
			}
 
			f += mn_flow;
		}
 
		return make_pair(f, ret);
	}
 
	// Opcional: retorna as arestas originais por onde passa flow = cap
	vector<pair<int,int>> recover() {
		vector<pair<int,int>> used;
		for (int i = 0; i < g.size(); i++) for (edge e : g[i])
			if(e.flow == e.cap && !e.res) used.push_back({i, e.to});
		return used;
	}
};
 
int resp[55][55];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, x;
    cin >> n;
    mcmf ber(2 * n + 2);
    int fluxo = 0;
    for (int i = 1; i <= n; i++) {
        cin >> x;
        fluxo += x;
        ber.add(0, i, x, 0);
    }
    for (int i = n + 1; i <= 2 * n; i++) {
        cin >> x;
        ber.add(i, 2*n + 1, x, 0);
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> x;
            ber.add(i + 1, n + j + 1, 1, -x);
        }
    }
    pii ans = ber.min_cost_flow(0, 2 * n + 1, ber.inf);
    if (ans.first < fluxo) cout << "-1\n";
    else {
        cout << -ans.second << '\n';
        vector<pii> ed = ber.recover();
        for (auto x : ed) {
            if (x.first != 0 && x.second != 2 * n + 1) 
                resp[x.first - 1][x.second - n - 1] = 1;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                cout << (resp[i][j] ? 'X' : '.');
            }
            cout << '\n';
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2130
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
// MinCostMaxFlow
//
// min_cost_flow(s, t, f) computa o par (fluxo, custo)
// com max(fluxo) <= f que tenha min(custo)
// min_cost_flow(s, t) -> Fluxo maximo de custo minimo de s pra t
// Se for um dag, da pra substituir o SPFA por uma DP pra nao
// para O(nm) no comeco
// Se nao tiver aresta com custo negativo, nao precisa do SPFA
//
// O(nm + f * m log n)
// 697b4c
 
template<typename T = int> struct mcmf {
	struct edge {
		int to, rev, flow, cap; // para, id da reversa, fluxo, capacidade
		bool res; // se eh reversa
		T cost; // custo da unidade de fluxo
		edge() : to(0), rev(0), flow(0), cap(0), cost(0), res(false) {}
		edge(int to_, int rev_, int flow_, int cap_, T cost_, bool res_)
			: to(to_), rev(rev_), flow(flow_), cap(cap_), res(res_), cost(cost_) {}
	};
 
	vector<vector<edge>> g;
	vector<int> par_idx, par;
	T inf;
	vector<T> dist;
 
	mcmf(int n) : g(n), par_idx(n), par(n), inf(numeric_limits<T>::max()/3) {}
 
	void add(int u, int v, int w, T cost) { // de u pra v com cap w e custo cost
		edge a = edge(v, g[v].size(), 0, w, cost, false);
		edge b = edge(u, g[u].size(), 0, 0, -cost, true);
 
		g[u].push_back(a);
		g[v].push_back(b);
	}
 
	vector<T> spfa(int s) { // nao precisa se nao tiver custo negativo
		deque<int> q;
		vector<bool> is_inside(g.size(), 0);
		dist = vector<T>(g.size(), inf);
 
		dist[s] = 0;
		q.push_back(s);
		is_inside[s] = true;
 
		while (!q.empty()) {
			int v = q.front();
			q.pop_front();
			is_inside[v] = false;
 
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
 
					if (is_inside[to]) continue;
					if (!q.empty() and dist[to] > dist[q.front()]) q.push_back(to);
					else q.push_front(to);
					is_inside[to] = true;
				}
			}
		}
		return dist;
	}
	bool dijkstra(int s, int t, vector<T>& pot) {
		priority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> q;
		dist = vector<T>(g.size(), inf);
		dist[s] = 0;
		q.emplace(0, s);
		while (q.size()) {
			auto [d, v] = q.top();
			q.pop();
			if (dist[v] < d) continue;
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				cost += pot[v] - pot[to];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
					q.emplace(dist[to], to);
					par_idx[to] = i, par[to] = v;
				}
			}
		}
		return dist[t] < inf;
	}
 
	pair<int, T> min_cost_flow(int s, int t, int flow) {
		vector<T> pot(g.size(), 0);
		pot = spfa(s); // mudar algoritmo de caminho minimo aqui
 
		int f = 0;
		T ret = 0;
		while (f < flow and dijkstra(s, t, pot)) {
			for (int i = 0; i < g.size(); i++)
				if (dist[i] < inf) pot[i] += dist[i];
 
			int mn_flow = flow - f, u = t;
			while (u != s){
				mn_flow = min(mn_flow,
					g[par[u]][par_idx[u]].cap - g[par[u]][par_idx[u]].flow);
				u = par[u];
			}
 
			ret += pot[t] * mn_flow;
 
			u = t;
			while (u != s) {
				g[par[u]][par_idx[u]].flow += mn_flow;
				g[u][g[par[u]][par_idx[u]].rev].flow -= mn_flow;
				u = par[u];
			}
 
			f += mn_flow;
		}
 
		return make_pair(f, ret);
	}
 
	// Opcional: retorna as arestas originais por onde passa flow = cap
	vector<pair<int,int>> recover() {
		vector<pair<int,int>> used;
		for (int i = 0; i < g.size(); i++) for (edge e : g[i])
			if(e.flow == e.cap && !e.res) used.push_back({i, e.to});
		return used;
	}
};
 
int n;
vector<pii> v[505], path;
 
void dfs(int node) {
    for (auto &x : v[node]) {
        if (!x.second && x.first != n + 1) {
            x.second = 1;
            path.emplace_back(node, x.first);
            dfs(x.first);
            break;
        }
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int m, k, a, b, c, d;
    cin >> n >> m >> k;
    mcmf ber(n + 2);
    ber.add(0, 1, k, 0);
    ber.add(n, n + 1, k, 0);
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        ber.add(a, b, 1, 1);
    }
    pii ans = ber.min_cost_flow(0, n + 1, ber.inf);
    if (ans.first < k) cout << "-1\n";
    else {
        cout << ans.second << '\n';
        vector<pii> ed = ber.recover();
        for (auto x : ed) {
            v[x.first].emplace_back(x.second, 0);
        }
        for (int i = 0; i < ans.first; i++) {
            dfs(1);
            cout << path.size() + 1 << '\n';
            cout << path[0].first << ' ';
            for (auto x : path) cout << x.second << ' ';
            cout << '\n';
            path.clear();
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2129
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e4 + 5;
const ll INF = 2e18;
 
template<typename T = int> struct hungarian {
	int n;
	vector<vector<T>> a;
	vector<T> u, v;
	vector<int> p, way;
	T inf;
 
	hungarian(int n_) : n(n_), u(n+1), v(n+1), p(n+1), way(n+1) {
		a = vector<vector<T>>(n, vector<T>(n));
		inf = numeric_limits<T>::max();
	}
	pair<T, vector<int>> assignment() {
		for (int i = 1; i <= n; i++) {
			p[0] = i;
			int j0 = 0;
			vector<T> minv(n+1, inf);
			vector<int> used(n+1, 0);
			do {
				used[j0] = true;
				int i0 = p[j0], j1 = -1;
				T delta = inf;
				for (int j = 1; j <= n; j++) if (!used[j]) {
					T cur = a[i0-1][j-1] - u[i0] - v[j];
					if (cur < minv[j]) minv[j] = cur, way[j] = j0;
					if (minv[j] < delta) delta = minv[j], j1 = j;
				}
				for (int j = 0; j <= n; j++)
					if (used[j]) u[p[j]] += delta, v[j] -= delta;
					else minv[j] -= delta;
				j0 = j1;
			} while (p[j0] != 0);
			do {
				int j1 = way[j0];
				p[j0] = p[j1];
				j0 = j1;
			} while (j0);
		}
		vector<int> ans(n);
		for (int j = 1; j <= n; j++) ans[p[j]-1] = j-1;
		return make_pair(-v[0], ans);
	}
};
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    hungarian ber(n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) cin >> ber.a[i][j];
    }
    pair<int, vector<int>> ans = ber.assignment();
    cout << ans.first << '\n';
    for (int i = 0; i < n; i++) {
        cout << i + 1 << ' ' << ans.second[i] + 1 << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2138
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 50100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
vector<int> v[MAXN], ord;
int check[MAXN];
bitset<MAXN> bits[MAXN];
 
void dfs(int node) {
	check[node] = 1;
	for (int x : v[node]) 
		if (!check[x]) dfs(x);
	ord.pb(node);
}
 
void dfs2(int node) {
	for (int x : v[node]) bits[node] |= bits[x];
}
 
int main() { _
	int n, m, a, b;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].pb(b);
	}
	for (int i = 1; i <= n; i++) {
		if (!check[i]) dfs(i);
		bits[i].set(i);
	}
	for (int x : ord) dfs2(x);
	for (int i = 1; i <= n; i++) cout << bits[i].count() << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2115
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
using cd = complex<double>;
const double PI = acos(-1);
 
void fft(vector<cd> & a, bool invert) {
    int n = a.size();
 
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;
 
        if (i < j)
            swap(a[i], a[j]);
    }
 
    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            cd w(1);
            for (int j = 0; j < len / 2; j++) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
 
    if (invert) {
        for (cd & x : a)
            x /= n;
    }
}
 
vector<ll> multiply(vector<int> const& a, vector<int> const& b) {
    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n < (int)(a.size() + b.size())) 
        n <<= 1;
    fa.resize(n);
    fb.resize(n);
 
    fft(fa, false);
    fft(fb, false);
    for (int i = 0; i < n; i++)
        fa[i] *= fb[i];
    fft(fa, true);
 
    vector<ll> result(n);
    for (int i = 0; i < n; i++)
        result[i] = round(fa[i].real());
    return result;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	string s;
    cin >> s;
    int n = (int)s.size();
    vector<int> v, w;
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        if (s[i] == '1') {
            v.push_back(cnt+1);
            cnt = 0;
        }
        else cnt++;
    }
    v.push_back(cnt+1);
    w = v;
    reverse(w.begin(), w.end());
    vector<ll> ans = multiply(v, w);
    ll zero = 0;
    for (int x : v) zero += (1ll * x * (x-1) / 2);
    cout << zero << ' ';
    int tot = 1;
    for (int i = (int)v.size(); i < (int)ans.size() && tot < n+1; i++) {
        cout << ans[i] << ' ';
        tot++;
    }
    while (tot < n+1) {
        cout << "0 ";
        tot++;
    }
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2113
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
using cd = complex<double>;
const double PI = acos(-1);
 
void fft(vector<cd> & a, bool invert) {
    int n = a.size();
 
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;
 
        if (i < j)
            swap(a[i], a[j]);
    }
 
    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            cd w(1);
            for (int j = 0; j < len / 2; j++) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
 
    if (invert) {
        for (cd & x : a)
            x /= n;
    }
}
 
vector<ll> multiply(vector<int> const& a, vector<int> const& b) {
    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n < (int)(a.size() + b.size())) 
        n <<= 1;
    fa.resize(n);
    fb.resize(n);
 
    fft(fa, false);
    fft(fb, false);
    for (int i = 0; i < n; i++)
        fa[i] *= fb[i];
    fft(fa, true);
 
    vector<ll> result(n);
    for (int i = 0; i < n; i++)
        result[i] = round(fa[i].real());
    return result;
}
 
int main() { _
	int n, m;
	cin >> n >> m;
	vector<int> v(n+m), w(n+m);
	for (int i = m-1; i < n+m-1; i++) 
		cin >> v[i];
	for (int i = n+m-1; i > n-1; i--) 
		cin >> w[i];
	vector<ll> ans = multiply(v, w);
	for (int i = n+m-1; i < 2* (n+m-1); i++) cout << ans[i] << ' ';
	cout << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2112
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
using cd = complex<double>;
const double PI = acos(-1);
 
void fft(vector<cd> & a, bool invert) {
    int n = a.size();
 
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;
 
        if (i < j)
            swap(a[i], a[j]);
    }
 
    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            cd w(1);
            for (int j = 0; j < len / 2; j++) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
 
    if (invert) {
        for (cd & x : a)
            x /= n;
    }
}
 
vector<ll> multiply(vector<int> const& a, vector<int> const& b) {
    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n < (int)(a.size() + b.size())) 
        n <<= 1;
    fa.resize(n);
    fb.resize(n);
 
    fft(fa, false);
    fft(fb, false);
    for (int i = 0; i < n; i++)
        fa[i] *= fb[i];
    fft(fa, true);
 
    vector<ll> result(n);
    for (int i = 0; i < n; i++)
        result[i] = round(fa[i].real());
    return result;
}
 
int main() { _
	string s;
	cin >> s;
	int n = (int)s.size();
	vector<int> v(n), w(n);
	for (int i = 0; i < n; i++) {
		if (s[i] == '1') {
			v[i] = 1;
			w[n-i-1] = 1;
		}
	}
	vector<ll> ans = multiply(v, w);
	for (int i = n; i < 2*n-1; i++) cout << ans[i] << ' ';
	cout << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2111
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
using cd = complex<double>;
const double PI = acos(-1);
 
void fft(vector<cd> & a, bool invert) {
    int n = a.size();
 
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;
 
        if (i < j)
            swap(a[i], a[j]);
    }
 
    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            cd w(1);
            for (int j = 0; j < len / 2; j++) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
 
    if (invert) {
        for (cd & x : a)
            x /= n;
    }
}
 
vector<ll> multiply(vector<int> const& a, vector<int> const& b) {
    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n < (int)(a.size() + b.size())) 
        n <<= 1;
    fa.resize(n);
    fb.resize(n);
 
    fft(fa, false);
    fft(fb, false);
    for (int i = 0; i < n; i++)
        fa[i] *= fb[i];
    fft(fa, true);
 
    vector<ll> result(n);
    for (int i = 0; i < n; i++)
        result[i] = round(fa[i].real());
    return result;
}
 
int main() { _
	int k, n, m, aux;
	cin >> k >> n >> m;
	vector<int> ban(k), ap(k);
	for (int i = 0; i < n; i++) {
		cin >> aux;
		ban[aux-1]++;
	}
	for (int i = 0; i < m; i++) {
		cin >> aux;
		ap[aux-1]++;
	}
	vector<ll> ans = multiply(ban, ap);
	for (int i = 0; i < 2*k-1; i++) cout << ans[i] << ' ';
	cout << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2110
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
ll a[MAXN];
 
void upd(int pos, int val) {
    pos += 2;
    for (; pos < MAXN; pos += pos & -pos) a[pos] += val;
}
 
int qry(int pos) {
    pos += 2;
    ll ans = 0;
    for (; pos; pos -= pos & -pos) ans += a[pos];
    return ans;
}
 
void count_sort(vector<int> &p, vector<int> &c) {
    int n = p.size();   
    vector<int> cnt(n);
    for (auto x : c) cnt[x]++;
    vector<int> p_new(n), pos(n);
    pos[0] = 0;
    for (int i = 1; i < n; i++) {
        pos[i] = pos[i - 1] + cnt[i - 1];
    }
    for (auto x : p) {
        p_new[pos[c[x]]] = x;
        pos[c[x]]++;
    }
    p = p_new;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    s += '$';
    int n = s.size();
    vector<int> p(n), c(n);
    {
        vector<pair<char, int>> a(n);
        for (int i = 0; i < n; i++) a[i] = {s[i], i};
        sort(a.begin(), a.end());
        for (int i = 0; i < n; i++) p[i] = a[i].second;
        c[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            if (a[i - 1].first == a[i].first) c[p[i]] = c[p[i - 1]];
            else c[p[i]] = c[p[i - 1]] + 1;
        }
    }
    int k = 0;
    while ((1 << k) < n) {
        for (int i = 0; i < n; i++) p[i] = (p[i] - (1 << k) + n) % n;
        count_sort(p, c);
        vector<int> c_new(n);
        c_new[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            pii prev = {c[p[i - 1]], c[(p[i - 1] + (1 << k)) % n]};
            pii now = {c[p[i]], c[(p[i] + (1 << k)) % n]};
            if (prev == now) c_new[p[i]] = c_new[p[i - 1]];
            else c_new[p[i]] = c_new[p[i - 1]] + 1;
        }
        c = c_new;
        k++;
    }
    vector<int> lcp(n);
    k = 0;
    for (int i = 0; i < n - 1; i++) {
        int pi = c[i];
        int j = p[pi - 1];
        while (s[i + k] == s[j + k]) k++;
        lcp[pi] = k;
        k = max(k - 1, 0);
    }
    for (int i = 1; i < n; i++) {
        upd(lcp[i] + 1, 1);
        upd(n - p[i], -1);
    }
    for (int i = 1; i < n; i++) {
        cout << qry(i) << ' ';
    }
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2109
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2108
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAX = 4e3 + 5;
const ll INF = 2e18;
 
void count_sort(vector<int> &p, vector<int> &c) {
    int n = p.size();   
    vector<int> cnt(n);
    for (auto x : c) cnt[x]++;
    vector<int> p_new(n), pos(n);
    pos[0] = 0;
    for (int i = 1; i < n; i++) {
        pos[i] = pos[i - 1] + cnt[i - 1];
    }
    for (auto x : p) {
        p_new[pos[c[x]]] = x;
        pos[c[x]]++;
    }
    p = p_new;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    s += '$';
    int n = s.size();
    vector<int> p(n), c(n);
    {
        vector<pair<char, int>> a(n);
        for (int i = 0; i < n; i++) a[i] = {s[i], i};
        sort(a.begin(), a.end());
        for (int i = 0; i < n; i++) p[i] = a[i].second;
        c[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            if (a[i - 1].first == a[i].first) c[p[i]] = c[p[i - 1]];
            else c[p[i]] = c[p[i - 1]] + 1;
        }
    }
    int k = 0;
    while ((1 << k) < n) {
        for (int i = 0; i < n; i++) p[i] = (p[i] - (1 << k) + n) % n;
        count_sort(p, c);
        vector<int> c_new(n);
        c_new[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            pii prev = {c[p[i - 1]], c[(p[i - 1] + (1 << k)) % n]};
            pii now = {c[p[i]], c[(p[i] + (1 << k)) % n]};
            if (prev == now) c_new[p[i]] = c_new[p[i - 1]];
            else c_new[p[i]] = c_new[p[i - 1]] + 1;
        }
        c = c_new;
        k++;
    }
    vector<int> lcp(n);
    k = 0;
    for (int i = 0; i < n - 1; i++) {
        int pi = c[i];
        int j = p[pi - 1];
        while (s[i + k] == s[j + k]) k++;
        lcp[pi] = k;
        k = max(k - 1, 0);
    }
    ll find;
    cin >> find;
    ll tot = 0;
    for (int i = 1; i < n; i++) {
        if (tot + n - p[i] - 1 - (!i ? 0 : lcp[i]) >= find) {
            // just print
            cout << s.substr(p[i], find - tot + lcp[i]) << '\n';
            break;
        }
        tot += n - p[i] - 1 - (!i ? 0 : lcp[i]);
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2107
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
vector<int> pi(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i-1];
        while (j > 0 && s[i] != s[j])
            j = pi[j-1];
        if (s[i] == s[j])
            j++;
        pi[i] = j;
    }
    return pi;
}
 
vector<int> z(string s) {
    int n = (int) s.length();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r)
            z[i] = min (r - i + 1, z[i - l]);
        while (i + z[i] < n && s[z[i]] == s[i + z[i]])
            ++z[i];
        if (i + z[i] - 1 > r)
            l = i, r = i + z[i] - 1;
    }
    return z;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    vector<int> vpi = pi(s), vz = z(s);
    for (int x : vz) cout << x << ' ';
    cout << '\n';
    for (int x : vpi) cout << x << ' ';
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2174
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
// Quantidade de 9s, Maior digito do prefixo, Ultimo digito
ll dp[20][10][10];
int to[20][10][10];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
 
	// precalc
	for (int j = 0; j < 10; j++) {
		for (int k = 0; k < 10; k++) {
			if (j > k) {
				dp[0][j][k] = 1;
				to[0][j][k] = 10 + k - j; 
			}
			else {
				dp[0][j][k] = 2;
				to[0][j][k] = 10 - j;
			}
		}
	}
    for (int i = 1; i <= 17; i++) {
		for (int j = 0; j < 10; j++) {
			for (int k = 0; k < 10; k++) {
				int lst = k;
				for (int l = 9; l >= 0; l--) {
					dp[i][j][k] += dp[i - 1][max(j, l)][lst];
					lst = to[i - 1][max(j, l)][lst];
				}
				to[i][j][k] = lst;
			}
		}
	}
	
	ll n, ans = 0;
	cin >> n;
	int lst = n % 10, cnt = 0;
	n /= 10;
	while (n % 10 == 9) {
		cnt++;
		n /= 10;
	}
	while (n > 0 || lst > 0 || cnt > 0) {
		int dig = 0;
		ll pre = n;
		while (pre > 0) {
			dig = max(dig, (int)(pre % 10));
			pre /= 10;
		}
		ans += dp[cnt][dig][lst];
		lst = to[cnt][dig][lst];
		if (n == 0) break;
		n--;
		while (n % 10 == 9) {
			cnt++;
			n /= 10;
		}
	}
	cout << ans - 1 << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2184
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
using namespace std; 
 
#define ll long long
#define FOR(i, x, y) for (int i = x; i < y; i++)
#define arr array<int, 30>
 
const int mx = 2e5 + 5;
 
int n, q, A[mx]; ll sm[mx][30]; arr seg[mx * 2];
 
arr comb(arr &A, arr &B){
	arr ret;
    FOR(i, 0, 30) ret[i] = min(A[i], B[i]);
    return ret;
}
arr qry(int l, int r){
    arr ret; fill(ret.begin(), ret.end(), 2e9);
    for (l += mx, r += mx; l <= r; r /= 2, l /= 2){
        if (l % 2 == 1) ret = comb(ret, seg[l++]);
        if (r % 2 == 0) ret = comb(seg[r--], ret);
    }
    return ret;
}
 
int main(){
	ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> q; memset(seg, 0x3f, sizeof(seg));
    FOR(i, 1, n + 1){
        int x; cin >> x;
        int g = log2(x);
        seg[i + mx][g] = x; sm[i][g] = x;
    }
    FOR(i, 1, n + 1) FOR(j, 0, 30) sm[i][j] += sm[i - 1][j];
    
    for (int i = mx - 1; i; i--) seg[i] = comb(seg[i * 2], seg[i * 2 + 1]);
    
    while (q--){
        int l, r; cin >> l >> r;
 
        arr bst = qry(l, r); ll tot = 0, ans = -1;
        FOR(i, 0, 30){
            if (tot + 1 < (1 << (i + 1)) and bst[i] > tot + 1){ 
                ans = tot + 1;
                break;
            }
            tot += sm[r][i] - sm[l - 1][i];
        }
        cout<<(ans == -1 ? tot + 1 : ans)<<"\n";
    }
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2183
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n;
	cin >> n;
	vector<ll> v(n);
	for (int i = 0; i < n; i++) {
		cin >> v[i];
	}
	sort(v.begin(), v.end());
	ll resp = 0;
	for (int i = 0; i < n; i++) {
		if (v[i] - resp > 1) break;
		else resp += v[i];
	}
	cout << resp+1 << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2182
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, ll e) {
    ll resp = 1;
    while (e) {
        if (e&1) resp = (resp * b) % M;
        e >>= 1;
        b = (b * b) % M;
    }
    return resp;
}
 
int main () { _
    int n, x, k, pos;
	cin >> n;
	vector<ll> ans(3, 1);
	vector<pii> v;
	bool odd = true;
	ll exp = 1;
	for (int i = 0; i < n; i++) {
		cin >> x >> k;
		v.pb({x, k});
		if (odd && k&1) {
			odd = false;
			pos = i;
		}
		ans[0] = (ans[0] * (k+1)) % M;
		ll prox = ((ll)(fexp(x, k+1) - 1) * fexp(x-1, M-2)) % M;
        ans[1] = (ans[1] * prox) % M;
	}
	for (int i = 0; i < n; i++) {
		if (!odd && pos == i) {
			exp = (exp * (v[i].S+1)/2) % (M-1);
		}
		else exp = (exp * (v[i].S+1)) %  (M-1);
	}
	for (int i = 0; i < n; i++) {
		if (odd) {
			ans[2] = (ans[2] * fexp(v[i].F, (v[i].S/2) * exp)) % M;
		}
		else {
			ans[2] = (ans[2] * fexp(v[i].F, exp * v[i].S)) % M;
		}
	}
	for (int x : ans) cout << x << ' ';
	cout << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2181
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, m;
    cin >> n >> m;
    vector<vector<int>> v((1<<n)+2);
    vector<vector<int>> dp(1010, vector<int> (1<<(n+1)));
    for (int i = 0; i < (1<<n); i++) {
        for (int j = 0; j < (1<<n); j++) {
            int count = 0;
            bool valid = true;
            for (int k = 0; k < n; k++) {
                if ((i & (1<<k))) {
                    if ((j & (1<<k))) valid = false;
                    valid &= !(count&1);
                    count = 0;
                }
                else if (j & (1<<k)) {
                    valid &= !(count&1);
                    count = 0;
                }
                else count++;
            }
            valid &= !(count&1);
            if (valid) v[i].pb(j);
        }
    }
    for (int i = 0; i < (int)v[0].size(); i++) {
        dp[1][v[0][i]] = 1;
    }
    for (int i = 2; i <= m; i++) {
        for (int j = 0; j < (1<<n); j++) {
            for (int k = 0; k < (int)v[j].size(); k++) {
                int l = v[j][k];
                dp[i][j] += dp[i-1][l];
                if (dp[i][j] >= M) dp[i][j] -= M;
            }
        }
    }
    cout << dp[m][0] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2180
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
int v1[MAXN], v2[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) 
        cin >> v1[i], v1[i]--;
    for (int i = 0; i < n; i++) 
        cin >> v2[i], v2[i]--;
    int cima = 0, baixo = 0;
    ll ans = 0;
    for (int i = 0; i < n; i++) {
        ans += abs(cima) + abs(baixo);
        cima += v1[i];
        baixo += v2[i];
        while (cima > 0 && baixo < 0) 
            cima--, baixo++, ans++;
        while (cima < 0 && baixo > 0)
            cima++, baixo--, ans++;
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2179
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
vector<int> v[MAXN];
int vis[MAXN], cnt = 0, deg[MAXN], dep[MAXN];
 
void dfs(int node, int pai) {
	dep[node] = dep[pai]+1;
	vis[node] = 1;
	for (int x : v[node]) {
		cnt++;
		if (x == pai) continue;
		if (!vis[x]) 
			dfs(x, node);
	}
}
 
void dfs2(int node, int pai) {
	vis[node] = 1;
	for (int x : v[node]) {
		if (x == pai) continue;
		if (!vis[x]) {
			dfs2(x, node);
			if (deg[x]) 
				cout << x << ' ' << node << '\n';
			else {
				cout << node << ' ' << x << '\n';
				deg[node] ^= 1;
			}
		}
		else if (dep[node] > dep[x]) {
			cout << node << ' ' << x << '\n';
			deg[node] ^= 1;
		}
	}
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	bool valid = true;
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			cnt = 0;
			dfs(i, 0);
			cnt /= 2;
			valid &= (cnt % 2 == 0);
		}
	}
	if (!valid) cout << "IMPOSSIBLE\n";
	else {
		memset(vis, 0, sizeof(vis));
		for (int i = 1; i <= n; i++) {
			if (!vis[i]) {
				dfs2(i, 0);
			}
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2177
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
vector<int> v[MAXN];
vector<pii> edges;
int low[MAXN], cnt = 0, vis[MAXN], dep[MAXN];
 
void dfs(int node, int pai) {
	vis[node] = ++cnt;
	low[node] = cnt;
	dep[node] = dep[pai] + 1;
	for (int x : v[node]) {
		if (x == pai) continue;
		if (!vis[x]) {
			dfs(x, node);
			low[node] = min(low[node], low[x]);
		}
		else low[node] = min(low[node], vis[x]);
	}
	if (low[node] == vis[node] && pai > 0) edges.emplace_back(node, pai);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
		edges.emplace_back(a, b);
	}
	int compo = 0;
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			dfs(i, 0);
			compo++;
		}
	}
	if ((int)edges.size() > m || compo > 1) cout << "IMPOSSIBLE\n";
	else {
		for (auto x : edges) {
			if (dep[x.second] > dep[x.first]) swap(x.first, x.second);
			if (dep[x.first] - dep[x.second] == 1) 
				cout << x.second << ' ' << x.first << '\n';
			else 
				cout << x.first << ' ' << x.second << '\n';
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2176
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e6 + 5;
const ll INF = 1e18;
 
int dp[1005][250010], n, k;
 
int count(int diag) {
    if (diag&1) return diag / 4 * 2 + 1;
    return (diag-1) / 4 * 2 + 2;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> k;
    if (k > 2*n-1) cout << "0\n";
    else {
        dp[0][0] = dp[1][0] = 1;
        dp[1][1] = 1;
        for (int i = 0; i < 2*n-2; i++) {
            for (int j = 0; j <= k; j++) {
                if (dp[i][j]) {
                    dp[i+2][j] += dp[i][j];
                    if (dp[i+2][j] >= MOD) dp[i+2][j] -= MOD;
                    if (count(i+2) - j > 0) {
                        dp[i+2][j+1] += (1ll * dp[i][j] * (count(i+2) - j)) % MOD;
                        if (dp[i+2][j+1] >= MOD) dp[i+2][j+1] -= MOD;
                    }
                }
            }
        }
        int ans = 0;
        for (int i = 0; i <= k; i++) {
            ans += (1ll * dp[2*n-1][i] * dp[2*n-2][k-i]) % MOD;
            if (ans >= MOD) ans -= MOD;
        }
        cout << ans << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1696
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int n;
int vis[505];
vector<vector<int>> residualGraph;
 
bool bfs(vector<vector<int>>& residualGraph, vector<int>& level, int source, int sink) {
    fill(level.begin(), level.end(), -1);
	level[source] = 0;
	
	queue<int> q;
	q.push(source);
 
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		for (int v=0; v < n; v++)
		{
			if (u != v && residualGraph[u][v] > 0 && level[v] < 0)
			{
 
				level[v] = level[u] + 1;
				q.push(v);
			}
		}
	}
	return level[sink] < 0 ? false : true ;
}
 
int sendFlow(vector<vector<int>>& residualGraph, vector<int>& level, vector<int>& count, int u, int sink, int flow) {
	if (u == sink)
		return flow;
 
    if (count[u] == (int)residualGraph[u].size())
	    return 0;
 
	for (int v=0; v < n; v++)
	{
		if (residualGraph[u][v] > 0)
		{
		    count[u]++;
			if (level[v] == level[u]+1)
			{
			 	int curr_flow = min(flow, residualGraph[u][v]);
 
			    int min_cap = sendFlow(residualGraph, level, count, v, sink, curr_flow);
			    if (min_cap > 0)
			    {
                    residualGraph[u][v] -= min_cap;
                    residualGraph[v][u] += min_cap;
				    return min_cap;
			    }
			}
		}
	}
	return 0;
}
 
int dinic_algorithm(vector<vector<int>>& graph, int source, int sink) {
	if (source == sink)
		return -1;
 
	int max_flow = 0;
    residualGraph = graph;
    vector<int> level(n, -1);
 
	while (bfs(residualGraph, level, source, sink) == true)
	{
		vector<int> count(n, 0);
 
		while (int flow = sendFlow(residualGraph, level, count, source, sink, INT_MAX))
			max_flow += flow;
	}
	return max_flow;
}
 
void addEdge(vector<vector<int>>& graph, int u, int v, int w) {
    graph[u][v] = w;
}
 
int main() { _
	int x, y, m;
	cin >> x >> y >> m;
	n = x+y+2;
    vector<vector<int>> graph(n, vector<int> (n, 0));
	vector<pii> edg;
	for (int i = 1; i <= x; i++) addEdge(graph, 0, i, 1);
	for (int i = x+1; i <= x+y; i++) addEdge(graph, i, n-1, 1);
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		addEdge(graph, a, b+x, 1);
		edg.pb({a, b+x});
	}
	cout << dinic_algorithm(graph, 0, n-1) << '\n';
	for (pii a : edg)
		if (!residualGraph[a.F][a.S]) cout << a.F << ' ' << a.S-x << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2169
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 400100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int a[MAXN];
 
void upd(int pos) {
    for (int i = pos; i < MAXN; i+=(i & -i)) {
        a[i]++;
    }
}
 
int sum(int pos) {
    int resp = 0;
    for (int i = pos; i > 0; i-=(i & -i)) {
        resp += a[i];
    }
    return resp;
}
 
int main () { _
    int n;
    cin >> n;
    vector<pair<pii, int>> v(n);
    set<int> comp;
    for (int i = 0; i < n; i++) {
        cin >> v[i].F.F >> v[i].F.S;
        v[i].S = i;
        comp.insert(v[i].F.F), comp.insert(v[i].F.S);
    }   
    map<int,int> mp;
    int atual = 1;
    for (int x : comp) {
        mp[x] = atual++;
    }
    for (int i = 0; i < n; i++) {
        v[i].F.F = mp[v[i].F.F];
        v[i].F.S = mp[v[i].F.S];
    }
    sort(begin(v), end(v), [&](pair<pii, int> a, pair<pii, int> b) {
        if (a.F.F == b.F.F) return a.F.S > b.F.S;
        return a.F.F < b.F.F;
    });
    vector<pii> contem(n), contido(n);
    for (int i = n-1; i >= 0; i--) {
        contem[i].S = sum(v[i].F.S);
        contem[i].F = v[i].S;
        upd(v[i].F.S);
    }
    memset(a, 0, sizeof(a));
    for (int i = 0; i < n; i++) {
        contido[i].S = sum(MAXN-1) - sum(v[i].F.S - 1);
        contido[i].F = v[i].S;
        upd(v[i].F.S);
    }
    sort(begin(contem), end(contem));
    sort(begin(contido), end(contido));
    for (pii x : contem) cout << x.S << ' ';
    cout << '\n';
    for (pii x : contido) cout << x.S << ' ';
    cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2168
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
    int n;
    cin >> n;
    vector<pair<pii, int>> v(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i].F.F >> v[i].F.S;
        v[i].S = i;
    }
    sort(begin(v), end(v), [&](pair<pii, int> a, pair<pii, int> b) {
        if (a.F.F == b.F.F) return a.F.S > b.F.S;
        return a.F.F < b.F.F;
    });
    int mini = 1e9+1;
    vector<pii> contem(n), contido(n);
    for (int i = n-1; i >= 0; i--) {
        contem[i].S = (v[i].F.S >= mini);
        contem[i].F = v[i].S;
        mini = min(mini, v[i].F.S);
    }
    int maxi = -1;
    for (int i = 0; i < n; i++) {
        contido[i].S = (v[i].F.S <= maxi);
        contido[i].F = v[i].S;
        maxi = max(maxi, v[i].F.S);
    }
    sort(begin(contem), end(contem));
    sort(begin(contido), end(contido));
    for (pii x : contem) cout << x.S << ' ';
    cout << '\n';
    for (pii x : contido) cout << x.S << ' ';
    cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2166
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
ll a[4*MAXN], lz[4*MAXN], v[MAXN], w[MAXN];
 
void build(int node, int i, int j) {
	if (i == j) a[node] = w[i];
	else {
		int m = (i+j)/2;
		build(2*node, i, m), build(2*node+1, m+1, j);
		a[node] = max(a[2*node], a[2*node+1]);
	}
}
 
void push(int node, int i, int j) {
	a[node] += lz[node];
	if (i != j) {
		lz[2*node] += lz[node];
		lz[2*node+1] += lz[node];
	}
	lz[node] = 0;
}
 
void upd(int node, int i, int j, int ini, int fim, int val) {
	push(node, i, j);
	if (j < ini || i > fim) return;
	if (ini <= i && j <= fim) {
		lz[node] += val;
		push(node, i, j);
	}
	else {
		int m = (i+j)/2;
		upd(2*node, i, m, ini, fim, val);
		upd(2*node+1, m+1, j, ini, fim, val);
		a[node] = max(a[2*node], a[2*node+1]);
	}
}
 
ll query(int node, int i, int j, int ini, int fim) {
	push(node, i, j);
	if (j < ini || i > fim) return -INF;
	if (ini <= i && j <= fim) return a[node];
	else {
		int m = (i+j)/2;
		return max(query(2*node, i, m, ini, fim), query(2*node+1, m+1, j, ini, fim));
	}
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		w[i] = v[i] + w[i-1];
	}
	build(1, 0, n);
	int tipo, a, b;
	for (int i = 0; i < q; i++) {
		cin >> tipo >> a >> b;
		if (tipo == 1) {
			upd(1, 0, n, a, n, b - v[a]);
			v[a] = b;
		}
		if (tipo == 2) 
			cout << max(query(1, 0, n, a, b) - query(1, 0, n, a-1, a-1), 0ll) << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2165
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
 
using namespace std;
typedef long long int lli;
 
void hanoi (int discos, int ini, int fim) {
    if (discos == 1) {
        cout << ini << " " << fim << endl;
    }
    else {
        int outro = 6-ini-fim;
        hanoi (discos-1, ini, outro);
        cout << ini << " " << fim << endl;
        hanoi (discos-1, outro, fim);
    }
}
 
int main() { _
    int n;
    cin >> n;
    cout << (int)(pow(2, n)-1) << endl;
    hanoi (n, 1, 3);
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2164
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int jose(int n, int pos, bool impar) {
	if (n == 0) return 1;
	if (impar) {
		if (n&1) {
			if (pos <= n/2 + 1) return 2 * pos - 1;
			return 2 * jose(n/2, pos - n/2 - 1, false);
		}
		else {
			if (pos <= n/2) return 2 * pos - 1;
			return 2 * jose(n/2, pos - n/2, true);
		}
	}
	else {
		if (pos <= n/2) return 2 * pos;
		if (n&1) {
			return 2 * jose(n/2+1, pos - n/2, true) - 1;
		}
		else {
			return 2 * jose(n/2, pos - n/2, false) - 1;
		}
	}
}
 
int main () { _
	int q, n, k;
	cin >> q;
	for (int i = 0; i < q; i++) {
		cin >> n >> k;
		cout << jose(n, k, false) << '\n';
	}
    return 0;   
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2163
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef tree<int,null_type,less<int>,rb_tree_tag,
tree_order_statistics_node_update> ordered_set;
const int M = 1e9+7;
 
int main () { _
    int n, k;
    cin >> n >> k;
    ordered_set s;
    for (int i = 1; i <= n; i++) {
        s.insert(i);
    }
    int tam = n, pos = k % tam;
    for (int i = 0; i < n; i++) {
        auto x = s.find_by_order(pos);
        cout << *x << ' ';
        s.erase(*x);
        tam--;
        if (tam) pos = (pos + k) % tam;
    }
    cout << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2162
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 300100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
set<int> s;
 
int main() { _
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) s.insert(i);
    auto it = s.begin();
    it++;
    int count = 0;
    while (count < n) {
        cout << *it << ' ';
        auto it2 = it;
        it++;
        if (it == s.end()) it = s.begin();
        s.erase(*it2);
        it++;
        if (it == s.end()) it = s.begin();
        count++;
    }
    cout << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/2143
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 50005
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
bitset<MAXN> bit[MAXN];
vector<int> v[MAXN], w[MAXN], nv[MAXN], ord;
int vis[MAXN], comp[MAXN], cnt = 0;
 
void dfs1(int node) {
	vis[node] = 1;
	for (int x : v[node])
		if (!vis[x]) dfs1(x);
	ord.pb(node);
}
 
void dfs2(int node) {
	vis[node] = 1;
	comp[node] = cnt;
	for (int x : w[node])
		if (!vis[x]) dfs2(x);
}
 
void dfs3(int node) {
	vis[node] = 1;
	for (int x : nv[node]) {
		if (!vis[x]) dfs3(x);
		bit[node] |= bit[x];
	}
}
 
int main () { _
	int n, m, q, a, b;
	cin >> n >> m >> q;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].pb(b);
		w[b].pb(a);
	}
	for (int i = 1; i <= n; i++) {
		bit[i][i] = 1;
		if (!vis[i]) dfs1(i);
	}
	memset(vis, 0, sizeof(vis));
	reverse(ord.begin(), ord.end());
	for (int x : ord) {
		if (!vis[x]) {
			cnt++;
			dfs2(x);
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int x : v[i]) if (comp[i] != comp[x]) nv[comp[i]].pb(comp[x]);
	}
	memset(vis, 0, sizeof(vis));
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) dfs3(i);
	}
	for (int i = 0; i < q; i++) {
		cin >> a >> b;
		if (bit[comp[a]][comp[b]]) cout << "YES\n";
		else cout << "NO\n";
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1141
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n;
	cin >> n;
	vector<int> v(n);
	map<int, int> mapa;
	for (int i = 0; i < n; i++) {
		cin >> v[i];
	}
	int r = 0, resp = 0;
	mapa[v[0]]++;
	for (int l = 0; l < n; l++) {
		while (r < n && mapa[v[r]] <= 1) {
			resp = max(resp, r - l + 1);
			r++;
			mapa[v[r]]++;
		}
		mapa[v[l]]--;
	}
	cout << resp << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1157
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
int main() {
    int x, y;
    scanf("%d %d", &x, &y);
    printf("%d", (x-1) ^ (y-1));
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1149
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 5e5 + 5;
const ll INF = 1e18;
 
int dp[MAXN], last[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    int n = s.size();
    vector<int> v(26, -1);
    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
        last[i] = (v[s[i-1]-'a'] < 0 ? -1 : v[s[i-1]-'a']);
        v[s[i-1] - 'a'] = i-1;
        dp[i] = dp[i-1] - (last[i] >= 0 ? dp[last[i]] : 0);
        if (dp[i] < 0) dp[i] += MOD;
        if (dp[i] >= MOD) dp[i] -= MOD;
        dp[i] += dp[i-1];
        if (dp[i] >= MOD) dp[i] -= MOD;
    }
    cout << (dp[n]-1+MOD) % MOD << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1147
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
char mat[1010][1010];
int maxi[1010][1010];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	memset(maxi, -1, sizeof(maxi));
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> mat[i][j];
			maxi[i][j] = (mat[i][j] == '.');
			if (maxi[i][j] && i > 1) maxi[i][j] += maxi[i-1][j];
		}
	}
	//for (int i = n; i > 1; i--) {
	//	for (int j = 1; j <= m; j++) {
	//		if (maxi[i-1][j]) maxi[i-1][j] = max(maxi[i][j], maxi[i-1][j]);
	//	}
	//}
	ll ans = 0;
	vector<int> besq(m+1), bdir(m+1);
	for (int i = 1; i <= m; i++) {
		besq[i] = i-1;
		bdir[i] = i+1;
	}
	for (int i = 1; i <= n; i++) {
		vector<int> esq, dir;
		esq = besq, dir = bdir;
		for (int j = 1; j <= m; j++) {
			while (maxi[i][esq[j]] >= maxi[i][j]) {
				esq[j] = esq[esq[j]];
			}
		}
		for (int j = m; j >= 1; j--) {
			while (maxi[i][dir[j]] >= maxi[i][j]) {
				dir[j] = dir[dir[j]];
			}
		}
		for (int j = 1; j <= m; j++) {
			ans = max(ans, 1ll * (dir[j] - esq[j] - 1) * maxi[i][j]);
		}
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1146
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	ll n;
	cin >> n;
	ll ans = 0, aux, add, two;
	n++;
	for (int i = 0; i <= 50; i++) {
		two = (1ll<<i);
		aux = n - two;
		if (aux < 0) break;
		add = aux / two;
		if (add&1) add = ((add+1) / 2) * two;
		else add = add * two / 2 + aux % two;
		ans += add;
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1145
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n;
    cin >> n;
    vector<int> v(n), pilha;
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        auto it = lower_bound(pilha.begin(), pilha.end(), v[i]);
        if (it == pilha.end()) {
            pilha.pb(v[i]);
        }
        else *it = v[i];
    }
    cout << (int)pilha.size() << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1144
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 400100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
vector<int> mapa;
vector<pair<char, pii>> que;
ll a[MAXN], v[MAXN];
 
void upd(int pos, int val) {
	int id = upper_bound(mapa.begin(), mapa.end(), pos) - mapa.begin();
	for (int i = id; i < MAXN; i += (i & -i)) {
		a[i] += val;
	}
}
 
ll sum(int pos) {
	int id = upper_bound(mapa.begin(), mapa.end(), pos) - mapa.begin();
	ll resp = 0;
	for (int i = id; i > 0; i -= (i & -i)) {
		resp += a[i];
	}
	return resp;
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 0; i < n; i++) {
		cin >> v[i];
		mapa.pb(v[i]);
	}
	char c;
	int x, y;
	for (int i = 0; i < q; i++) {
		cin >> c >> x >> y;
		que.pb({c, {x, y}});
		if (c == '!') mapa.pb(y);
	}
	sort(mapa.begin(), mapa.end());
	mapa.erase(unique(mapa.begin(), mapa.end()), mapa.end());
	for (int i = 0; i < n; i++) {
		upd(v[i], 1);
	}
	for (int i = 0; i < q; i++) {
		que[i].S.F--;
		if (que[i].F == '?') {
			cout << sum(que[i].S.S) - sum(que[i].S.F) << '\n';
		}
		else {
			upd(v[que[i].S.F], -1);
			v[que[i].S.F] = que[i].S.S;
			upd(v[que[i].S.F], 1);
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1143
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int a[4*MAXN], v[MAXN];
 
void build(int node, int ini, int fim) {
	if (ini == fim) {
		a[node] = v[ini];
	}
	else {
		int m = (ini+fim) >> 1;
		build(2*node, ini, m);
		build(2*node+1, m+1, fim);
		a[node] = max(a[2*node], a[2*node+1]);
	}
}
 
int ans(int n, int i, int j, int v) {
	if (i == j && a[n] >= v) {
		int resp = i;
		a[n] -= v;
		return resp;
	}
	else if (i == j) return 0;
	else {
		int m = (i+j) >> 1;
		if (a[2*n] >= v) {
			int resp = ans(2*n, i, m, v);
			a[n] = max(a[2*n], a[2*n+1]);
			return resp;
		}
		else if (a[2*n+1] >= v) {
			int resp = ans(2*n+1, m+1, j, v);
			a[n] = max(a[2*n], a[2*n+1]);
			return resp;
		}
		else {
			return 0;
		}
	}
}
 
int main () { _
	int n, m, aux;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	build(1, 1, n);
	for (int i = 0; i < m; i++) {
		cin >> aux;
		cout << ans(1, 1, n, aux) << ' ';
	}
	cout << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1142
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int v[MAXN];
 
int main () { _
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> v[i];
	v[n+1] = 0;
	vector<pii> sk;
	sk.pb({v[1], 1});
	ll ans = 0;
	for (int i = 2; i <= n+1; i++) {
		while (!sk.empty() && sk.back().F >= v[i]) {
			ans = max(ans, 1ll * (i-1 - ((int)sk.size() == 1 ? 0 : sk[(int)sk.size()-2].S)) * sk.back().F);
			sk.pop_back();
		}
		sk.pb({v[i], i});
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1158
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, x;
    cin >> n >> x;
    vector<int> h(n), v(n);
    for (int i = 0; i < n; i++) cin >> h[i];
    for (int i = 0; i < n; i++) cin >> v[i];
    vector<vector<int>> dp(n+1, vector<int> (x+1, -1));
    dp[0][x] = 0;
    for (int i = 0; i < n; i++) {
        for (int j = x; j >= 0; j--) {
            if (dp[i][j] >= 0) {
                dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
                if (j >= h[i]) dp[i+1][j-h[i]] = max(dp[i+1][j-h[i]], dp[i][j] + v[i]);
            }
        }
    }
    int ans = 0;
    for (int i = x; i >= 0; i--) ans = max(ans, dp[n][i]);
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1140
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n;
    cin >> n;
    vector<pair<pii, int>> v(n);
    vector<int> c;
    for (int i = 0; i < n; i++) {
        cin >> v[i].F.F >> v[i].F.S >> v[i].S;
        c.pb(v[i].F.F), c.pb(v[i].F.S);
    }
    sort(c.begin(), c.end());
    map<int, int> mapa;
    int atual = 0;
    mapa[c[0]] = atual++;
    for (int i = 1; i < (int)c.size(); i++) {
        if (c[i] != c[i-1]) mapa[c[i]] = atual++;
    }
    for (int i = 0; i < n; i++) {
        v[i].F.F = mapa[v[i].F.F];
        v[i].F.S = mapa[v[i].F.S];
    }
    sort(v.begin(), v.end());
    vector<ll> dp(1e6);
    atual = n-1;
    for (int i = 5e5; i >= 0; i--) {
        dp[i] = max(dp[i], dp[i+1]);
        while (atual >= 0 && i == v[atual].F.F) {
            dp[i] = max(dp[i], v[atual].S + dp[v[atual].F.S + 1]);
            atual--;
        }
    }
    cout << dp[0] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1139
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN];
int c[MAXN], ans[MAXN];
set<int> s[MAXN];
 
void dfs(int node, int pai) {
    s[node].insert(c[node]);
    for (int x : v[node]) {
        if (x != pai) {
            dfs(x, node);
            if ((int)s[x].size() > (int)s[node].size()) swap(s[x], s[node]);
            for (int y : s[x]) s[node].insert(y);
        }
    }
    ans[node] = (int)s[node].size();
}
 
int main () { _
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> c[i];
    for (int i = 0; i < n-1; i++) {
        int a, b;
        cin >> a >> b;
        v[a].pb(b);
        v[b].pb(a);
    }
    dfs(1, 0);
    for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
    cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1138
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN], a(1);
int sz[MAXN], pos[MAXN];
ll ini[MAXN], val[MAXN];
vector<ll> dif(MAXN);
 
void dfs(int node, int pai) {
    sz[node] = 1;
    ini[node] = ini[pai] + val[node];
    a.pb(node);
    pos[node] = (int)a.size()-1;
    for (int x : v[node]) {
        if (x != pai) {
            dfs(x, node);
            sz[node] += sz[x];
        }
    }
}
 
ll sum(int pos) {
    ll resp = 0;
    for (int i = pos; i > 0; i -= (i & -i)) {
        resp += dif[i];
    }
    return resp;
}
 
void upd(int pos, ll value) {
    for (int i = pos; i < MAXN; i += (i & -i)) {
        dif[i] += value;
    }
}
 
int main () { _
    int n, m, x, y, z;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> val[i];
    for (int i = 0; i < n-1; i++) {
        cin >> x >> y;
        v[x].pb(y);
        v[y].pb(x);
    }
    dfs(1, 0);
    for (int i = 0; i < m; i++) {
        cin >> x;
        if (x == 1) {
            cin >> y >> z;
            upd(pos[y], z - val[y]);
            upd(pos[y] + sz[y], val[y] - z);
            val[y] = z;
        }
        if (x == 2) {
            cin >> y;
            cout << ini[y] + sum(pos[y]) << '\n';
        }
    }
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1137
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN], a(1, 0);
int val[MAXN], sz[MAXN], pos[MAXN];
ll t[MAXN];
 
ll sum(int pos) {
	ll resp = 0;
	for (int i = pos; i > 0; i -= (i & -i)) {
		resp += t[i];
	}
	return resp;
}
 
void upd(int pos, int val) {
	for (int i = pos; i < MAXN; i += (i & -i)) {
		t[i] += val;
	}
}
 
void dfs(int node, int pai) {
	sz[node] = 1;
	a.pb(node);
	pos[node] = (int)a.size()-1;
	upd(pos[node], val[node]);
	for (int x : v[node]) {
		if (x != pai) {
			dfs(x, node);
			sz[node] += sz[x];
		}
	}
}
 
int main () { _
	int n, q, x, y, z;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> val[i];
	}
	for (int i = 0; i < n-1; i++) {
		cin >> x >> y;
		v[x].pb(y);
		v[y].pb(x);
	}
	dfs(1, 0);
	for (int i = 0; i < q; i++) {
		cin >> x;
		if (x == 1) {
			cin >> y >> z;
			upd(pos[y], z - val[y]);
			val[y] = z;
		}
		else {
			cin >> y;
			cout << sum(pos[y] + sz[y] - 1) - sum(pos[y]-1) << '\n';
		}
	}
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1136
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN], a;
int tab[MAXN][25], nivel[MAXN], ans[MAXN];
 
void dfs(int node, int pai) {
    a.pb(node);
    tab[node][0] = pai;
    nivel[node] = 1 + nivel[pai];
    for (int i = 1; i <= 20; i++) {
        tab[node][i] = tab[tab[node][i-1]][i-1];
    }
    for (int x : v[node])
        if (x != pai)   
            dfs(x, node);
}
 
void dfs2(int node, int pai) {
    for (int x : v[node]) {
        if (x != pai) {
            dfs2(x, node);
            ans[node] += ans[x];
        }
    }
}
 
int lca(int a, int b) {
    if (nivel[a] < nivel[b]) swap(a, b);
 
    for (int i = 20; i >= 0; i--) {
        if (nivel[a] - nivel[b] >= (1<<i)) {
            a = tab[a][i];
        }
    }
 
    if (a == b) return a;
 
    for (int i = 20; i >= 0; i--) {
        if (tab[a][i] != tab[b][i]) {
            a = tab[a][i];
            b = tab[b][i];
        }
    }
    return tab[a][0];
}
 
int main () { _
    int n, m, a, b;
    cin >> n >> m;
    for (int i = 0; i < n-1; i++) {
        cin >> a >> b;
        v[a].pb(b);
        v[b].pb(a);
    }
    dfs(1, 0);
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        ans[a]++;
        ans[b]++;
        int pater = lca(a, b);
        ans[pater]--;
        ans[tab[pater][0]]--;
    }
    dfs2(1, 0);
    for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
    cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1135
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int tab[MAXN][25], nivel[MAXN];
vector<int> v[MAXN];
 
int lca(int a, int b) {
	if (nivel[a] < nivel[b]) swap(a, b);
	for (int i = 19; i >= 0; i--) {
		if (nivel[a] - nivel[b] >= (1<<i)) {
			a = tab[a][i];
		}
	}
	if (a == b) return a;
	for (int i = 19; i >= 0; i--) {
		if (tab[a][i] != tab[b][i]) {
			a = tab[a][i];
			b = tab[b][i];
		}
	}
	return tab[a][0];
}
 
void dfs(int node) {
	for (int i = 1; i < 20; i++) {
		tab[node][i] = tab[tab[node][i-1]][i-1];
	}
	for (int x : v[node]) {
		if (x != tab[node][0]) {
			nivel[x] = nivel[node]+1;
			tab[x][0] = node;
			dfs(x);
		}
	}
}
 
int main () { _
	int n, q, a, b;
	cin >> n >> q;
	for (int i = 0; i < n-1; i++) {
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	nivel[1] = 1;
	dfs(1);
	for (int i = 0; i < q; i++) {
		cin >> a >> b;
		cout << nivel[a] + nivel[b] - 2 * nivel[lca(a, b)] << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1134
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int c[MAXN], v[MAXN];
 
int main () { _
	int n;
	cin >> n;
	for (int i = 0; i < n-2; i++) {
		cin >> v[i];
		c[v[i]]++;
	}
	priority_queue<int, vector<int>, greater<int>> fila;
	for (int i = 1; i <= n; i++) {
		if (!c[i]) fila.push(i);
	}
	for (int i = 0; i < n-2; i++) {
		cout << fila.top() << ' ' << v[i] << '\n';
		fila.pop();
		c[v[i]]--;
		if (!c[v[i]]) fila.push(v[i]);
	}
	cout << fila.top() << ' ';
	fila.pop();
	cout << fila.top() << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1133
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN];
ll tam[MAXN], dp[MAXN], ans[MAXN], n;
 
void dfs(int node, int pai) {
	tam[node] = 1;
	for (int x : v[node]) {
		if (x != pai) {
			dfs(x, node);
			tam[node] += tam[x];
			dp[node] += tam[x] + dp[x];
		}
	}
}
 
void dfs2(int node, int pai) {
	ans[node] = ans[pai] + n - 2 * tam[node];
	for (int x : v[node]) 
		if (x != pai) dfs2(x, node);
}
 
int main () { _
	cin >> n;
	for (int i = 0; i < n-1; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	dfs(1, 0);
	ans[0] = dp[1] + 2*tam[1] - n;
	dfs2(1, 0);
	for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
	cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1190
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
struct t{
	ll pre, suf, tot, ans;
};
 
t a[4*MAXN];
ll v[MAXN];
 
void build(int node, int i, int j) {
	if (i == j) {
		a[node].pre = a[node].suf = a[node].ans = max(0ll, v[i]);
		a[node].tot = v[i];
	}
	else {
		int m = (i+j)/2;
		build(2*node, i, m);
		build(2*node+1, m+1, j);
		a[node].pre = max(a[2*node].pre, a[2*node].tot + a[2*node+1].pre);
		a[node].suf = max(a[2*node].suf + a[2*node+1].tot, a[2*node+1].suf);
		a[node].tot = a[2*node].tot + a[2*node+1].tot;
		a[node].ans = max({a[node].pre, a[node].suf, a[2*node].ans, a[2*node+1].ans, a[2*node].suf + a[2*node+1].pre});
	}
}
 
void upd(int node, int i, int j, int pos) {
	if (i == j) {
		a[node].pre = a[node].suf = a[node].ans = max(0ll, v[i]);
		a[node].tot = v[i];
	}
	else {
		int m = (i+j)/2;
		if (pos <= m) upd(2*node, i, m, pos);
		else upd(2*node+1, m+1, j, pos);
		a[node].pre = max(a[2*node].pre, a[2*node].tot + a[2*node+1].pre);
		a[node].suf = max(a[2*node].suf + a[2*node+1].tot, a[2*node+1].suf);
		a[node].tot = a[2*node].tot + a[2*node+1].tot;
		a[node].ans = max({a[node].pre, a[node].suf, a[2*node].ans, a[2*node+1].ans, a[2*node].suf + a[2*node+1].pre});
	}
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> v[i];
	build(1, 1, n);
	int x, y;
	for (int i = 0; i < m; i++) {
		cin >> x >> y;
		v[x] = y;
		upd(1, 1, n, x);
		cout << a[1].ans << '\n';
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1202
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
vector<pii> v[MAXN], w[MAXN];
ll dist[MAXN], quant[MAXN], mn[MAXN], mx[MAXN];
int n, m, vis[MAXN];
 
void dijkstra(int node) {
	for (int i = 1; i <= n; i++) dist[i] = INF;
	dist[node] = 0;
	priority_queue<pll, vector<pll>, greater<pll>> fila;
	fila.push({0, node});
	while (!fila.empty()) {
		pll atual = fila.top();
		fila.pop();
		if (dist[atual.S] < atual.F) continue;
		for (pii x : v[atual.S]) {
			if (dist[x.F] > atual.F + x.S) {
				dist[x.F] = atual.F + x.S;
				fila.push({dist[x.F], x.F});
			}
		}
	}
}
 
void dag(int node) {
	vis[node] = 1;
	for (pii x : v[node]) {
		if (dist[node] + x.S == dist[x.F]) {
			w[node].pb(x);
			if (!vis[x.F]) dag(x.F);
		}
	}
}
 
void dfs(int node) {
	vis[node] = 1;
	for (pii x : w[node]) {
		if (!vis[x.F]) dfs(x.F);
		quant[node] += quant[x.F];
		if (quant[node] >= M) quant[node] -= M;
		mn[node] = min(mn[node], mn[x.F]+1);
		mx[node] = max(mx[node], mx[x.F]+1);
	}
}
 
int main () { _
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b, c;
		cin >> a >> b >> c;
		v[a].pb({b, c});
	}
	dijkstra(1);
	dag(1);
	memset(vis, 0, sizeof(vis));
	for (int i = 1; i <= n; i++) {
		mn[i] = INF;
		mx[i] = -INF;
	}
	mn[n] = mx[n] = 0;
	quant[n] = 1;
	// min price = dist[n]
	// how many routes
	// min number of edges in route
	// max number of edges in route
	dfs(1);
	cout << dist[n] << ' ' << quant[1] << ' ' << mn[1] << ' ' << mx[1] << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1197
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2550
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
vector<array<int, 3>> v;
ll dist[MAXN];
int p[MAXN];
 
int main() { _
	int n, m;
	cin >> n >> m;
	array<int, 3> a;
	for (int i = 0; i < m; i++) {
		cin >> a[0] >> a[1] >> a[2];
		v.pb(a);
	}
	int x = -1;
	for (int i = 2; i <= n; i++) dist[i] = INF;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (dist[v[j][0]] + v[j][2] < dist[v[j][1]]) {
				dist[v[j][1]] = dist[v[j][0]] + v[j][2];
				p[v[j][1]] = v[j][0];
				if (i == n-1) x = v[j][1];
			}
		}
	}
	if (x == -1) cout << "NO\n";
	else {
		cout << "YES\n";
		for (int i = 0; i < n; i++) x = p[x];
		stack<int> ans;
		ans.push(x);
		for (int i = p[x]; i != x; i = p[i]) {
			ans.push(i);
		}
		ans.push(x);
		while (!ans.empty()) {
			cout << ans.top() << ' ';
			ans.pop();
		}
		cout << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1196
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
vector<pii> v[MAXN];
priority_queue<ll> dist[MAXN];
int n, m, k;
 
void dijkstra() {
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < k; j++) dist[i].push(INF);
	}
	dist[1].pop();
	dist[1].push(0);
	priority_queue<pll, vector<pll>, greater<pll>> fila;
	fila.push({0, 1});
	while (!fila.empty()) {
		pll atual = fila.top();
		fila.pop();
		if (atual.F > dist[atual.S].top()) continue;
		for (pii x : v[atual.S]) {
			if (dist[x.F].top() > atual.F + x.S) {
				dist[x.F].pop();
				dist[x.F].push(atual.F + x.S);
				fila.push({atual.F + x.S, x.F});
			}
		}
	}
}
 
int main() { _
	cin >> n >> m >> k;
	for (int i = 0; i < m; i++) {
		int a, b, c;
		cin >> a >> b >> c;
		v[a].pb({b, c});
	}
	dijkstra();
	vector<ll> ans;
	while (!dist[n].empty()) {
		ans.pb(dist[n].top());
		dist[n].pop();
	}
	reverse(ans.begin(), ans.end());
	for (ll x : ans) cout << x << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1195
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<pii> v[MAXN];
ll dist[MAXN][10], n, m, coupons = 1;
 
struct d {
	int no;
	int sale;
	ll di;
 
	d(int _no = 0, ll _di = 0, int _sale = 0) {
		no = _no;
		di = _di;
		sale = _sale;
	}
 
	inline const bool operator<(const d& other) const {
		if (sale == other.sale) {
			return di > other.di;
		}
		return sale > other.sale;
	}
};
 
void dijkstra(int node) {
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < 10; j++) dist[i][j] = INF;
	}
	dist[node][0] = 0;
	d aux;
	aux.no = node, aux.di = 0, aux.sale = 0;
	priority_queue<d> fila;
	fila.push(aux);
	while (!fila.empty()) {
		aux = fila.top();
		fila.pop();
		if (dist[aux.no][aux.sale] < aux.di) continue;
		for (pii x : v[aux.no]) {
			if (dist[x.F][aux.sale] > aux.di + x.S) {
				dist[x.F][aux.sale] = aux.di + x.S;
				d next;
				next.no = x.F, next.di = dist[x.F][aux.sale], next.sale = aux.sale;
				fila.push(next);
			}
			if (aux.sale < coupons) {
				if (dist[x.F][aux.sale+1] > aux.di + x.S/2) {
					dist[x.F][aux.sale+1] = aux.di + x.S/2;
					d next;
					next.no = x.F, next.di = dist[x.F][aux.sale+1], next.sale = aux.sale+1;
					fila.push(next);
				}
			}
		}
	}
}
 
int main () { _
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b, c;
		cin >> a >> b >> c;
		v[a].pb({b, c});
	}
	dijkstra(1);
	cout << dist[n][coupons] << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1194
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1010
#define INF 1000000
#define PB push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int n, m, dist[MAXN][MAXN];
pii go[MAXN][MAXN], a, A;
char v[MAXN][MAXN];
bool ber, check[MAXN][MAXN];
queue<pii> fila;
queue<pair<pii, int>> qu;
 
void BFS_multi() {
    while(!fila.empty()) {
        A = fila.front();
        fila.pop();
        check[A.F][A.S] = true;
        if (A.F + 1 < n && !check[A.F+1][A.S] && v[A.F+1][A.S] != '#') {
            dist[A.F+1][A.S] = min(dist[A.F+1][A.S], 1+dist[A.F][A.S]);
            fila.push({A.F+1, A.S});
            check[A.F+1][A.S] = true;
        }
        if (A.F - 1 >= 0 && !check[A.F-1][A.S] && v[A.F-1][A.S] != '#') {
            dist[A.F-1][A.S] = min(dist[A.F-1][A.S], 1+dist[A.F][A.S]);
            fila.push({A.F-1, A.S});
            check[A.F-1][A.S] = true;
        }
        if (A.S + 1 < m && !check[A.F][A.S+1] && v[A.F][A.S+1] != '#') {
            dist[A.F][A.S+1] = min(dist[A.F][A.S+1], 1+dist[A.F][A.S]);
            fila.push({A.F, A.S+1});
            check[A.F][A.S+1] = true;
        }
        if (A.S - 1 >= 0 && !check[A.F][A.S-1] && v[A.F][A.S-1] != '#') {
            dist[A.F][A.S-1] = min(dist[A.F][A.S-1], 1+dist[A.F][A.S]);
            fila.push({A.F, A.S-1});
            check[A.F][A.S-1] = true;
        }
    }
}
 
pii BFS() {
    while (!qu.empty()) {
        A = qu.front().F;
        if (A.F == 0 || A.F == n-1 || A.S == 0 || A.S == m-1) {
            return A;
        }
        int D = qu.front().S;
        qu.pop();
        check[A.F][A.S] = true;
        if (A.F + 1 < n && !check[A.F+1][A.S] && dist[A.F+1][A.S] > D+1 && v[A.F+1][A.S] != '#') {
            go[A.F+1][A.S] = A;
            qu.push(make_pair(make_pair(A.F+1, A.S), D+1));
            check[A.F+1][A.S] = true;
        }
        if (A.F - 1 >= 0 && !check[A.F-1][A.S] && dist[A.F-1][A.S] > D+1 && v[A.F-1][A.S] != '#') {
            go[A.F-1][A.S] = A;
            qu.push(make_pair(make_pair(A.F-1, A.S), D+1));
            check[A.F-1][A.S] = true;
        }
        if (A.S + 1 < m && !check[A.F][A.S+1] && dist[A.F][A.S+1] > D+1 && v[A.F][A.S+1] != '#') {
            go[A.F][A.S+1] = A;
            qu.push(make_pair(make_pair(A.F, A.S+1), D+1));
            check[A.F][A.S+1] = true;
        }
        if (A.S - 1 >= 0 && !check[A.F][A.S-1] && dist[A.F][A.S-1] > D+1 && v[A.F][A.S-1] != '#') {
            go[A.F][A.S-1] = A;
            qu.push(make_pair(make_pair(A.F, A.S-1), D+1));
            check[A.F][A.S-1] = true;
        }
    }
    return {-1, -1};
}
 
int main() { _
    memset(go, -1, sizeof(go));
    cin >> n >> m;
    int resp = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> v[i][j];
            if (v[i][j] == 'M') {
                dist[i][j] = 0;
                fila.push({i, j});
            }
            else dist[i][j] = INF;
            if (v[i][j] == 'A') a = {i, j};
        }
    }
    BFS_multi();
    memset(check, false, sizeof(check));
    qu.push({a, 0});
    pii fim = BFS();
    if (fim.F == -1) cout << "NO" << endl;
    else {
        cout << "YES" << endl;
        stack<char> ans;
        while(fim != a) {
            if (go[fim.F][fim.S] == make_pair(fim.F+1, fim.S)) ans.push('U');
            else if (go[fim.F][fim.S] == make_pair(fim.F-1, fim.S)) ans.push('D');
            else if (go[fim.F][fim.S] == make_pair(fim.F, fim.S+1)) ans.push('L');
            else ans.push('R');
            resp++;
            fim = go[fim.F][fim.S];
        }
        cout << (int)ans.size() << endl;
        while(!ans.empty()) {
            cout << ans.top();
            ans.pop();
        }
        cout << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1193
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
using namespace std;
#define MAXN 1003
#define MAXS 1003
int n, m, inix, iniy, fimx, fimy;
int vis[MAXN][MAXS];
char path[MAXN][MAXS];
char mapa[MAXN][MAXS];
int varx[] = {1, -1, 0, 0};
int vary[] = {0, 0, 1, -1};
int BFS(int a, int b) {
    queue<pair<int,int>> q;
    q.push({a, b});
	mapa[a][b] = '#';
    while(!q.empty()) {
        int x = q.front().first;
        int y = q.front().second;
        q.pop();
        for (int i = 0; i < 4; i++) {
            int X = varx[i] + x;
            int Y = vary[i] + y;
            if (X <= 0 || X > n || Y <= 0 || Y > m || mapa[X][Y] == '#') continue;
            q.push({X, Y});
            vis[X][Y] = vis[x][y] + 1;
			bool fim = (mapa[X][Y] == 'B');
	        mapa[X][Y] = '#';
            if (i == 0) path[X][Y] = 'D';
            else if (i == 1) path[X][Y] = 'U';
            else if (i == 2) path[X][Y] = 'R';
            else path[X][Y] = 'L';
            if (fim) {
                fimx = X;
                fimy = Y;
                return vis[X][Y];
            }
        }
    }
    return 0;
}
 
int main() {
    memset(vis, 0, sizeof(vis));
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> mapa[i][j];
            if (mapa[i][j] == 'A') {
                inix = i;
                iniy = j;
            }
        }
    }
    int resposta = BFS(inix, iniy);
	if (!resposta) cout << "NO\n";
	else {
		cout << "YES\n";
		cout << resposta << endl;
		vector<char> caminho;
		int i = fimx, j = fimy;
		while (make_pair(i, j) != make_pair(inix, iniy)) {
			caminho.push_back(path[i][j]);
			if (path[i][j] == 'D') i--;
			else if (path[i][j] == 'U') i++;
			else if (path[i][j] == 'R') j--;
			else j++;
		}
		for (int i = caminho.size()-1; i >= 0; i--) {
			cout << caminho[i];
		}
		cout << '\n';
	}
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1192
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 10000000000
 
using namespace std;
typedef long long int lli;
const int mod = 1e9+7;
 
int n, m, matriz[1010][1010], resp = 0;
bool check[1010][1010];
 
void DFS (int i, int j) {
    check[i][j] = true;
    if (i+1 < n and !check[i+1][j] and !matriz[i+1][j]) DFS(i+1, j);
    if (i-1 >= 0 and !check[i-1][j] and !matriz[i-1][j]) DFS(i-1, j);
    if (j+1 < m and !check[i][j+1] and !matriz[i][j+1]) DFS(i, j+1);
    if (j-1 >= 0 and !check[i][j-1] and !matriz[i][j-1]) DFS(i, j-1);
}
 
int main() { _
    char c;
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> c;
            if (c == '.') matriz[i][j] = 0;
            else matriz[i][j] = 1;
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (!check[i][j] and !matriz[i][j]) {
                DFS(i, j);
                resp++;
            }
        }
    }
    cout << resp << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1191
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const ll INF = 2e18;
 
ll v[MAXN], pre[MAXN], to[MAXN], n, b;
 
void solve() {
    int r = 1; 
    for (int l = 1; l <= 2 * n; l++) {
        while (r <= 2 * n && pre[r + 1] - pre[l - 1] <= b) r++;
        to[l] = r;
    }
    int mn = 2 * n + 1, id = -1;
    for (int i = 1; i <= n; i++) {
        if (to[i] - i + 1 < mn) {
            mn = to[i] - i + 1;
            id = i;
        }
    }
    int st = id, ans = 1e9;
    for (int i = id; i <= id + mn; i++) {
        int cur = st, cnt = 0;
        while (cur - st < n) {
            cur = to[cur] + 1;
            cnt++;
        }
        ans = min(ans, cnt);
        st = st % n + 1;
    }
    cout << ans << '\n';
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> b;
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
        v[i + n] = v[i];
    }
    for (int i = 1; i <= 2 * n; i++) {
        pre[i] = v[i] + pre[i - 1];
    }
    solve();
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1132
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN];
pair<pii, pii> dp[MAXN];
int ans[MAXN];
 
void dfs(int node, int pai) {
	for (int x : v[node]) {
		if (x != pai) {
			dfs(x, node);
			if (dp[x].F.F+1 > dp[node].F.F) {
				dp[node].S = dp[node].F;
				dp[node].F = {dp[x].F.F+1, x};
			}
			else if (dp[x].F.F+1 > dp[node].S.F) {
				dp[node].S = {dp[x].F.F+1, x};
			}
		}
	}
}
 
void dfs2(int node, int pai) {
	for (int x : v[node]) {
		if (x != pai) {
			if (dp[node].F.S == x) {
				ans[x] = max(dp[node].S.F, ans[node]) + 1;
			}
			else {
				ans[x] = max(dp[node].F.F, ans[node]) + 1;
			}
			dfs2(x, node);
		}
	}
}
 
int main () { _
	int n;
	cin >> n;
	for (int i = 0; i < n-1; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	dfs(1, 0);
	dfs2(1, 0);
	for (int i = 1; i <= n; i++) cout << max(dp[i].F.F, ans[i]) << ' ';
	cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1189
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const ll INF = 2e18;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    vector<int> a(n), b(n), flow(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    for (int i = 0; i < n; i++) {
        cin >> b[i];
        a[i] = b[i] - a[i];
        if (i) flow[i] = flow[i - 1] + a[i - 1];
    }
    sort(flow.begin(), flow.end());
    int ans = flow[n / 2];
    ll tot = 0;
    for (int i = 0; i < n; i++) {
        tot += abs(flow[i] - ans);
    }
    cout << tot << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1188
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
struct t{
	int pre, suf, ans, tam;
};
 
string s;
t a[4*MAXN][2];
 
void merge(int node) {
	a[node][0].tam = a[2*node][0].tam + a[2*node+1][0].tam;
	if (a[2*node][0].pre == a[2*node][0].tam) 
		a[node][0].pre = a[2*node][0].pre + a[2*node+1][0].pre;
	else a[node][0].pre = a[2*node][0].pre;
 
	if (a[2*node][1].pre == a[2*node][0].tam) 
		a[node][1].pre = a[2*node][1].pre + a[2*node+1][1].pre;
	else a[node][1].pre = a[2*node][1].pre;
 
	if (a[2*node+1][0].suf == a[2*node+1][0].tam) 
		a[node][0].suf = a[2*node][0].suf + a[2*node+1][0].suf;
	else a[node][0].suf = a[2*node+1][0].suf;
 
	if (a[2*node+1][1].suf == a[2*node+1][0].tam) 
		a[node][1].suf = a[2*node][1].suf + a[2*node+1][1].suf;
	else a[node][1].suf = a[2*node+1][1].suf;
 
	a[node][0].ans = max({a[node][0].pre, a[node][0].suf, a[2*node][0].ans, a[2*node+1][0].ans, a[2*node][0].suf + a[2*node+1][0].pre});
	a[node][1].ans = max({a[node][1].pre, a[node][1].suf, a[2*node][1].ans, a[2*node+1][1].ans, a[2*node][1].suf + a[2*node+1][1].pre});
}
 
void build(int node, int i, int j) {
	if (i == j) {
		a[node][0].ans = a[node][0].pre = a[node][0].suf = (s[i] == '0');
		a[node][1].ans = a[node][1].pre = a[node][1].suf = (s[i] == '1');
		a[node][0].tam = 1;
	}
	else {
		int m = (i+j)/2;
		build(2*node, i, m);
		build(2*node+1, m+1, j);
		merge(node);
	}
}
 
void upd(int node, int i, int j, int pos) {
	if (i == j) {
		a[node][0].ans = a[node][0].pre = a[node][0].suf = (s[i] == '0');
		a[node][1].ans = a[node][1].pre = a[node][1].suf = (s[i] == '1');
	}
	else {
		int m = (i+j)/2;
		if (m >= pos) upd(2*node, i, m, pos);
		else upd(2*node+1, m+1, j, pos);
		merge(node);
	}
}
 
int main () { _
	cin >> s;
	int n = (int)s.size();
	build(1, 0, n-1);
	int q;
	cin >> q;
	int pos;
	for (int i = 0; i < q; i++) {
		cin >> pos;
		pos--;
		s[pos] = (s[pos] == '1' ? '0' : '1');
		upd(1, 0, n-1, pos);
		cout << max(a[1][0].ans, a[1][1].ans) << ' ';
	}
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1164
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
struct t {
	int f, s;
	bool sair;
};
 
int main() { _
    int n;
	t aux;
	cin >> n;
	vector<t> v;
	vector<int> w(n, -1);
	for (int i = 0; i < n; i++) {
		cin >> aux.f >> aux.s;
		int depois = aux.s;
		aux.s = i;
		aux.sair = false;
		v.pb(aux);
		aux.f = depois+1;
		aux.sair = true;
		v.pb(aux);
	}
	int tot = 1;
	queue<int> q;
	sort(v.begin(), v.end(), [&](t a, t b) { 
		if (a.f != b.f) return a.f < b.f;
		return (a.sair && !b.sair);
	});
	for (t x : v) {
		if (w[x.s] == -1) {
			if (q.empty()) {
				w[x.s] = tot++;
			}
			else {
				w[x.s] = q.front();
				q.pop();
			}
		}
		else {
			q.push(w[x.s]);
		}
	}
	cout << tot-1 << '\n';
	sort(v.begin(), v.end(), [&](t a, t b) {
		return a.s < b.s;
	});
	bool ber = true;
	for (t x : v) {
		if (ber)
			cout << w[x.s] << ' ';
		ber = 1-ber;
	}
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1163
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
set<int> luz;
multiset<int> dist;
 
int main() { _
    int x, n, aux;
    cin >> x >> n;
    luz.insert(0), luz.insert(x);
    dist.insert(x);
    for (int i = 0; i < n; i++) {
        cin >> aux;
        auto it1 = luz.upper_bound(aux);
        auto it2 = it1;
        it2--;
        dist.erase(dist.find(*it1 - *it2));
        dist.insert(*it1 - aux), dist.insert(aux - *it2);
        luz.insert(aux);
        it1 = dist.end(), it1--;
        cout << *it1 << ' ';
    }
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1162
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
int v[MAXN], a[MAXN], inv[MAXN], vis[MAXN];
vector<int> adj[MAXN];
 
int sum(int pos) {
    int ans = 0;
    for (; pos; pos -= (pos & -pos)) ans += a[pos];
    return ans;
}
 
void upd(int pos, int val) { for (; pos < MAXN; pos += (pos & -pos)) a[pos] += val; }
 
void dfs(int node) {
    vis[node] = 1;
    for (int x : adj[node]) 
        if (!vis[x]) dfs(x);
}
 
int lis(int n) {
    vector<int> pilha;
    for (int i = 0; i < n; i++) {
        auto pos = lower_bound(pilha.begin(), pilha.end(), v[i]);
        if (pos == pilha.end())
            pilha.push_back(v[i]);
        else *pos = v[i];
    }
    return pilha.size();
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) cin >> v[i];
    ll ans1 = 0;
    int ans2 = n, ans3 = n, ans4 = n;
    int atual = n;
    for (int i = n-1; i >= 0; i--) {
        ans1 += sum(v[i]);
        upd(v[i], 1);
        if (v[i] == atual) {
            atual--;
            ans4--;
        }
        adj[v[i]].push_back(i+1);
        adj[i+1].push_back(v[i]);
    }
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) {
            dfs(i);
            ans2--;
        }
    }
    ans3 -= lis(n);
    cout << ans1 << ' ' << ans2 << ' ' << ans3 << ' ' << ans4 << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1161
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	int x, n;
	cin >> x >> n;
	vector<int> v(n);
	priority_queue<int, vector<int>, greater<int>> fila;
	for (int &x : v) {
		cin >> x;
		fila.push(x);
	}
	ll ans = 0;
	int a, b;
	while (fila.size() > 1) {
		a = fila.top();
		fila.pop();
		b = fila.top();
		fila.pop();
		ans += a + b;
		fila.push(a+b);
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1160
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int tree[MAXN], ciclo[MAXN], id[MAXN], peso[MAXN], tab[MAXN][20], cor[MAXN], dep[MAXN], in[MAXN], x;
 
int sobe(int node, int k) {
	if (k < 0) return -1;
	for (int i = 19; i >= 0; i--) {
		if (k & (1<<i)) node = tab[node][i];
	}
	return node;
}
 
void dfs(int node) {
	cor[node] = 1;
	if (!cor[tab[node][0]]) dfs(tab[node][0]);
	else if (cor[tab[node][0]] == 1) {
		x++;
		int atual = node, p = 0;
		do {	
			p++;
			ciclo[atual] = x;
			tree[atual] = atual;
			id[atual] = p;
			atual = tab[atual][0];
		} while (atual != node);
		peso[x] = p;
	}
	cor[node] = 2;
}
 
void dfs2(int node) {
	cor[node] = 1;
	if (!cor[tab[node][0]] && !ciclo[tab[node][0]]) dfs2(tab[node][0]);
	tree[node] = tree[tab[node][0]];
	dep[node] = dep[tab[node][0]] + 1;
}
 
int main() { _
	x = 0;
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> tab[i][0];
		in[tab[i][0]]++;
	}
	for (int i = 1; i < 20; i++) {
		for (int j = 1; j <= n; j++) tab[j][i] = tab[tab[j][i-1]][i-1];
	}
	for (int i = 1; i <= n; i++) {
		if (!cor[i]) dfs(i);
	}
	memset(cor, 0, sizeof(cor));
	for (int i = 1; i <= n; i++) {
		if (!in[i]) dfs2(i);
	}
	int a, b;
	for (int i = 0; i < q; i++) {
		cin >> a >> b;
		if (ciclo[a]) {
			if (ciclo[b]) {
				if (ciclo[a] == ciclo[b]) {
					if (id[b] >= id[a]) cout << id[b] - id[a] << '\n';
					else cout << peso[ciclo[b]] + id[b] - id[a] << '\n';
				}
				else cout << "-1\n";
			}
			else if (!ciclo[b]) cout << "-1\n";
		}
		else if (!ciclo[a]) {
			if (!ciclo[b]) {
				if (sobe(a, dep[a] - dep[b]) == b) cout << dep[a] - dep[b] << '\n';
				else cout << "-1\n";
			}
			else if (ciclo[b]) {
				if (ciclo[tree[a]] == ciclo[b]) {
					if (id[b] >= id[tree[a]]) cout << id[b] - id[tree[a]] + dep[a] << '\n';
					else cout << peso[ciclo[b]] + id[b] - id[tree[a]] + dep[a] << '\n';
				}
				else cout << "-1\n";
			}
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1159
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
int cop[MAXN], pr[MAXN], pg[MAXN], dp[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, x;
    cin >> n >> x;
    for (int i = 0; i < n; i++) 
        cin >> pr[i];
    for (int i = 0; i < n; i++) 
        cin >> pg[i];  
    
    vector<int> pages, price;
    for (int i = 0; i < n; i++) {
        cin >> cop[i];
        int tot = 0;
        for (int j = 0; j < 10; j++) {
            if (cop[i] >= (1 << (j+1))) {
                pages.push_back(pg[i] * (1<<j));
                price.push_back(pr[i] * (1<<j));
                tot += (1<<j);
            }
        }
        pages.push_back(pg[i] * (cop[i] - tot));
        price.push_back(pr[i] * (cop[i] - tot));
    }
    int m = (int)pages.size();
    for (int i = 0; i < m; i++) {
        for (int j = x; j >= price[i]; j--) {
            dp[j] = max(dp[j-price[i]] + pages[i], dp[j]);
        }
    }
    int ans = 0;
    for (int i = 0; i <= x; i++) ans = max(ans, dp[i]);
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1077
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
	int n, k;
    cin >> n >> k;
    vector<int> v(n);
    multiset<ll> menor, maior, aux;
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        if (i < k) aux.insert(v[i]);
    }
    int count = 0;
    ll mi = 0, mj = 0;
    for (int x : aux) {
        if (count < (k+1)/2) {
            menor.insert(x);
            mi += x;
        }
        else {
            maior.insert(x);
            mj += x;
        }
        count++;
    }
    cout << abs(mi - (int)menor.size() * *menor.rbegin()) + abs(mj - (int)maior.size() * *menor.rbegin()) << ' ';
    for (int i = k; i < n; i++) {
        if (maior.find(v[i-k]) != maior.end()) {
            maior.erase(maior.find(v[i-k]));
            mj -= v[i-k];
        }
        else {
            menor.erase(menor.find(v[i-k]));
            mi -= v[i-k];
        }
        if (menor.empty() || v[i] > *menor.rbegin()) {
            maior.insert(v[i]);
            mj += v[i];
        }
        else {
            menor.insert(v[i]);
            mi += v[i];
        }
        while (maior.size() > menor.size()) {
            menor.insert(*maior.begin());
            mi += *maior.begin();
            mj -= *maior.begin();
            maior.erase(maior.begin());
        }
        while (menor.size()-1 > maior.size()) {
            auto it = menor.end();
            it--;
            mi -= *it;
            mj += *it;
            maior.insert(*it);
            menor.erase(it);
        }
        cout << abs(mi - (int)menor.size() * *menor.rbegin()) + abs(mj - (int)maior.size() * *menor.rbegin()) << ' ';
    }
    cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1085
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n, k;
	cin >> n >> k;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	ll l = 0, r = 1e16;
	while (r > l + 1) {
		ll m = (r+l)/2;
		ll count = 0, sum = 0;
		for (int i = 0; i < n; i++) {
			if (sum + v[i] <= m) sum += v[i];
			else {
				sum = v[i];
				if (sum > m) count = 1e8;
				count++;
			}
		}
		count += (sum > 0);
		if (count <= k) r = m;
		else l = m;
	}	
	cout << r << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1084
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 999999
 
using namespace std;
typedef long long int lli;
 
int main() {
	int n, m, k, ap[MAXN], v[MAXN], resp = 0;
	cin >> n >> m >> k;
	for (int i = 0; i < n; i++) {
		cin >> v[i];
	}
	for (int i = 0; i < m; i++) {
		cin >> ap[i];
	}
	sort(v, v+n);
	sort(ap, ap+m);
	int id = 0;
	for (int i = 0; i < n && id < m; i++) {
		while (v[i] > ap[id]+k and id < m) id++;
		if (v[i] < ap[id]-k) continue;
		if (id < m) resp++;
		id++;
	}
	cout << resp << endl;
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1083
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n, aux;
	cin >> n;
	vector<int> check(n+1);
	for (int i = 0; i < n - 1; i++) {
		cin >> aux;
		check[aux] = 1;
	}
	for (int i = 1; i <= n; i++) {
		if (!check[i]) {
			cout << i << "\n";
			break;
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1082
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    ll n;
    cin >> n;
    ll ans = 0, last = n, ult, um, dois;
    for (int i = 2; i <= 1e6; i++) {
        ult = n/i + 1;
        if ((last + ult) % 2 == 0) {
            um = ((last + ult) / 2) % M;
            dois = (last - ult + 1) % M;
        }
        else {
            um = (last + ult) % M;
            dois = ((last - ult + 1) / 2) % M;
        }
        ll mais = (um * dois) % M;
        mais = (mais * (i-1)) % M;
        ans += mais;
        if (ans >= M) ans -= M;
        last = ult-1;
    }
    for (int i = 1; i <= last; i++) {
        ans = (ans + (n/i * i)) % M;
    }
    cout << ans << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1081
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	ll n, aux;
	cin >> n;
	vector<int> v(1e6+10), c(1e6+10);
	for (int i = 0; i < n; i++) {
		cin >> aux;
		v[aux]++;
	}
	int resp = 0;
	for (int i = 1e6; !resp &&  i > 0; i--) {
		for (int j = i; !resp && j <= 1e6; j+=i) {
			c[i]+=v[j];
			if (c[i] > 1) resp = i;
		}
	}
	cout << resp << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1080
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
int add(int a, int b) {
    if (a + b >= MOD)
        return a + b - MOD;
    if (a + b < 0)
        return a + b + MOD;
    return a + b;
}
 
int dp[505][505], c[505][505];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    int n = (int)s.size();
    c[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        c[i][0] = 1;
        for (int j = 1; j <= i; j++) {
            c[i][j] = add(c[i-1][j], c[i-1][j-1]);
        }
    }
    for (int i = 0; i+1 <= n; i++) 
        dp[i+1][i] = 1;
 
    for (int i = n-1; i >= 0; i--) {
        for (int j = i+1; j < n; j+=2) {
            for (int k = i+1; k <= j; k+=2) {
                if (s[i] == s[k]) 
                    dp[i][j] = add(dp[i][j], (((1ll * dp[i+1][k-1] * dp[k+1][j]) % MOD) * c[(j-i+1)/2][(k-i+1)/2]) % MOD);            
            }
        }
    }
    cout << dp[0][n-1] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1079
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, int e) {
    ll resp = 1;
    while (e) {
        if (e&1) resp = (resp * b) % M;
        e >>= 1;
        b = (b * b) % M;
    }
    return resp;
}
 
int main () { _
    vector<int> fat(1e6+10), inv(1e6+10);
    fat[0] = fat[1] = 1;
    for (int i = 2; i <= 1e6; i++) {
        fat[i] = ((ll) fat[i-1] * i) % M;
    }
    inv[1e6] = fexp(fat[1e6], M-2);
    for (int i = 1e6-1; i >= 0; i--) {
        inv[i] = ((ll) inv[i+1] * (i+1)) % M;
    }
    int n, a, b;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a >> b;
        cout << (((ll) fat[a] * inv[b]) % M * inv[a-b]) % M << '\n';
    }
    return 0;   
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1078
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int fexp(ll b, int e) {
	ll resp = 1;
	while (e) {
		if (e&1) resp = (resp * b) % M;
		e = (e>>1);
		b = (b * b) % M;
	}
	return resp;
}
 
int main () { _
	int h, w, n;
	cin >> h >> n;
	w = h;
	vector<ll> inv(1000100, 1), fat(2000100, 1), dp(n);
	ll f;
	for (int i = 2; i < 2000050; i++) {
		f = fat[i-1]*i % M;
		fat[i] = f;
	}
	inv[1000050] = fexp(fat[1000050], M-2);
	for (int i = 1000049; i >= 0; i--) {
		inv[i] = (inv[i+1] * (i+1)) % M;
	}
	vector<pii> v(n);
	for (int i = 0; i < n; i++) cin >> v[i].F >> v[i].S;
	sort(v.begin(), v.end());
	for (int i = 0; i < n; i++) {
		dp[i] = fat[v[i].F + v[i].S - 2] * inv[v[i].F - 1] % M;
		dp[i] = dp[i] * inv[v[i].S - 1] % M;
		for (int j = i-1; j >= 0; j--) {
			if (v[j].F <= v[i].F && v[j].S <= v[i].S) {
				ll nova = dp[j] * fat[v[i].F - v[j].F + v[i].S - v[j].S] % M;
				nova = nova * inv[v[i].F - v[j].F] % M;
				nova = nova * inv[v[i].S - v[j].S] % M;
				dp[i] -= nova;	
				if (dp[i] < 0) dp[i] += M;
			}
		}
	}
	ll total = fat[h+w-2] * inv[h-1] % M;
	total = total * inv[w-1] % M;
	for (int i = 0; i < n; i++) {
		dp[i] = dp[i] * fat[h + w - v[i].F - v[i].S] % M;
		dp[i] = dp[i] * inv[h - v[i].F] % M;
		dp[i] = dp[i] * inv[w - v[i].S] % M;
		total -= dp[i];
		if (total < 0) total += M;
	}
	cout << total << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1086
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	ll n;
	cin >> n;
	ll ans = 524638270000000001;
	for (int i = 0; i < 10; i++) {
		ll l = 0, r = 524638270000000001;
		while (r > l+1) {
			ll m = (r+l) >> 1, test = m, cnt = 0, pot = 1;
			for (int j = 0; j <= 18; j++) {
				if (!test) break;
				cnt += pot * (test/10 + (test%10 > i));
				if (test%10 == i) cnt += m - test*pot + 1;
				if (!i) cnt -= pot;
				pot *= 10;
				test /= 10;
			}
			if (cnt <= n) l = m;
			else r = m;
		}
		ans = min(ans, l);
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1076
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
	int n, k;
    cin >> n >> k;
    vector<int> v(n);
    multiset<int> menor, maior, aux;
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        if (i < k) aux.insert(v[i]);
    }
    int count = 0;
    for (int x : aux) {
        if (count < (k+1)/2) {
            menor.insert(x);
        }
        else {
            maior.insert(x);
        }
        count++;
    }
    cout << *menor.rbegin() << ' ';
    for (int i = k; i < n; i++) {
        if (maior.find(v[i-k]) != maior.end()) maior.erase(maior.find(v[i-k]));
        else menor.erase(menor.find(v[i-k]));
        if (menor.empty() || v[i] > *menor.rbegin()) maior.insert(v[i]);
        else menor.insert(v[i]);
        while (maior.size() > menor.size()) {
            menor.insert(*maior.begin());
            maior.erase(maior.begin());
        }
        while (menor.size()-1 > maior.size()) {
            auto it = menor.end();
            it--;
            maior.insert(*it);
            menor.erase(it);
        }
        cout << *menor.rbegin() << ' ';
    }
    cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1075
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 4e5 + 5;
const ll INF = 2e18;

int dp[1005][1005][2];
 
void add(int &a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
}
 
int mul(int a, int b) {
    return (1ll * a * b) % MOD;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    dp[1][0][0] = 1;
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            add(dp[i + 1][j + 1][1], mul(2, dp[i][j][0]));
            if (j)
                add(dp[i + 1][j - 1][0], mul(j, dp[i][j][0]));
            add(dp[i + 1][j][0], mul(i - j - 1, dp[i][j][0]));
            add(dp[i + 1][j + 1][1], dp[i][j][1]);
            if (j)
                add(dp[i + 1][j - 1][0], mul(j - 1, dp[i][j][1]));
            add(dp[i + 1][j][0], mul(i - j, dp[i][j][1]));
            add(dp[i + 1][j][1], dp[i][j][1]);
        }
    }
    cout << dp[n][0][0] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1074
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int n;
    cin >> n;
    vector<int> v(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i];
    }
    sort(v.begin(), v.end());
    long long int ans = 0;
    for (int i = 0; i < n; i++) {
        ans += abs(v[i] - v[n / 2]);
    }
    cout << ans << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1073
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n, aux;
	cin >> n;
	vector<int> pilha;
	for (int i = 0; i < n; i++) {
		cin >> aux;
		auto it = upper_bound(pilha.begin(), pilha.end(), aux);
		if (it == pilha.end()) pilha.pb(aux);
		else *it = aux;
	}
	cout << pilha.size() << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1072
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
int main() { _
    int n;
    lli resp;
    cin >> n;
    if (n >= 1) cout << "0" << endl;
    if (n >= 2) cout << "6" << endl;
    if (n >= 3) cout << "28" << endl;
    for (int i = 4; i <= n; i++) {
        resp = 0LL;
        resp += (1ll)*(i*i - 3)*4;
        resp += (1ll)*(i*i - 4)*8;
        resp += (1ll)*(i*i - 5)*(4 + 4*(i-4));
        resp += (1ll)*(i*i - 7)*(4*(i-4));
        resp += (1ll)*(i*i - 9)*(i-4)*(i-4);
        cout << resp/2 << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1071
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
int main() { _
    int t, x, y;
    lli resp;
    cin >> t;
    for (int i = 0; i < t; i++) {
        cin >> x >> y;
        if (x > y) {
            if (x%2==0) {
                resp = (1ll)*x*x - y + 1;
            }
            else {
                resp = (1ll)*(x-1)*(x-1) + y;
            }
        }
        else {
            if (y%2==0) {
                resp = (1ll)*(y-1)*(y-1) + x; 
            }
            else {
                resp = (1ll)*y*y - x + 1;
            }
        }
        cout << resp << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1070
Author: Bernardo Archegas (codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n;
	cin >> n;
	if (n == 1) cout << "1\n";
	else if (n < 4) cout << "NO SOLUTION\n";
	else {
		int start = n/2 + 1;
		for (int i = 1; i < start; i++) {
			cout << start + i - 1 << " " << i << " ";
		}
		if (n % 2 == 1) cout << 2*start - 1;
		cout << "\n";
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1069
Author: Bernardo Archegas (codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	string s;
	cin >> s;
	int ans = 1;
	int count = 1;
	for (int i = 1; i < (int)s.size(); i++) {
		if (s[i] == s[i-1]) count++;
		else {
			ans = max(ans, count);
			count = 1;
		}
	}
	ans = max(ans, count);
	cout << ans << "\n";
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1097
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n;
    cin >> n;
    vector<int> v(n);
    vector<vector<ll>> dp(n, vector<ll> (n));
    ll soma = 0;
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        soma += v[i];
        dp[i][i] = v[i];
    }
    for (int j = 1; j < n; j++) {
        for (int i = 0; i < n; i++) {
            if (i + j < n) {
                dp[i][i+j] = max(v[i] - dp[i+1][i+j], v[i+j] - dp[i][i+j-1]);
            }
        }
    }
    cout << (soma+dp[0][n-1])/2 << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1131
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
vector<int> v[MAXN];
int n;
 
int bfs(int node, bool flag) {
	queue<pii> q;
	vector<int> check(n+1);
	check[node] = 1;
	q.push({node, 0});
	int resp = 0, no;
	while (!q.empty()) {
		pii atual = q.front();
		q.pop();
		for (int x : v[atual.F]) {
			if (!check[x]) {
				check[x] = 1;
				q.push({x, atual.S+1});
				if (atual.S + 1 > resp) {
					resp = atual.S + 1;
					no = x;
				}
			}
		}
	}
	return (flag ? resp : no);
}
 
int main() { _
    int a, b;
	cin >> n;
	if (n == 1) cout << "0\n";
	else {
		for (int i = 0; i < n - 1; i++) {
			cin >> a >> b;
			v[a].pb(b);
			v[b].pb(a);
		}
		int no = bfs(1, false);
		cout << bfs(no, true) << '\n';
	}	
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1130
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN];
int dp[MAXN][2];
 
void dfs(int node, bool flag, int pai) {
	if (dp[node][flag] > -1) return;
	vector<int> zero, um;
	int ans = 0;
	for (int x : v[node]) {
		if (x != pai) {
			if (flag) {
				dfs(x, false, node);
				ans += dp[x][0];
			}
			else {
				dfs(x, false, node);
				dfs(x, true, node);
				zero.pb(dp[x][0]);
				um.pb(1 + dp[x][1]);
			}
		}
	}
	if (!flag) {
		int tam = (int)zero.size(), total = 0;
		for (int i = 0; i < tam; i++) {
			total += zero[i];
		}
		for (int i = 0; i < tam; i++) {
			ans = max(ans, um[i] + total - zero[i]);
		}
	}
	dp[node][flag] = ans;
}
 
int main () { _
	int n;
	cin >> n;
	for (int i = 0; i < n-1; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	memset(dp, -1, sizeof(dp));
	dfs(1, 0, 0);
	cout << dp[1][0] << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1113
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1112
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
vector<int> prefix(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i-1];
        while (j > 0 && s[i] != s[j])
            j = pi[j-1];
        if (s[i] == s[j])
            j++;
        pi[i] = j;
    }
    return pi;
}
 
vector<vector<int>> aut;
 
void automato(string s) {
    vector<int> kmp = prefix(s + '$');
    int n = s.size() + 1;
    aut.assign(n, vector<int> (26));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < 26; j++) {
            if (i > 0 && 'A' + j != s[i]) 
                aut[i][j] = aut[kmp[i -  1]][j];
            else 
                aut[i][j] = i + ('A' + j == s[i]);
        }
    }
}
 
void add(int &a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
}
 
// dp[position][size of prefix of s][char i¬¥m at]
int dp[1005][105];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
    string s;
    cin >> n >> s;
    m = s.size();
    automato(s);
    dp[0][0] = 1;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            for (int k = 0; k < 26; k++) {
                if (aut[j][k] == m) continue;
                add(dp[i + 1][aut[j][k]], dp[i][j]);
            }
        }
    }
    int ans = 1;
    for (int i = 0; i < n; i++) ans = (ans * 26ll) % MOD;
    for (int i = 0; i < m; i++) {
        add(ans, MOD - dp[n][i]);
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1111
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const ll INF = 2e18;
 
int v[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string ns, s;
    cin >> ns;
    s = "$";
    for (auto x : ns) s += "#", s += x;
    s += "#@";
    int c = 0, r = 0, n = s.size(), mx = 0;
    for (int i = 1; i < n - 1; i++) {
        int mir = 2 * c - i;
        if (i < r) {
            v[i] = min(v[mir], r - i);
        }
        while (s[i + v[i] + 1] == s[i - v[i] - 1]) v[i]++;
        if (i + v[i] > r) {
            c = i;
            r = i + v[i];
        }
        mx = max(mx, v[i]);
    }
    string ans;
    for (int i = 2; i < n - 1; i++) {
        if (v[i] == mx) {
            for (int j = (s[i - v[i]] == '#' ? i - v[i] + 1 : i - v[i]); j <= i + v[i]; j += 2) ans += s[j];
            cout << ans << '\n';
            break;
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1110
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
// https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation
 
int least_rotation(string s) {
    s += s;
    int n = s.size();
    vector<int> f(n, -1);
    int k = 0;
    for (int j = 1; j < n; j++) {
        int sj = s[j];
        int i = f[j - k - 1];
        while (i != -1 && sj != s[k + i + 1]) {
            if (sj < s[k + i + 1])
                k = j - i - 1;
            i = f[i];
        }
        if (sj != s[k + i + 1]) {
            if (sj < s[k])
                k = j;
            f[j - k] = -1;
        }
        else {
            f[j - k] = i + 1;
        }
    }
    return k;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    int st = least_rotation(s), n = s.size();
    for (int i = st; i < n; i++) cout << s[i];
    for (int i = 0; i < st; i++) cout << s[i];
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1099
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int t;
    cin >> t;
    while (t--) {
        int n, aux, ans = 0;
        cin >> n;
        for (int i = 0; i < n; i++) {
            cin >> aux;
            if (i&1) ans ^= aux;
        }
        cout << (ans ? "first\n" : "second\n");
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1098
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int t;
    cin >> t;
    while (t--) {
        int n, aux, ans = 0;
        cin >> n;
        for (int i = 0; i < n; i++) {
            cin >> aux;
            ans ^= (aux % 4);
        }
        cout << (ans ? "first\n" : "second\n");
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1203
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
vector<pii> v[MAXN];
vector<int> w[MAXN], sla[MAXN];
ll dist[MAXN];
int low[MAXN], nec[MAXN], cnt = 0, vis[MAXN], ja[MAXN], vis15[MAXN], vis2[MAXN];
 
void dfs(int node, int pai) {
	vis[node] = ++cnt;
	low[node] = cnt;
	int filhos = 0;
	for (int x : w[node]) {
		if (!vis[x]) {
			filhos++;
			dfs(x, node);
			low[node] = min(low[node], low[x]);
		}
		else if (x != pai) low[node] = min(low[node], vis[x]);
	}
	if (node == 1) nec[node] = (filhos > 1);
	else if (low[node] >= vis[pai] && pai > 1) nec[pai] = 1;
}
 
void dfs15(int node) {
    vis15[node] = 1;
    for (int x : sla[node]) {
        if (!vis15[x]) dfs15(x);
    }
}
 
void dfs2(int node) {
    vis2[node] = 1;
    for (auto x : v[node]) {
        if (dist[node] + x.second == dist[x.first]) {
            sla[x.first].push_back(node);
        }
        if (!vis2[x.first]) dfs2(x.first);
    }
}
 
void dijkstra(int n) {
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    priority_queue<pll, vector<pll>, greater<pll>> fila;
    fila.push({dist[1], 1});
    while (!fila.empty()) {
        pll at = fila.top();
        fila.pop();
        if (dist[at.second] < at.first) continue;
        for (auto x : v[at.second]) {
            if (dist[x.first] > at.first + x.second) {
                dist[x.first] = at.first + x.second;
                fila.push({dist[x.first], x.first});
            }
        }
    }
}
 
void dag(int node) {
    ja[node] = 1;
    for (auto x : v[node]) {
        if (dist[node] + x.second == dist[x.first] && vis15[x.first]) {
            w[x.first].push_back(node);
            w[node].push_back(x.first);
            sla[x.first].push_back(node);
        }
        if (!ja[x.first] && vis15[x.first]) dag(x.first);
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, a, b, c;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> a >> b >> c;
        v[a].emplace_back(b, c);
    }
    dijkstra(n);
    dfs2(1);
    dfs15(n);
    dag(1);
    dfs(1, -1);
    nec[1] = nec[n] = 1;
    int qtd = 0;
    for (int i = 1; i <= n; i++) qtd += nec[i];
    cout << qtd << '\n';
    for (int i = 1; i <= n; i++) {
        if (nec[i]) cout << i << ' ';
    }    
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1096
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
const int x = 6;
 
typedef vector<vector<ll>> matriz;
 
ll n;
 
matriz mult(matriz a, matriz b) {
	matriz c(x, vector<ll> (x));
	for (int i = 0; i < x; i++) {
		for (int j = 0; j < x; j++) {
			for (int k = 0; k < x; k++) {
				c[i][j] += (a[i][k] * b[k][j]) % M;
				if (c[i][j] >= M) c[i][j] -= M;
			}
		}
	}
	return c;
}
 
matriz expo(matriz a, ll e) {
	if (e == 1) return a;
	matriz ans = expo(a, e/2);
	ans = mult(ans, ans);
	if (e&1) ans = mult(ans, a);
	return ans;
}
 
int main () { _
	cin >> n;
	if (n <= 6) cout << (1<<(n-1)) << '\n';
	else {
		matriz m (6, vector<ll> (6));
		for (int i = 0; i < 6; i++) {
			if (i < 5) m[i][i+1] = 1;
			m[5][i] = 1;
		}
		m = expo(m, n-6);
		ll ans = 0;
		for (int i = 0; i < 6; i++) {
			ans += (m[5][i] * (1<<i)) % M;
			if (ans >= M) ans -= M;
		}
		cout << ans << '\n';
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1095
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 10010
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, int e) {
    ll resp = 1;
    while (e) {
        if (e&1) {
            resp = (resp * b) % M;
        }
        e = e >> 1;
        b = (b * b) % M;
    }
    return resp;
}
 
int main () { _
    int n;
    cin >> n;
    while(n--) {
        int a, b;
        cin >> a >> b;
        cout << fexp(a, b) << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1094
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
int main() { _
    int n, v[MAXN], atual = 0;
    cin >> n;
    lli resp = 0;
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        if (v[i] >= atual) atual = v[i];
        else resp += atual - v[i];
    }
    cout << resp << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1093
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, int e) {
    ll resp = 1;
    while (e) {
        if (e&1) resp = (resp * b) % M;
        b = (b * b) % M;
        e = (e >> 1);
    }
    return resp;
}
 
int main () { _
    int n;
    cin >> n;
    if ((n%4) && ((n+1)%4)) cout << "0\n";
    else {
        int meta = n*(n+1)/4;
        vector<ll> dp(meta+1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = meta; j >= 0; j--) {
                if (j+i <= meta) {
                    dp[j+i] += dp[j];
                    if (dp[j+i] >= M) dp[j+i] -= M;
                }
            }
        }
        cout << (dp[meta] * fexp(2, M-2)) % M << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1092
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
int main() { _
    int n;
    cin >> n;
    vector<int> v1, v2;
    if (n % 2 == 0) {
        if (n % 4 != 0) cout << "NO" << endl;
        else {
            for (int i = 1; i <= n/4; i++) {
                v1.push_back(i);
                v1.push_back(n-i+1);
            }
            for (int i = n/4 + 1; i <= n/2; i++) {
                v2.push_back(i);
                v2.push_back(n-i+1);
            }
            cout << "YES" << endl;
            cout << (int)v1.size() << endl;
            for (int i = 0; i < (int)v1.size(); i++) {
                cout << v1[i] << " ";
            }
            cout << endl << (int)v2.size() << endl;
            for (int i = 0; i < (int)v2.size(); i++) {
                cout << v2[i] << " ";
            }
            cout << endl;
        }
    }
    else {
        if ((n+1) % 4 != 0) cout << "NO" << endl;
        else {
            bool ber = true;
            for (int i = 1; i <= n; i++) {
                if (ber) v1.push_back(i);
                else v2.push_back(i);
                if (i%2 == 0) ber = 1 - ber;
            }
            cout << "YES" << endl;
            cout << (int)v1.size() << endl;
            for (int i = 0; i < (int)v1.size(); i++) {
                cout << v1[i] << " ";
            }
            cout << endl << (int)v2.size() << endl;
            for (int i = 0; i < (int)v2.size(); i++) {
                cout << v2[i] << " ";
            }
            cout << endl;
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1091
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n, m, aux;
	cin >> n >> m;
	multiset<int> s;
	for (int i = 0; i < n; i++) {
		cin >> aux;
		s.insert(-aux);
	}
	for (int i = 0; i < m; i++) {
		cin >> aux;
		auto it = s.begin();
		it = s.lower_bound(-aux);
		if (it == s.end()) cout << "-1\n";
		else {
			cout << -*it << '\n';
			s.erase(it);
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1090
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
 
pair<int, bool> p[MAXN];
 
int main () { _
    int n, x, resp = 0;
    cin >> n >> x;
    for (int i = 0; i < n; i++) {
        cin >> p[i].first;
    }
    sort(p, p+n);
    int j = n-1;
    for (int i = 0; i < n && !p[i].second; i++) {
        while (p[i].first + p[j].first > x and !p[i].second) {
            resp++;
            p[j].second = true;
            j--;
        }
        if (!p[i].second and !p[j].second) {
            resp++;
            p[i].second = true;
            p[j].second = true;
            j--;
        }
    }
    cout << resp << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1087
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int main () { _
	string s, resp;
	cin >> s;
	int tam = s.size();
	set<char> st;
	int ans = 0;
	for (int i = 0; i < tam; i++) {
		st.insert(s[i]);
		if ((int)st.size() == 4) {
			resp += s[i];
			ans++;
			st.clear();
		}
	}
	if (!st.count('A')) resp += 'A';
	else if (!st.count('C')) resp += 'C';
	else if (!st.count('G')) resp += 'G';
	else resp += 'T';
	cout << resp << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1668
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000
#define PB push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int n, m, id, resp[MAXN];
vector<int> viz[MAXN];
bool check[MAXN], ber;
 
void DFS(int node, int z) {
    check[node] = true;
    resp[node] = z+1;
    for (int i = 0; i < (int)viz[node].size(); i++) {
        int atual = viz[node][i];
        if (!check[atual]) DFS(atual, 1-z);
        else if (resp[atual] == resp[node]) ber = true;
    }
}
 
int main() { _
    int a, b;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        viz[a].PB(b);
        viz[b].PB(a);
    }
    id = 0;
    for (int i = 1; i <= n; i++) {
        if (!check[i]) {
            DFS(i, 0);
        }
    }
    if (!ber) {
        for (int i = 1; i <= n; i++) {
            cout << resp[i] << " ";
        }
        cout << endl;
    }
    else cout << "IMPOSSIBLE" << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1676
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 4000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int pai[MAXN], sz[MAXN], peso[MAXN], comp, maxi;
 
int find(int a) {
	if (pai[a] == a) return a;
	return pai[a] = find(pai[a]);
}
 
void join(int a, int b) {
	a = find(a);
	b = find(b);
	if (a == b) return;
	comp--;
	if (peso[a] > peso[b]) {
		pai[b] = a;
		sz[a] += sz[b];
	}
	if (peso[b] > peso[a]) {
		pai[a] = b;
		sz[b] += sz[a];
	}
	if (peso[a] == peso[b]) {
		pai[a] = b;
		sz[b] += sz[a];
		peso[b]++;
	}
	maxi = max({maxi, sz[a], sz[b]});
	return;
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		pai[i] = i;
		sz[i] = 1;
	}
	comp = n, maxi = 1;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		join(a, b);
		cout << comp << ' ' << maxi << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1675
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int pai[MAXN], peso[MAXN];
vector<pair<int, pii>> v;
 
int find(int a) {
	if (pai[a] == a) return a;
	return pai[a] = find(pai[a]);
}
 
void join(int a, int b) {
	a = find(a);
	b = find(b);
	if (a == b) return;
	if (peso[a] > peso[b]) {
		pai[b] = a;
	}
	if (peso[b] > peso[a]) {
		pai[a] = b;
	}
	if (peso[a] == peso[b]) {
		pai[a] = b;
		peso[b]++;
	}
	return;
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) pai[i] = i;
	for (int i = 0; i < m; i++) {
		int a, b, c;
		cin >> a >> b >> c;
		v.pb({c, {a, b}});
	}
	sort(v.begin(), v.end());
	ll ans = 0;
	int count = 0;
	for (int i = 0; i < m; i++) {
		if (find(v[i].S.F) != find(v[i].S.S)) {
			join(v[i].S.F, v[i].S.S);
			ans += v[i].F;
			count++;
		}
	}
	if (count == n-1) cout << ans << '\n';
	else cout << "IMPOSSIBLE\n";
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1674
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
vector<int> v[MAXN], dp(MAXN);
 
void dfs(int node) {
	for (int x : v[node]) {
		dfs(x);
		dp[node] += 1+dp[x];
	}
}
 
int main() { _
    int n, aux;
	cin >> n;
	for (int i = 2; i <= n; i++) {
		cin >> aux;
		v[aux].pb(i);
	}
	dfs(1);
	for (int i = 1; i <= n; i++) cout << dp[i] << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1673
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 5050
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
vector<array<int, 3>> v;
vector<int> u[MAXN], w[MAXN];
ll dist[MAXN];
int inv[MAXN], vis1[MAXN], vis2[MAXN];
 
void dfs1(int node) {
	vis1[node] = 1;
	for (int x : u[node]) 	
		if (!vis1[x]) dfs1(x);
}
 
void dfs2(int node) {
	vis2[node] = 1;
	for (int x : w[node]) 	
		if (!vis2[x]) dfs2(x);
}
 
int main() { _
	int n, m;
	cin >> n >> m;
	array<int, 3> a;
	for (int i = 0; i < m; i++) {
		cin >> a[0] >> a[1] >> a[2];
		a[2] = -a[2];
		v.pb(a);
		u[a[0]].pb(a[1]);
		w[a[1]].pb(a[0]);
	}
	for (int i = 2; i <= n; i++) dist[i] = INF;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			dist[v[j][1]] = min(dist[v[j][1]], dist[v[j][0]] + v[j][2]);
		}
	}
	for (int j = 0; j < m; j++) {
		if (dist[v[j][0]] + v[j][2] < dist[v[j][1]]) inv[v[j][1]] = 1;
	}
	bool ok = true;
	dfs1(1);
	dfs2(n);
	ll ans = -dist[n];
	for (int i = 1; i <= n; i++) {
		if (inv[i] && vis1[i] && vis2[i]) ok = 0;
	}
	if (!ok) ans = -1;
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1672
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 505
#define INF 1000000000000000LL
#define PB push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int n, m;
lli dist[MAXN][MAXN];
 
void FW() {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            for (int k = 1; k <= n; k++) {
                dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);
            }
        }
    }
}
 
int main () { _
    int a, b, q;
    lli c;
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            dist[i][j] = INF;
        }
    }
    for (int i = 0; i < m; i++) {
        cin >> a >> b >> c;
        dist[a][b] = dist[b][a] = min(dist[a][b], c);
    }
    for (int i = 1; i <= n; i++) dist[i][i] = 0;
    FW();
    for (int i = 0; i < q; i++) {
        cin >> a >> b;
        if (dist[a][b] == INF) cout << "-1" << endl;
        else cout << dist[a][b] << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1671
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000000000000LL
#define PB push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int n, m;
lli dist[MAXN];
vector<pair<lli, int>> viz[MAXN];
 
void dijkstra() {
    for (int i = 2; i <= n; i++) dist[i] = INF;
    dist[1] = 0LL;
    priority_queue <pair<lli, int>, vector<pair<lli, int>>, greater<pair<lli, int>>> fila;
    fila.push({dist[1], 1});
    while(!fila.empty()) {
        int atual = fila.top().S;
        lli d = fila.top().F;
        fila.pop();
        if (d > dist[atual]) continue;
        for (auto v : viz[atual]) {
            if (dist[v.S] > d + v.F) {
                dist[v.S] = d + v.F;
                fila.push({dist[v.S], v.S});
            }
        }
    }
}
 
int main () { _
    int a, b;
    lli c;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> a >> b >> c;
        viz[a].PB({c, b});
    }
    dijkstra();
    for (int i = 1; i <= n; i++) {
        cout << dist[i] << " ";
    }
    cout << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1670
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
const int N = 381367045;
 
bitset<N> vis;
int pwr[10];
 
int h(int atual, int pos) {
	if (pos == 2 || pos == 5) return 0;
	int ini = atual;
	int p0, p1, cnt = 0;
	while (cnt <= pos) {
		if (cnt == pos) p0 = atual % 9;
		atual /= 9;
		cnt++;
	}
	p1 = atual % 9;
	return ini - pwr[pos] * p0 - pwr[pos+1] * p1 + pwr[pos] * p1 + pwr[pos+1] * p0;
}
 
int v(int atual, int pos) {
	if (pos >= 6) return 0;
	int ini = atual;
	int p0, p1, cnt = 0;
	while (cnt <= pos+2) {
		if (cnt == pos) p0 = atual % 9;
		atual /= 9;
		cnt++;
	}
	p1 = atual % 9;
	return ini - pwr[pos] * p0 - pwr[pos+3] * p1 + pwr[pos] * p1 + pwr[pos+3] * p0;
}
 
int main () { _
	pwr[0] = 1;
	for (int i = 1; i < 10; i++) pwr[i] = 9 * pwr[i-1];
	int start = 0, aux, meta = 0;
	for (int i = 0; i < 9; i++) {
		cin >> aux;
		start += pwr[i] * (aux % 9);
		meta += pwr[i] * ((i+1) % 9);
	}
	v(start, 5);
	queue<pii> fila;
	fila.push({start, 0});
	vis[0] = 1;
	vis[start] = 1;
	int ans = -1, hor, ver;
	while (!fila.empty()) {
		pii atual = fila.front();
		fila.pop();
		if (atual.F == meta) {
			ans = atual.S;
			break;
		}
		for (int i = 0; i < 8; i++) {
			hor = h(atual.F, i), ver = v(atual.F, i);
			if (!vis[hor]) {
				vis[hor] = 1;
				fila.push({hor, atual.S+1});
			}
			if (!vis[ver]) {
				vis[ver] = 1;
				fila.push({ver, atual.S+1});
			}
		}
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1669
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000
#define PB push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int n, m, go[MAXN], inicio;
vector<int> viz[MAXN], resp;
bool check[MAXN], ber;
 
void DFS(int node, int pai) {
    check[node] = true;
    for (int i = 0; i < (int)viz[node].size(); i++) {
        int atual = viz[node][i];
        if (!check[atual]) {
            if (!ber) go[atual] = node;
            DFS(atual, node);
        }
        else if (atual != pai and !ber) {
            ber = true;
            inicio = atual;
            go[atual] = node;
        }
    }
}
 
int main() { _
    int a, b;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        viz[a].PB(b);
        viz[b].PB(a);
    }
    for (int i = 1; i <= n; i++) {
        if (!check[i]) {
            resp.PB(i);
            DFS(i, 0);
        }
        if (ber) break;
    }
    if (ber) {
        stack<int> ans;
        ans.push(inicio);
        int atual = go[inicio];
        while (atual != inicio) {
            ans.push(atual);
            atual = go[atual];
        }
        ans.push(atual);
        cout << (int)ans.size() << endl;
        while (!ans.empty()) {
            cout << ans.top() << " ";
            ans.pop();
        }
        cout << endl;
    }
    else cout << "IMPOSSIBLE" << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1677
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
vector<int> v[MAXN];
int pai[MAXN], peso[MAXN], vis[MAXN];
set<pii> inv;
vector<pii> edg;
 
int find(int x) {
	if (pai[x] == x) return x;
	else return pai[x] = find(pai[x]);
}
 
void join(int a, int b) {
	a = find(a), b = find(b);
	if (a == b) return;
	if (peso[a] > peso[b]) 
		pai[b] = a;
	else if (peso[b] > peso[a])
		pai[a] = b;
	else {
		peso[a]++;
		pai[b] = a;
	}
}
 
void dfs(int node, int pai) {
	vis[node] = 1;
	for (int x : v[node]) {
		if (!inv.count({x, node}) && !inv.count({node, x}) && !vis[x]) {
			dfs(x, node);
			join(node, x);
		}
	}
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m, k;
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) pai[i] = i; 
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	for (int i = 0; i < k; i++) {
		int a, b;
		cin >> a >> b;
		inv.insert({a, b});
		edg.emplace_back(a, b);
	}
	vector<int> resp;
	int comps = 0;
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			dfs(i, 0);
			comps++;
		}
	}
	resp.push_back(comps);
	for (int i = (int)edg.size()-1; i > 0; i--) {
		if (find(edg[i].first) != find(edg[i].second)) {
			comps--;
			join(edg[i].first, edg[i].second);
		}
		resp.push_back(comps);
	}
	reverse(resp.begin(), resp.end());
	for (int x : resp) cout << x << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1667
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000
#define PB push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int n, m, dist[MAXN], go[MAXN];
vector<int> vizinhos[MAXN];
 
void dijkstra() {
    for (int i = 2; i <= n; i++) dist[i] = INF;
    priority_queue<pii, vector<pii>, greater<pii>> fila;
    dist[1] = 1;
    fila.push({dist[1], 1});
    while (!fila.empty()) {
        int atual = fila.top().S;
        int d = fila.top().F;
        fila.pop();
        if (d > dist[atual]) continue;
        for (int i = 0; i < (int)vizinhos[atual].size(); i++) {
            int prox = vizinhos[atual][i];
            if (dist[prox] > 1 + dist[atual]) {
                dist[prox] = 1 + dist[atual];
                fila.push({dist[prox], prox});
                go[prox] = atual;
            }
        }
    }
}
 
int main() { _
    int a, b;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        vizinhos[a].PB(b);
        vizinhos[b].PB(a);
    }
    dijkstra();
    if (dist[n] == INF) cout << "IMPOSSIBLE" << endl;
    else {
        cout << dist[n] << endl;
        int atual = n;
        stack<int> ans;
        ans.push(atual);
        while (atual != 1) {
            ans.push(go[atual]);
            atual = go[atual];
        }
        while (!ans.empty()) {
            cout << ans.top() << " ";
            ans.pop();
        }
        cout << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1666
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int pai[MAXN], n, m;
bool check[MAXN];
vector<int> resp;
 
int find(int x) {
    if (pai[x] == x) return x;
    return pai[x] = find(pai[x]);
}
 
void join(int a, int b) {
    int pai1 = find(a);
    int pai2 = find(b);
 
    if (pai1 == pai2) return;
    if (pai1 == 1) {
        pai[pai2] = pai1;
    }
    else pai[pai1] = pai2;
}
 
int main() { _
    int resp = 0;
    queue<pii> ans;
    cin >> n >> m;
    int a, b;
    for (int i = 1; i <= n; i++) {
        pai[i] = i;
    }
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        join(a, b);
    }
    int conec = 1;
    for (int i = 2; i <= n; i++) {
        if (find(i) != conec) {
            resp++;
            ans.push({1, i});
            join(1, i);
        }
    }
    cout << resp << endl;
    while(!ans.empty()) {
        cout << ans.front().first << " " << ans.front().second << endl;
        ans.pop();
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1165
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
int dp1[105][10010], dp2[105][10010], v[105];
 
int add(int a, int b) {
    if (a + b >= MOD)
        return a + b - MOD;
    if (a + b < 0)
        return a + b + MOD;
    return a + b;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, x;
    cin >> n >> x;
    for (int i = 1; i <= n; i++) cin >> v[i];
    sort(v + 1, v + n + 1);
    // dp1 receives from dp2
    dp2[0][5000] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= i; j++) {
            for (int k = 0; k <= 10000; k++) {
                dp1[j][k] = add(dp1[j][k], (1ll * dp2[j][k] * (j+1)) % MOD);
                if (k + v[i] <= 10000 && j) 
                    dp1[j][k] = add(dp1[j][k], dp2[j-1][k + v[i]]);
                if (k - v[i] >= 0)
                    dp1[j][k] = add(dp1[j][k], (1ll * dp2[j+1][k-v[i]] * (j+1)) % MOD);
            }
        }
        for (int j = 0; j <= i; j++) {
            for (int k = 0; k <= 5000 + x; k++) {
                dp2[j][k] = dp1[j][k];
                dp1[j][k] = 0;
            }
        }
    }
    int ans = 0;
    for (int i = 5000; i <= 10000; i++) 
        ans = add(ans, dp2[0][i]);
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1664
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
int st[(int) 1e6 + 5], to[20][MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, q;
    cin >> n >> q;
    vector<pii> v(n + 1);
    for (int i = 0; i < n; i++) {
        cin >> v[i].second >> v[i].first;
    }
    v[n] = {1e6 + 1, 1e6 + 1};
    sort(v.begin(), v.end());
    int at = 0;
    for (int i = 0; i <= n; i++) {
        if (v[i].second >= at) {
            for (int j = at; j <= v[i].second; j++) st[j] = i;
            at = v[i].second + 1;
        }
    }
    for (int i = 0; i <= n; i++) {
        to[0][i] = st[v[i].first];
    }
    for (int i = 1; i < 20; i++) {
        for (int j = 0; j <= n; j++) to[i][j] = to[i - 1][to[i - 1][j]];
    }
    int a, b;
    for (int i = 0; i < q; i++) {
        cin >> a >> b;
        at = st[a];
        int ans = (v[at].first <= b);
        for (int j = 19; j >= 0; j--) {
            if (v[to[j][at]].first <= b) {
                ans += (1 << j);
                at = to[j][at];
            }
        }
        
        cout << ans << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1662
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n;
	cin >> n;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	map<int, int> mp;
	ll soma = 0, resp = 0;
	mp[0] = 1;
	for (int i = 0; i < n; i++) {
		soma = (soma + v[i]) % n;
		if (soma < 0) soma += n;
		resp += mp[soma % n];
		mp[soma % n]++;
	}
	cout << resp << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1661
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n, x;
	cin >> n >> x;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	if (!x) cout << 1ll * n * (n+1) / 2 << '\n';
	else {
		map<ll, ll> mapa;
		mapa[0] = 1;
		ll soma = 0, resp = 0;
		for (int i = 0; i < n; i++) {
			soma += v[i];
			mapa[soma]++;
			resp += mapa[soma - x];
		}
		cout << resp << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1660
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n, x;
	cin >> n >> x;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	ll soma = 0, r = 0, resp = 0;
	for (int l = 0; l < n; l++) {
		while (r < n && soma < x) {
			soma += v[r];
			r++;
		}
		if (soma == x) resp++;
		soma -= v[l];
	}
	cout << resp << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1655
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int trie[6000100][2], quant[6000100], cnt = 0;
 
void insert(int x) {
	int no = 0;
	for (int i = 30; i >= 0; i--) {
		quant[no]++;
		if (quant[no] == 1) {
			trie[no][0] = ++cnt;
			trie[no][1] = ++cnt;
		}
		no = trie[no][(x & (1<<i) ? 1 : 0)];
	}
	quant[no]++;
}
 
int query(int x) {
	int no = 0, resp = 0;
	for (int i = 30; i >= 0; i--) {
		if (quant[trie[no][(x & (1<<i) ? 0 : 1)]]) {
			resp += (x & (1<<i) ? 0 : 1) * (1<<i);
			no = trie[no][(x & (1<<i) ? 0 : 1)];
		}
		else {
			resp += (x & (1<<i) ? 1 : 0) * (1<<i);
			no = trie[no][(x & (1<<i) ? 1 : 0)];
		}
	}
	return resp;
}
 
int main () { _
	int n;
	cin >> n;
	int ans = 0, atual = 0, aux;
	insert(0);
	for (int i = 0; i < n; i++) {
		cin >> aux;
		atual ^= aux;
		ans = max(ans, query(atual) ^ atual);
		insert(atual);
	}	
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1687
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int tab[MAXN][25];
vector<int> v[MAXN];
 
void dfs(int node) {
	for (int i = 1; i < 20; i++) {
		tab[node][i] = tab[tab[node][i-1]][i-1];
	}
	for (int x : v[node]) {
		dfs(x);
	}
}
 
int main () { _
	memset(tab, 0, sizeof(tab));
	int n, q;
	cin >> n >> q;
	for (int i = 2; i <= n; i++) {
		cin >> tab[i][0];
		v[tab[i][0]].pb(i);
	}
	dfs(1);
	for (int i = 0; i < q; i++) {
		int x, k;
		cin >> x >> k;
		for (int j = 0; j < 20; j++) {
			if (k & (1<<j)) x = tab[x][j];
		}
		cout << (!x ? -1 : x) << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1695
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int n;
int vis[505];
vector<vector<int>> residualGraph;
 
// Finds if more flow can be sent from source to sink.
// Also assigns levels to nodes.
bool bfs(vector<vector<int>>& residualGraph, vector<int>& level, int source, int sink)
{
    fill(level.begin(), level.end(), -1);
	level[source] = 0;
	
	queue<int> q;
	q.push(source);
 
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		for (int v=0; v < n; v++)
		{
			if (u != v && residualGraph[u][v] > 0 && level[v] < 0)
			{
				// Level of current vertex is level of parent + 1
				level[v] = level[u] + 1;
				q.push(v);
			}
		}
	}
	// IF we can not reach to the sink we
	// return false else true
	return level[sink] < 0 ? false : true ;
}
 
// A DFS based function to send flow after BFS has figured out that there is a possible flow and
// constructed levels. This function called multiple times for a single call of BFS.
// flow : Current flow send by parent function call
// count[] : count of edges explored from i.
// u : Current vertex
int sendFlow(vector<vector<int>>& residualGraph, vector<int>& level, vector<int>& count, int u, int sink, int flow)
{
	// Sink reached
	if (u == sink)
		return flow;
 
    if (count[u] == (int)residualGraph[u].size())
	    return 0;
 
	// Traverse all adjacent edges one-by-one.
	for (int v=0; v < n; v++)
	{
		if (residualGraph[u][v] > 0)
		{
		    count[u]++;
			if (level[v] == level[u]+1)
			{
                // find minimum flow from u to sink
			 	int curr_flow = min(flow, residualGraph[u][v]);
 
			    int min_cap = sendFlow(residualGraph, level, count, v, sink, curr_flow);
			    if (min_cap > 0)
			    {
                    residualGraph[u][v] -= min_cap;
                    residualGraph[v][u] += min_cap;
				    return min_cap;
			    }
			}
		}
	}
	return 0;
}
 
int dinic_algorithm(vector<vector<int>>& graph, int source, int sink)
{
	if (source == sink)
		return -1;
 
	int max_flow = 0;
    residualGraph = graph;
    vector<int> level(n, -1);
 
	// Augment the flow while there is path from source to sink
	while (bfs(residualGraph, level, source, sink) == true)
	{
		// store how many neighbors are visited
		vector<int> count(n, 0);
 
		// while flow is not zero in graph from source to sink
		while (int flow = sendFlow(residualGraph, level, count, source, sink, INT_MAX))
			max_flow += flow;
	}
	return max_flow;
}
 
void addEdge(vector<vector<int>>& graph,
             int u, int v, int w)
{
    graph[u][v] = w;
	graph[v][u] = w;
}
 
int main() {
	int m;
	cin >> n >> m;
    vector<vector<int>> graph(n, vector<int> (n, 0));
	vector<pii> edg;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		a--, b--;
		addEdge(graph, a, b, 1);
		edg.pb({a, b});
	}
	cout << dinic_algorithm(graph, 0, n-1) << '\n';
	memset(vis, -1, sizeof(vis));
	vis[0] = 1;
	queue<int> fila;
	fila.push(0);
	while (!fila.empty()) {
		int atual = fila.front();
		fila.pop();
		for (int i = 1; i < n; i++) {
			if (vis[i] == -1 && residualGraph[atual][i] > 0) {
				vis[i] = 1;
				fila.push(i);
			}
		}
	}
	for (pii x : edg) {
		if (vis[x.F] == 1 &&  vis[x.S] == -1) cout << x.F+1 << ' ' << x.S+1 << '\n';
		else if (vis[x.S] == 1 && vis[x.F] == -1) cout << x.S+1 << ' ' << x.F+1 << '\n';
	}
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1694
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include<bits/stdc++.h>
using namespace std;
#define int long long
 
// A structure to represent a edge between
// two vertex
struct Edge
{
    int v ;  // Vertex v (or "to" vertex)
             // of a directed edge u-v. "From"
             // vertex u can be obtained using
             // index in adjacent array.
 
    int flow ; // flow of data in edge
 
    int C;    // capacity
 
    int rev ; // To store index of reverse
              // edge in adjacency list so that
              // we can quickly find it.
};
 
// Residual Graph
class Graph
{
    int V; // number of vertex
    int *level ; // stores level of a node
    vector< Edge > *adj;
public :
    Graph(int V)
    {
        adj = new vector<Edge>[V];
        this->V = V;
        level = new int[V];
    }
 
    // add edge to the graph
    void addEdge(int u, int v, int C)
    {
        // Forward edge : 0 flow and C capacity
        Edge a{v, 0, C, adj[v].size()};
 
        // Back edge : 0 flow and 0 capacity
        Edge b{u, 0, 0, adj[u].size()};
 
        adj[u].push_back(a);
        adj[v].push_back(b); // reverse edge
    }
 
    bool BFS(int s, int t);
    int sendFlow(int s, int flow, int t, int ptr[]);
    int DinicMaxflow(int s, int t);
};
 
// Finds if more flow can be sent from s to t.
// Also assigns levels to nodes.
bool Graph::BFS(int s, int t)
{
    for (int i = 0 ; i < V ; i++)
        level[i] = -1;
 
    level[s] = 0;  // Level of source vertex
 
    // Create a queue, enqueue source vertex
    // and mark source vertex as visited here
    // level[] array works as visited array also.
    list< int > q;
    q.push_back(s);
 
    vector<Edge>::iterator i ;
    while (!q.empty())
    {
        int u = q.front();
        q.pop_front();
        for (i = adj[u].begin(); i != adj[u].end(); i++)
        {
            Edge &e = *i;
            if (level[e.v] < 0  && e.flow < e.C)
            {
                // Level of current vertex is,
                // level of parent + 1
                level[e.v] = level[u] + 1;
 
                q.push_back(e.v);
            }
        }
    }
 
    // IF we can not reach to the sink we
    // return false else true
    return level[t] < 0 ? false : true ;
}
 
// A DFS based function to send flow after BFS has
// figured out that there is a possible flow and
// constructed levels. This function called multiple
// times for a single call of BFS.
// flow : Current flow send by parent function call
// start[] : To keep track of next edge to be explored.
//           start[i] stores  count of edges explored
//           from i.
//  u : Current vertex
//  t : Sink
int Graph::sendFlow(int u, int flow, int t, int start[])
{
    // Sink reached
    if (u == t)
        return flow;
 
    // Traverse all adjacent edges one -by - one.
    for (  ; start[u] < adj[u].size(); start[u]++)
    {
        // Pick next edge from adjacency list of u
        Edge &e = adj[u][start[u]];
                                     
        if (level[e.v] == level[u]+1 && e.flow < e.C)
        {
            // find minimum flow from u to t
            int curr_flow = min(flow, e.C - e.flow);
 
            int temp_flow = sendFlow(e.v, curr_flow, t, start);
 
            // flow is greater than zero
            if (temp_flow > 0)
            {
                // add flow  to current edge
                e.flow += temp_flow;
 
                // subtract flow from reverse edge
                // of current edge
                adj[e.v][e.rev].flow -= temp_flow;
                return temp_flow;
            }
        }
    }
 
    return 0;
}
 
// Returns maximum flow in graph
int Graph::DinicMaxflow(int s, int t)
{
    // Corner case
    if (s == t)
        return -1;
 
    int total = 0;  // Initialize result
 
    // Augment the flow while there is path
    // from source to sink
    while (BFS(s, t) == true)
    {
        // store how many edges are visited
        // from V { 0 to V }
        int *start = new int[V+1] {0};
 
        // while flow is not zero in graph from S to D
        while (int flow = sendFlow(s, INT_MAX, t, start))
 
            // Add path flow to overall flow
            total += flow;
    }
 
    // return maximum flow
    return total;
}
 
// Driver Code
int32_t main() {
	int n, m;
	cin >> n >> m;
    Graph g(n);
    for (int i = 0; i < m; i++) {
		int a, b, c;
		cin >> a >> b >> c;
		a--, b--;
		g.addEdge(a, b, c);
	}
    cout << g.DinicMaxflow(0, n-1) << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1693
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 4000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
stack<int> ans;
vector<pii> v[MAXN];
int grau[MAXN], num[MAXN], edge[MAXN];
 
void euler(int node) {
	stack<int> path;
	path.push(node);
	while (!path.empty()) {
		int cur = path.top();
		if (!num[cur]) {
			ans.push(cur);
			path.pop();
		}
		else {
			pii next = v[cur].back();
			v[cur].pop_back();
			num[cur]--;
			edge[next.S] = 1;
			path.push(next.F);
		}
	}
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb({b, i});
		grau[a]++;
		grau[b]--;
		num[a]++;
	}
	bool valid = (grau[1] == 1 && grau[n] == -1);
	for (int i = 2; i < n; i++) valid &= (grau[i] == 0);
	if (!valid) cout << "IMPOSSIBLE\n";
	else {
		euler(1);
		for (int i = 0; i < m; i++) valid &= edge[i];
		if (!valid) cout << "IMPOSSIBLE\n";
		else {
			while (!ans.empty()) {
				cout << ans.top() << ' ';
				ans.pop();
			}
			cout << '\n';
		}
	}
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1692
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 4000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN];
string ans;
int grau[MAXN], n, start = -1;
 
void euler(int node) {
	stack<pair<int, char>> path;
	path.push({node, ' '});
	while (!path.empty()) {
		pair<int, char> cur = path.top();
		if (!grau[cur.F]) {
			if (start == -1) start = cur.F;
			ans += cur.S;
			path.pop();
		}
		else {
			int next = v[cur.F].back();
			v[cur.F].pop_back();
			path.push({next, (next&1 ? '1' : '0')});
			grau[cur.F]--;
		}
	}
}
 
int main () { _
	cin >> n;
	for (int i = 0; i < (1<<(n-1)); i++) {
		int next = i<<1 & ((1<<(n-1)) - 1);
		v[i].pb(next);
		v[i].pb(next+1);
		grau[i] = 2;
	}
	euler(0);
	ans.pop_back();
	for (int i = 0; i < n-1; i++) {
		ans += (start & (1 << i) ? '1' : '0');
	}
	cout << ans << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1691
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 4000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
stack<int> ans;
vector<pii> v[MAXN];
int grau[MAXN], edge[MAXN];
 
void euler(int node) {
	stack<int> path;
	path.push(node);
	while (!path.empty()) {
		int cur = path.top();
		while (!v[cur].empty() && edge[v[cur].back().S]) {
			grau[cur]--;
			v[cur].pop_back();
		}
		if (!grau[cur]) {
			ans.push(cur);
			path.pop();
			continue;
		}
		pii next = v[cur].back();
		v[cur].pop_back();
		grau[cur]--;
		edge[next.S] = 1;
		path.push(next.F);
	}
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb({b, i});
		v[b].pb({a, i});
		grau[a]++, grau[b]++;
	}
	bool ok = true;
	for (int i = 1; i <= n; i++) {
		ok &= (grau[i] % 2 == 0);
	}
	if (!ok) cout << "IMPOSSIBLE\n";
	else {
		euler(1);
		for (int i = 0; i < m; i++) {
			ok &= edge[i];
		}
		if (!ok) cout << "IMPOSSIBLE\n";
		else {
			while (!ans.empty()) {
				cout << ans.top() << ' ';
				ans.pop();
			}
			cout << '\n';
		}
	}
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1690
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 4000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int mat[25][25], dp[1100000][25];
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		mat[a][b]++;
	}
	dp[1][1] = 1;
	for (int i = 1; i < (1<<n); i++) {
		for (int j = 1; j <= n; j++) {
			if (dp[i][j]) {
				for (int k = 0; k < n; k++) {
					if (!(i & (1<<k)) && mat[j][k+1]) {
						dp[i ^ (1<<k)][k+1] += (1ll* dp[i][j] * mat[j][k+1]) % M;
						if (dp[i ^ (1<<k)][k+1] >= M) dp[i ^ (1<<k)][k+1] -= M;
					}
				}
			}
		}
	}
	cout << dp[(1<<n) - 1][n] << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1689
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 4000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int dx[8] = {2, 2, -2, -2, 1, -1, 1, -1}, dy[8] = {1, -1, 1, -1, 2, 2, -2, -2};
int mat[10][10];
 
bool valid(int x, int y) { return (x >= 0 && y >= 0 && x < 8 && y < 8 && !mat[x][y]); }
 
int count(int x, int y) {
	int resp = 0;
	for (int i = 0; i < 8; i++) {
		resp += valid(x+dx[i], y+dy[i]);
	}
	return resp;
}
 
bool dfs(int x, int y, int pos) {
	if (pos == 64) return true;
	vector<pair<int, pii>> v;
	for (int i = 0; i < 8; i++) {
		if (valid(x+dx[i], y+dy[i])) {
			v.pb({count(x+dx[i], y+dy[i]), {x+dx[i], y+dy[i]}});
		}
	}
	sort(v.begin(), v.end());
	for (int i = 0; i < (int)v.size(); i++) {
		mat[v[i].S.F][v[i].S.S] = pos+1;
		if (dfs(v[i].S.F, v[i].S.S, pos+1)) return true;
		mat[v[i].S.F][v[i].S.S] = 0;
	}
	return false;
}
 
int main () { _
	int x, y;
	cin >> x >> y;
	x--, y--;
	mat[y][x] = 1;
	dfs(y, x, 1);
	for (int i = 0; i < 8; i++) {
		for (int j = 0; j < 8; j++) {
			cout << mat[i][j] << ' ';
		}
		cout << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1688
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int tab[MAXN][25], nivel[MAXN];
vector<int> v[MAXN];
 
int lca(int a, int b) {
	if (nivel[a] < nivel[b]) swap(a, b);
	for (int i = 19; i >= 0; i--) {
		if (nivel[a] - nivel[b] >= (1<<i)) {
			a = tab[a][i];
		}
	}
	if (a == b) return a;
	for (int i = 19; i >= 0; i--) {
		if (tab[a][i] != tab[b][i]) {
			a = tab[a][i];
			b = tab[b][i];
		}
	}
	return tab[a][0];
}
 
void dfs(int node) {
	for (int i = 1; i < 20; i++) {
		tab[node][i] = tab[tab[node][i-1]][i-1];
	}
	for (int x : v[node]) {
		nivel[x] = nivel[node]+1;
		dfs(x);
	}
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 2; i <= n; i++) {
		cin >> tab[i][0];
		v[tab[i][0]].pb(i);
	}
	nivel[1] = 1;
	dfs(1);
	for (int i = 0; i < q; i++) {
		int a, b;
		cin >> a >> b;
		cout << lca(a, b) << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1654
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1<<20;
const ll INF = 2e18;
 
int v[200100], dp1[MAXN], dp2[MAXN], c[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> v[i];
		dp1[v[i]]++;
		dp2[v[i]]++;
		c[v[i]] = (v[i] ^ ((1<<20)-1));
	}
	for (int i = 0; i <= 19; i++) {
		for (int j = (1<<20)-1; j >= 0; j--) {
			if (j & (1<<i)) {
				dp1[j] += dp1[j ^ (1<<i)];
			}
		}
		for (int j = 0; j <= 1e6; j++) {
			if (!(j & (1<<i)) && (j ^ (1<<i)) <= 1e6) {
                dp2[j] += dp2[j ^ (1<<i)];
            }
		}
	}
	for (int i = 0; i < n; i++) {
		cout << dp1[v[i]] << ' ' << dp2[v[i]] << ' ' << n - dp1[c[v[i]]] << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1686
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int vis[MAXN], comp[MAXN], cnt = 0;
ll c1[MAXN], c2[MAXN], dp[MAXN], ans = 0;
vector<int> v[MAXN], w[MAXN], nv[MAXN], ord;
 
void dfs1(int node) {
	vis[node] = 1;
	for (int x : v[node]) 
		if (!vis[x]) dfs1(x);
	ord.pb(node);
}
 
void dfs2(int node) {
	vis[node] = 1;
	c2[cnt] += c1[node];
	comp[node] = cnt;
	for (int x : w[node])
		if (!vis[x]) dfs2(x);
}
 
void dfs3(int node) {
	vis[node] = 1;
	dp[node] = c2[node];
	for (int x : nv[node]) {
		if (!vis[x]) dfs3(x);
		dp[node] = max(dp[x] + c2[node], dp[node]);
	}
	ans = max(ans, dp[node]);
}
 
int main () { _
	int n, m, a, b;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> c1[i];
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].pb(b);
		w[b].pb(a);
	}
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) dfs1(i);
	}
	memset(vis, 0, sizeof(vis));
	reverse(ord.begin(), ord.end());
	for (int x : ord) {
		if (!vis[x]) {
			cnt++;
			dfs2(x);
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int x : v[i]) {
			if (comp[x] != comp[i]) nv[comp[i]].pb(comp[x]);
		}
	}
	memset(vis, 0, sizeof(vis));
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) dfs3(i);
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1684
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
vector<int> v[MAXN], w[MAXN], ord, c[MAXN];
int vis[MAXN], cnt = 0, cmp[MAXN], ans[MAXN];
 
void dfs1(int node) {
	vis[node] = 1;
	for (int x : v[node])
		if (!vis[x]) dfs1(x);
	ord.pb(node);
}
 
void dfs2(int node) {
	cmp[node] = cnt;
	c[cnt].pb(node);
	vis[node] = 1;
	for (int x : w[node])
		if (!vis[x]) dfs2(x);
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		char a1, a2;
		int aux1, aux2;
		cin >> a1 >> aux1 >> a2 >> aux2;
		if (a1 == '+' && a2 == '+') {
			v[2*aux1+1].pb(2*aux2);
			v[2*aux2+1].pb(2*aux1);
			w[2*aux2].pb(2*aux1+1);
			w[2*aux1].pb(2*aux2+1);
		}
		else if (a1 == '+' && a2 == '-') {
			v[2*aux1+1].pb(2*aux2+1);
			v[2*aux2].pb(2*aux1);
			w[2*aux2+1].pb(2*aux1+1);
			w[2*aux1].pb(2*aux2);
		}
		else if (a1 == '-' && a2 == '+') {
			v[2*aux1].pb(2*aux2);
			v[2*aux2+1].pb(2*aux1+1);
			w[2*aux2].pb(2*aux1);
			w[2*aux1+1].pb(2*aux2+1);
		}
		else if (a1 == '-' && a2 == '-') {
			v[2*aux1].pb(2*aux2+1);
			v[2*aux2].pb(2*aux1+1);
			w[2*aux2+1].pb(2*aux1);
			w[2*aux1+1].pb(2*aux2);
		}
	}
	for (int i = 2; i <= 2*m+1; i++) 
		if (!vis[i]) dfs1(i);
	reverse(ord.begin(), ord.end());
	memset(vis, 0, sizeof(vis));
	for (int x : ord) {
		if (!vis[x]) {
			cnt++;
			dfs2(x);
		}
	}
	bool ok = true;
	for (int i = 2; i <= 2*m; i+=2) {
		if (cmp[i] == cmp[i+1]) ok = false;
		ans[i/2] = (cmp[i] > cmp[i+1]);
	}
	if (!ok) cout << "IMPOSSIBLE\n";
	else {
		for (int i = 1; i <= m; i++) cout << (ans[i] ? '+' : '-') << ' ';
		cout << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1683
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int vis[MAXN], cnt = 0, c[MAXN];
vector<int> v[MAXN], w[MAXN], ord;
 
void dfs1(int node) {
	vis[node] = 1;
	for (int x : v[node]) 
		if (!vis[x]) dfs1(x);
	ord.pb(node);
}
 
void dfs2(int node) {
	vis[node] = 1;
	c[node] = cnt;
	for (int x : w[node])
		if (!vis[x]) dfs2(x);
}
 
int main () { _
	int n, m, a, b;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].pb(b);
		w[b].pb(a);
	}
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) dfs1(i);
	}
	memset(vis, 0, sizeof(vis));
	reverse(ord.begin(), ord.end());
	for (int x : ord) {
		if (!vis[x]) {
			cnt++;
			dfs2(x);
		}
	}
	cout << cnt << '\n';
	for (int i = 1; i <= n; i++) cout << c[i] << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1682
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int vis[MAXN], cnt = 0;
vector<int> v[MAXN], w[MAXN], ord, c[MAXN];
 
void dfs1(int node) {
	vis[node] = 1;
	for (int x : v[node]) 
		if (!vis[x]) dfs1(x);
	ord.pb(node);
}
 
void dfs2(int node) {
	vis[node] = 1;
	c[cnt].pb(node);
	for (int x : w[node])
		if (!vis[x]) dfs2(x);
}
 
int main () { _
	int n, m, a, b;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].pb(b);
		w[b].pb(a);
	}
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) dfs1(i);
	}
	memset(vis, 0, sizeof(vis));
	reverse(ord.begin(), ord.end());
	for (int x : ord) {
		if (!vis[x]) {
			cnt++;
			dfs2(x);
		}
	}
	if (cnt == 1) cout << "YES\n";
	else {
		cout << "NO\n";
		cout << c[2][0] << ' ' << c[1][0] << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1681
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int dp[MAXN], check[MAXN];
vector<int> v[MAXN];
 
void dfs(int node) {
    for (int x : v[node]) {
        if (!check[x]) dfs(x);
        check[x] = 1;
        dp[node] += dp[x];
        if (dp[node] >= M) dp[node] -= M;
    }
}
 
int main () { _
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        v[a].pb(b);
    }
    dp[n] = 1;
    dfs(1);
    cout << dp[1] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1680
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int dp[MAXN], check[MAXN], go[MAXN], n;
vector<int> v[MAXN];
 
void dfs(int node) {
    dp[node] = (node == n ? 0 : -1e6);
    for (int x : v[node]) {
        if (!check[x]) dfs(x);
        check[x] = 1;
        if (dp[x] >= dp[node]) {
            dp[node] = 1 + dp[x];
            go[node] = x;
        }
    }
}
 
int main () { _
    int m;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        v[a].pb(b);
    }
    dfs(1);
    if (dp[1] < 0) cout << "IMPOSSIBLE\n";
    else {
        cout << dp[1] + 1 << '\n';
        cout << "1 ";
        int atual = go[1];
        while (atual != 0) {
            cout << atual << ' ';
            atual = go[atual];
        }
        cout << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1679
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN], ans;
bool valid = true;
int cor[MAXN];
 
void dfs(int node) {
	cor[node] = 1;
	for (int x : v[node]) {
		if (cor[x] == 1) {
			valid = false;
			return;
		}
		if (!cor[x]) dfs(x);
	}
	cor[node] = 2;
	ans.pb(node);
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
	}
	for (int i = 1; i <= n && valid; i++) {
		if (!cor[i]) {
			dfs(i);
		}
	}
	if (!valid) cout << "IMPOSSIBLE\n";
	else {
		reverse(ans.begin(), ans.end());
		for (int x : ans) cout << x << ' ';
		cout << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1678
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN];
stack<int> ans;
int valid;
int cor[MAXN], go[MAXN];
 
void dfs(int node) {
	cor[node] = 1;
	for (int x : v[node]) {
		if (cor[x] == 1 && ans.empty()) {
			int ini = x;
			valid = node;
			ans.push(x);
			while (valid != ini) {
				ans.push(valid);
				valid = go[valid];
			}
			ans.push(valid);
		}
		if (!cor[x]) {
			go[x] = node;
			dfs(x);
		}
	}
	cor[node] = 2;
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
	}
	for (int i = 1; i <= n && !valid; i++) {
		if (!cor[i]) {
			dfs(i);
		}
	}
	if (!valid) cout << "IMPOSSIBLE\n";
	else {
		cout << ans.size() << '\n';
		while (!ans.empty()) {
			cout << ans.top() << ' ';
			ans.pop();
		}
		cout << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1625
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1e6+2
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
string s;
int check[7][7], dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};
char c[4] = {'D', 'U', 'R', 'L'};
bool valid(int x, int y) { return (x >= 0 && x < 7 && y >= 0 && y < 7 && !check[x][y]); }
bool miou(int x, int y) {
	if (x == 6 && y == 0) return true;
	if (valid(x+1, y) && valid(x-1, y) && !valid(x, y+1) && !valid(x, y-1)) return true;
	if (!valid(x+1, y) && !valid(x-1, y) && valid(x, y+1) && valid(x, y-1)) return true;
	if (valid(x+1, y) && valid(x, y+1) && !valid(x+1, y+1)) return true;
	if (valid(x+1, y) && valid(x, y-1) && !valid(x+1, y-1)) return true;
	if (valid(x-1, y) && valid(x, y-1) && !valid(x-1, y-1)) return true;
	if (valid(x-1, y) && valid(x, y+1) && !valid(x-1, y+1)) return true;
	return false;
}
 
int count(int x, int y, int pos) {
	if (pos == 48) return 1;
	int ans = 0;
	if (miou(x, y)) return 0;
	check[x][y] = 1;
	for (int i = 0; i < 4; i++) {
		if (valid(x + dx[i], y + dy[i]) && (s[pos] == '?' || s[pos] == c[i]))
			ans += count(x + dx[i], y + dy[i], pos + 1);
	}
	check[x][y] = 0;
	return ans;
}
 
int main () { _
	cin >> s;
	cout << count(0, 0, 0) << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1635
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
 
const int mod = 1e9 + 7;
int dp[MAXN], n, x, v[105];
 
int coin(int soma) {
    if (dp[soma] >= 0) return dp[soma];
    int resp = 0;
    for (int i = 1; i <= n; i++) {
        if (soma - v[i] >= 0) {
            resp += coin(soma-v[i]);
            resp %= mod;
        }
        else break;
    }
    return dp[soma] = resp;
}
 
int main () { _
    memset(dp, -1, sizeof(dp));
    cin >> n >> x;
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
    }
    sort(v+1, v+n+1);
    dp[0] = 1;
    cout << coin(x) << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1634
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
 
int dp[MAXN], n, x, v[105];
 
int coin(int soma) {
    if (dp[soma] > 0) return dp[soma];
    if (soma == 0) return 0;
    int resp = INF;
    for (int i = n; i > 0; i--) {
        if (soma-v[i] >= 0) resp = min(resp, 1+coin(soma-v[i]));
    }
    return dp[soma] = resp;
}
 
int main () {
    cin >> n >> x;
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
    }
    int ans = coin(x);
    if (ans > 1000000) cout << "-1" << endl;
    else cout << ans << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1633
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
 
const int mod = 1e9 + 7;
int dp[1000005];
 
int dice(int n) {
    int resp = 0;
 
    // caso base
    if (n == 0) return 1;
 
    // se ja calculamos a dp
    if (dp[n] > 0) {
        return dp[n];
    }
    for (int i = 1; i<= 6; i++) {
        if (n - i >= 0) {
            resp += dice(n-i);
 
            // lembrar de tirar o modulo
            resp %= mod;
        }
    }
    return dp[n] = resp;
}
 
int main () {
    int n;
    cin >> n;
    cout << dice(n) << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1632
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, k;
    cin >> n >> k;
    vector<pii> v(n);
    for (int i = 0; i < n; i++) cin >> v[i].S >> v[i].F;
    sort(begin(v), end(v));
    multiset<int> s;
    for (int i = 0; i < k; i++) s.insert(0);
    int resp = 0;
    for (int i = 0; i < n; i++) {
        auto it = s.upper_bound(v[i].S);
        if (it == begin(s)) continue;
        resp++;
        s.erase(--it);
        s.insert(v[i].F);
    }
    cout << resp << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1631
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 300100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main() { _
    int n;
    cin >> n;
    vector<int> v(n);
    for (int i = 0; i < n; i++) cin >> v[i];
    sort(v.begin(), v.end());
    ll a1 = 0, a2 = 0, ma1, ma2;
    for (int i = n-1; i >= 0; i--) {
        if (a1 <= a2) {
            a1 += v[i];
            ma1 = v[i];
        }
        else {
            a2 += v[i];
            ma2 = v[i];
        }
    }
    if (a1 > a2) {
        if (a2 >= ma1) cout << a1 + a2 << '\n';
        else cout << 2*a1 << '\n';
    }
    else {
        if (a1 >= ma2) cout << a1 + a2 << '\n';
        else cout << 2*a2 << '\n';
    }
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1630
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 300100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main() { _
    int n, aux;
    cin >> n;
    ll soma = 0;
    vector<int> v(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i] >> aux;
        soma += aux;
    }
    sort(v.begin(), v.end());
    ll tempo = 0;
    for (int i = 0; i < n; i++) {
        tempo += v[i];
        soma -= tempo;
    }
    cout << soma << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1629
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1e5+2
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 998244353;
 
int main () { _
	int n;
	cin >> n;
	vector<pii> v(n);
	for (int i = 0; i < n; i++) cin >> v[i].S >> v[i].F;
	sort(v.begin(), v.end());
	int ans = 0, cd = 0;
	for (int i = 0; i < n; i++) {
		if (v[i].S >= cd) {
			ans++;
			cd = v[i].F;
		}
	}
	cout << ans << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1628
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1010
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int main () { _
	int n, x, aux;
	cin >> n >> x;
	vector<int> v1, v2;
	for (int i = 0; i < n/2; i++) {
		cin >> aux;
		v1.pb(aux);
	} 
	for (int i = n/2; i < n; i++) {
		cin >> aux;
		v2.pb(aux);
	}
	int tam1 = n/2, tam2 = (n+1)/2, tam;
	vector<ll> resp1(1), resp2(1);
	for (int i = 0; i < tam1; i++) {
		tam = (int)resp1.size();
		for (int j = 0; j < tam; j++) resp1.pb(resp1[j] + v1[i]);
	}
	for (int i = 0; i < tam2; i++) {
		tam = (int)resp2.size();
		for (int j = 0; j < tam; j++) resp2.pb(resp2[j] + v2[i]);
	}
	sort(resp1.begin(), resp1.end());
	sort(resp2.begin(), resp2.end());
	ll ans = 0;
	for (ll a : resp1) {
		if (a > x) break;
		ll look = x-a;
		ans -= lower_bound(resp2.begin(), resp2.end(), look) - upper_bound(resp2.begin(), resp2.end(), look);
	}
	cout << ans << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1636
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, x;
    cin >> n >> x;
    vector<int> coin(n), dp(x+1);
    for (int i = 0; i < n; i++) {
        cin >> coin[i];
    }
    sort(coin.begin(), coin.end());
    dp[0] = 1;
    for (int i = 0; i < n; i++) {
        int atual = coin[i];
        for (int j = atual; j <= x; j++) {
            dp[j] = dp[j] + dp[j-atual];
            if (dp[j] >= M) dp[j] -= M;
        }
    }
    cout << dp[x] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1624
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
 
const int mod = 1e9 + 7;
const int n_q = 8;
 
bool m[n_q][n_q];
 
int queen(int n) {
    if (n == n_q) return 1;
    int resp = 0;
    bool aux[n_q][n_q];
    for (int i = 0; i < n_q; i++) {
        for (int j = 0; j < n_q; j++) {
            aux[i][j] = m[i][j];
        }
    }
    int i = n;
    for (int j = 0; j < n_q; j++) {
        if (m[i][j]) {
            for (int k = 0; k < n_q; k++) {
                m[i][k] = m[k][j] = false;
                for (int l = 0; l < n_q; l++) {
                    if ((i-j) == (k-l) or (i+j) == (k+l)) m[k][l] = false;
                }
            }
            resp += queen(n+1);
            for (int k = 0; k < n_q; k++) {
                for (int l = 0; l < n_q; l++) {
                    m[k][l] = aux[k][l];
                }
            }
        }
    }
    return resp;
}
 
int main () { _
    char c;
    for (int i = 0; i < n_q; i++) {
        for (int j = 0; j < n_q; j++) {
            cin >> c;
            if (c == '*') m[i][j] = false;
            else m[i][j] = true;
        }
    }
    cout << queen(0) << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1623
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
 
using namespace std;
typedef long long int lli;
 
int n, aux;
lli soma = 0;
vector <int> v;
 
lli dp(lli atual, int id) {
    if (id == n) return abs(soma - 2*atual);
    if ((atual + v[id])*2 <= soma) {
        return min (dp(atual + v[id], id+1), dp (atual, id+1));
    }
    return dp (atual, id+1);
}
 
bool ordem (int a, int b) { return a < b; }
 
int main() { _
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> aux;
        soma += aux;
        v.push_back(aux);
    }
    sort(v.begin(), v.end(), ordem);
    lli resp = dp(0, 0);
    cout << resp << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1622
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
 
const int mod = 1e9 + 7;
const int n_q = 5;
 
int v[26], ans = 0;
string s, respostas[50000];
 
void permutations (string resp) {
    for (int i = 0; i < 26; i++) {
        if (v[i] > 0) {
            v[i]--;
            char nova = i+97;
            resp.push_back(nova);
            permutations(resp);
            v[i]++;
            resp.pop_back();
        }
    }
    if ((int)resp.size() == (int)s.size()) {
        respostas[ans] = resp;
        ans++;   
    }
    
}
 
int main () { _
    cin >> s;
    for (int i = 0; i < (int)s.size(); i++) {
        v[s.at(i)-97]++;
    }
    string ini = "";
    permutations(ini);
    cout << ans << endl;
    for (int i = 0; i < ans; i++) {
        cout << respostas[i] << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1621
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
 
set<int> conjunto;
 
int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        int aux;
        cin >> aux;
        conjunto.insert(aux);
    }
    cout << conjunto.size() << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1620
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 300100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main() { _
    int n, k;
    cin >> n >> k;
    vector<int> v(n);
    for (int i = 0; i < n; i++) cin >> v[i];
    ll l = 0, r = 1e18+1;
    while (r > l + 1) {
        ll m = (l+r)>>1, count = 0;
        for (int i = 0; i < n && count < k; i++) count += m/v[i];
        if (count >= k) r = m;
        else l = m;
    }
    cout << r << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1619
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1e5+2
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 998244353;
 
int main () { _
	int n, a;
	cin >> n;
	vector<pair<int, int>> v;
	for (int i = 0; i < n; i++) {
		cin >> a;
		v.pb({a, 1});
		cin >> a;
		v.pb({a, 0});
	}
	sort(v.begin(), v.end());
	int ans = 0, atual = 0;
	for (int i = 0; i < 2*n; i++) {
		if (v[i].S) atual++;
		else atual--;
		ans = max(ans, atual);
	}
	cout << ans << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1618
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
const int big = 1e9+7;
 
int main() { _
    int n, resp = 0, div = 5;
    cin >> n;
    while (div <= n) {
        resp += n/div;
        div *= 5;
    }
    cout << resp << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1617
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
const int big = 1e9+7;
 
int main() { _
    int n, resp = 1;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        resp *= 2;
        resp %= big;
    }
    cout << resp << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1645
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n;
	cin >> n;
	vector<int> v(n+1), ans(n+1);
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		ans[i] = i-1;
	}
	for (int i = 1; i <= n; i++) {
		while (v[ans[i]] >= v[i]) {
			ans[i] = ans[ans[i]];
		}
	}
	for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1653
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, x;
    cin >> n >> x;
    vector<int> v(n);
    for (int i = 0; i < n; i++) cin >> v[i];
    vector<pii> dp((1<<21), {n+1, 0});
    dp[0] = {0, 0};
    for (int i = 1; i < (1 << n); i++) {
        for (int j = 0; j < n; j++) {
            if (i & (1<<j)) {
                pii next = dp[i ^(1<<j)];
                if (next.S + v[j] > x) {
                    next.F++;
                    next.S = v[j];
                }
                else next.S += v[j];
                dp[i] = min(dp[i], next);
            }
        }
    }
    cout << dp[(1<<n)-1].F + (dp[(1<<n)-1].S >= 0) << '\n'; 
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1652
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1010
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
 
int bit[MAXN][MAXN], n;
 
int soma (int x, int y) {
	int resp = 0;
	for (int i = x; i > 0; i -= (i & -i)) {
		for (int j = y; j > 0; j -= (j & -j)) {
			resp += bit[i][j];
		}
	}
	return resp;
}
 
void update (int x, int y) {
	for (int i = x; i < 1001; i += (i&-i)) {
		for (int j = y; j < 1001; j += (j & -j)) {
			bit[i][j] += 1;
		}
	}
}
 
int main () { _
	int q, x1, y1, x2, y2;
	char c;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> c;
			if (c == '*') update(i, j);
		}
	}
	for (int i = 0; i < q; i++) {
		cin >> y1 >> x1 >> y2 >> x2;
		cout << soma(y2, x2) - soma(y1-1, x2) - soma(y2, x1-1) + soma(y1-1, x1-1) << endl;
	}
    return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1651
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
 
lli bit[MAXN], n;
 
lli soma (int x) {
	lli resp = 0;
	while (x > 0) {
		resp += bit[x];
		x -= (x & -x);
	}
	return resp;
}
 
void update (int x, int valor) {
	while (x <= n) {
		bit[x] += valor;
		x += (x & -x);
	}
}
 
int main () { _
	int q, tipo, a, b, c, anterior;
	cin >> n >> q;
	cin >> a;
	update (1, a);
	anterior = a;
	for (int i = 2; i <= n; i++) {
		cin >> a;
		update(i, a-anterior);
		anterior = a;
	}
	for (int i = 0; i < q; i++) {
		cin >> tipo;
		if (tipo == 1) {
			cin >> a >> b >> c;
			update(a, c);
			update(b+1, -c);
		}
		else {
			cin >> a;
			cout << soma(a) << endl;
		}
	}
    return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1650
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 10000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
 
int n, q, a, b, v[MAXN], arvore[4*MAXN];
 
void build(int node, int i, int j) {
	if (i == j) arvore[node] = v[i];
	else {
		int meio = (i+j)/2;
		build(2*node, i, meio);
		build(2*node+1, meio+1, j);
		arvore[node] = (arvore[2*node]^arvore[2*node+1]);
	}
}
 
void atualiza(int node, int i, int j, int posicao, int novo) {
	if (i == j) { 
		v[posicao] = novo;
		arvore[node] = novo;
	}
	else {
		int meio = (i+j)/2;
		if (posicao > meio) atualiza(2*node+1, meio+1, j, posicao, novo);
		else atualiza(2*node, i, meio, posicao, novo);
		arvore[node] = min(arvore[2*node], arvore[2*node+1]);
	}
}
 
int consulta (int node, int i, int j, int ini, int fim) {
	if (i > fim || j < ini) return 0;
	if (i >= ini && j <= fim) return arvore[node];
	else {
		int meio = (i+j)/2;
		int resp1 = consulta (2*node, i, meio, ini, fim);
		int resp2 = consulta (2*node+1, meio+1, j, ini, fim);
		return (resp1^resp2);
	}
}
 
int main () { _
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	build(1, 1, n);
	for (int i = 0; i < q; i++) {
		cin >> a >> b;
		cout << consulta(1, 1, n, a, b) << endl;
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1649
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 10000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
 
int n, q, a, b, v[MAXN], arvore[4*MAXN];
 
void build(int node, int i, int j) {
	if (i == j) arvore[node] = v[i];
	else {
		int meio = (i+j)/2;
		build(2*node, i, meio);
		build(2*node+1, meio+1, j);
		arvore[node] = min(arvore[2*node], arvore[2*node+1]);
	}
}
 
void atualiza(int node, int i, int j, int posicao, int novo) {
	if (i == j) { 
		v[posicao] = novo;
		arvore[node] = novo;
	}
	else {
		int meio = (i+j)/2;
		if (posicao > meio) atualiza(2*node+1, meio+1, j, posicao, novo);
		else atualiza(2*node, i, meio, posicao, novo);
		arvore[node] = min(arvore[2*node], arvore[2*node+1]);
	}
}
 
int consulta (int node, int i, int j, int ini, int fim) {
	if (i > fim || j < ini) return INT_MAX;
	if (i >= ini && j <= fim) return arvore[node];
	else {
		int meio = (i+j)/2;
		int resp1 = consulta (2*node, i, meio, ini, fim);
		int resp2 = consulta (2*node+1, meio+1, j, ini, fim);
		return min(resp1, resp2);
	}
}
 
int main () { _
	int tipo;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	build(1, 1, n);
	for (int i = 0; i < q; i++) {
		cin >> tipo >>  a >> b;
		if (tipo == 1) 
			atualiza (1, 1, n, a, b);
		else 
			cout << consulta(1, 1, n, a, b) << endl;
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1648
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
int n, q, v[MAXN];
lli BIT[MAXN];
 
void atualiza (int id, int novo, int antigo) {
    while(id <= n) {
        BIT[id] += novo - antigo;
        id += (id&-id);
    }
}
 
lli soma (int id) {
    lli resp = 0;
    while (id > 0) {
        resp += BIT[id];
        id -= (id&-id);
    }
    return resp;
}
 
int main() { _
    int k, andar1, andar2, pessoas;
    cin >> n >> q;
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
        atualiza(i, v[i], 0);
    }
    for (int i = 0; i < q; i++) {
        cin >> k;
        if (k==1){
            cin >> andar1 >> pessoas;
            atualiza(andar1, pessoas, v[andar1]);
            v[andar1] = pessoas;
        }
        else{
            cin >> andar1 >> andar2;
            cout << soma(andar2) - soma(andar1-1) << endl;
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1647
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 10000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
 
int n, q, a, b, v[MAXN], arvore[4*MAXN];
 
void build(int node, int i, int j) {
	if (i == j) arvore[node] = v[i];
	else {
		int meio = (i+j)/2;
		build(2*node, i, meio);
		build(2*node+1, meio+1, j);
		arvore[node] = min(arvore[2*node], arvore[2*node+1]);
	}
}
 
int consulta (int node, int i, int j, int ini, int fim) {
	if (i > fim || j < ini) return INT_MAX;
	if (i >= ini && j <= fim) return arvore[node];
	else {
		int meio = (i+j)/2;
		int resp1 = consulta (2*node, i, meio, ini, fim);
		int resp2 = consulta (2*node+1, meio+1, j, ini, fim);
		return min(resp1, resp2);
	}
}
 
int main () { _
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	build(1, 1, n);
	for (int i = 0; i < q; i++) {
		cin >> a >> b;
		cout << consulta(1, 1, n, a, b) << endl;
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1646
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 10000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
 
int main () { _
	int n, q, a, b;
	lli v[MAXN];
	cin >> n >> q;
	v[0] = 0;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		v[i] += v[i-1];
	}
	for (int i = 0; i < q; i++) {
		cin >> a >> b;
		cout << v[b] - v[a-1] << endl;
	}
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1068
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	ll n;
	cin >> n;
	while (n != 1) {
		cout << n << " ";
		if (n % 2 == 0) n /= 2;
		else n = 3 * n + 1;
	}
	cout << n << "\n";
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1644
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
multiset<ll> s;
 
int main () { _
	int n, a, b;
    cin >> n >> a >> b;
    vector<ll> v(n+1);
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
        v[i] += v[i-1];
    }
    ll ans = -1e16;
    for (int i = 0; i <= n; i++) {
        if (i-a >= 0) s.insert(v[i-a]);
        if (i >= a) ans = max(ans, v[i] - *s.begin());
        if (i-b >= 0) s.erase(s.find(v[i-b]));
    }
    cout << ans << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1643
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1e5+2
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 998244353;
 
int main () { _
	int n;
	cin >> n;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	ll ans = -1e9 - 10, sum = 0;
	for (int i = 0; i < n; i++) {
		sum += v[i];
		ans = max(ans, sum);
		if (sum < 0) sum = 0;
	}
	cout << ans << '\n';
	return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1642
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
bool comp (int a, int b, int c, int d) {
	bool ber = false;
	ber |= (a == b || a == c || a == d);
	ber |= (b == c || b == d);
	ber |= (c == d);
	return ber;
}
 
int main() { _
    int n, x;
	cin >> n >> x;
	vector<int> v(n);
	for (int i = 0; i < n; i++) {
		cin >> v[i];
	}
	vector<pair<ll, pii>> w;
	vector<ll> u;
	for (int i = 0; i < n; i++) {
		for (int j = i+1; j < n; j++) {
			w.pb({v[i] + v[j], {i, j}});
			u.pb(v[i] + v[j]);
		}
	}	
	sort(w.begin(), w.end());
	sort(u.begin(), u.end());
	int tam = w.size();
	for (int i = 0; i < tam; i++) {
		ll sum = x - w[i].F;
		int pos = lower_bound(u.begin(), u.end(), sum) - u.begin();
		while (pos < tam && (comp(w[i].S.F, w[i].S.S, w[pos].S.F, w[pos].S.S))) pos++;
		if (pos < tam && w[pos].F == sum && !comp(w[i].S.F, w[i].S.S, w[pos].S.F, w[pos].S.S)) {
			cout << w[i].S.F + 1 << ' ' << w[i].S.S + 1 << ' ' << w[pos].S.F + 1 << ' ' << w[pos].S.S + 1 << '\n';
			return 0;
		}
	}
	cout << "IMPOSSIBLE\n";
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1641
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n, k;
	cin >> n >> k;
	vector<pair<ll, int>> v(n);
	for (int i = 0; i < n; i++) {
		cin >> v[i].F;
		v[i].S = i+1;
	}
	sort(v.begin(), v.end());
	for (int i = 0; i < n-2; i++) {
		int r = n-1;
		for (int l = i+1; l < r; l++) {
			while (r > l + 1 && v[i].F + v[l].F + v[r].F > k) r--;
			if (v[i].F + v[r].F + v[l].F == k) {
				cout << v[i].S << ' ' << v[l].S << ' ' << v[r].S << '\n';
				return 0;
			}
		}
	}
	cout << "IMPOSSIBLE\n";
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1640
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int n, x;
    cin >> n >> x;
    vector<int> v(n);
    map<int, int> mp;
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        mp[v[i]] = i + 1;
    }
    bool ok = false;
    for (int i = 0; i < n; i++) {
        if (mp[x - v[i]] && mp[x - v[i]] != (i + 1)) {
            cout << i + 1 << ' ' << mp[x - v[i]] << endl;
            ok = true;
            break;
        }
    }
    if (!ok) cout << "IMPOSSIBLE" << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1639
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    string a, b;
    cin >> a >> b;
    int tama = (int)a.size(), tamb = (int)b.size();
    vector<vector<int>> dp(5050, vector<int> (5050, 10000));
    dp[tama][tamb] = 0;
    for (int i = tama; i >= 0; i--) {
        for (int j = tamb; j >= 0; j--) {
            dp[i][j] = min(dp[i][j], (a[i] != b[j]) + dp[i+1][j+1]);
            dp[i][j] = min(dp[i][j], 1 + dp[i+1][j]);
            dp[i][j] = min(dp[i][j], 1 + dp[i][j+1]);
        }
    }
    cout << dp[0][0] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1638
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
const int mod = 1e9+7;
 
int dp[1010][1010], n;
bool m[1010][1010];
 
int ways (int i, int j) {
    if (dp[i][j] >= 0) return dp[i][j];
    int resp = 0;
    if (i < n and m[i+1][j]) {
        resp += ways(i+1, j);
        resp %= mod;
    }
    if (j < n and m[i][j+1]) {
        resp += ways(i, j+1);
        resp %= mod;
    }
    return dp[i][j] = resp;
}
 
int main () { _
    char c;
    memset(dp, -1, sizeof(dp));
    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> c;
            if (c == '.') m[i][j] = true;
            else m[i][j] = false;
        }
    }
    dp[n-1][n-1] = 1;
    if (!m[0][0]) cout << "0" << endl;
    else cout << ways(0,0) << endl;
    return 0;
}
\end{lstlisting}

\subsection{}
\begin{lstlisting}
Problem Link: https://cses.fi/problemset/task/1637
Author: Bernardo Archegas (https://codeforces.com/profile/Ber)
*/
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
 
int dp[MAXN];
 
int digit(int x) {
    if (x == 0) return 0;
    if (dp[x] > 0) return dp[x];
    string s = to_string(x);
    int resp = INF;
    for (int i = 0; i < (int)s.size(); i++) {
        if (s.at(i) != '0') resp = min(resp, 1 + digit(x-(int)s.at(i)+48));
    }
    return dp[x] = resp;
}
 
int main () { _
    int n;
    cin >> n;
    cout << digit(n) << endl;
    return 0;
}
\end{lstlisting}

\pagebreak


%%%%%%%%%%%%%%%%%%%%
%
% Extra
%
%%%%%%%%%%%%%%%%%%%%

\section{Extra}

\subsection{template.cpp}
\begin{lstlisting}
// Template
// 

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    return 0;
}
\end{lstlisting}

\end{document}
