\documentclass[12pt, a4paper, twoside]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}
\usepackage{comment}
\usepackage{datetime}
\usepackage[pdfusetitle]{hyperref}
\usepackage[all]{xy}
\usepackage{graphicx}
\addtolength{\parskip}{.5\baselineskip}

%aqui comeca o que eu fiz de verdade, o resto veio e eu to com medo de tirar
\usepackage{listings} %biblioteca pro codigo
\usepackage{color}    %deixa o codigo colorido bonitinho
\usepackage[landscape, left=1cm, right=1cm, top=1cm, bottom=2cm]{geometry} %pra deixar a margem do jeito que o brasil gosta

\definecolor{gray}{rgb}{0.4, 0.4, 0.4} %cor pros comentarios
%\renewcommand{\footnotesize}{\small} %isso eh pra mudar o tamanho da fonte do codigo
\setlength{\columnseprule}{0.2pt} %barra separando as duas colunas
\setlength{\columnsep}{15pt} %distancia do texto ate a barra

\lstset{ %opcoes pro codigo
breaklines=true,
keywordstyle=\color{blue},
commentstyle=\color{gray},
basicstyle=\footnotesize,
breakatwhitespace=true,
language=C++,
%frame=single, % nao sei se gosto disso ou nao
numbers=none,
rulecolor=\color{black},
showstringspaces=false
stringstyle=\color{blue},
tabsize=4,
basicstyle=\ttfamily\footnotesize, % fonte
literate={~} {$\sim$}{1} % ~ bonitinho
}

\title{[UNICAMP] Inimigos do Hungaro}
\author{Bernardo Archegas, Luiz Oda e Cirilo de Morais}


\begin{document}
\twocolumn
\date{} %tira a data
\maketitle


\renewcommand{\contentsname}{Índice} %troca o nome do indice para indice
\tableofcontents


%%%%%%%%%%%%%%%%%%%%
%
% Graph
%
%%%%%%%%%%%%%%%%%%%%

\section{Graph}

\subsection{Bellman Ford}
\begin{lstlisting}

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;

vector<array<int, 3>> v;
ll dist[MAXN];
int p[MAXN];
 
int main() { 
	ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	array<int, 3> a;

	// recebe aresta de a pra b com custo c
	for (int i = 0; i < m; i++) {
		cin >> a[0] >> a[1] >> a[2];
		v.push_back(a);
	}
	int x = -1;
	for (int i = 2; i <= n; i++) dist[i] = INF;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (dist[v[j][0]] + v[j][2] < dist[v[j][1]]) {
				dist[v[j][1]] = dist[v[j][0]] + v[j][2];
				p[v[j][1]] = v[j][0];
				if (i == n-1) x = v[j][1];
			}
		}
	}
	if (x == -1) cout << "NO\n";
	else {
		cout << "YES\n";
		for (int i = 0; i < n; i++) x = p[x];
		stack<int> ans;
		ans.push(x);
		for (int i = p[x]; i != x; i = p[i]) {
			ans.push(i);
		}
		ans.push(x);
		while (!ans.empty()) {
			cout << ans.top() << ' ';
			ans.pop();
		}
		cout << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{Dinic}
\begin{lstlisting}
// O(min(m * max_flow, n^2 m))
// Grafo com capacidades 1 -> O(sqrt(n)*m)
// INF ta pra int
struct dinic {
	const bool scaling = false;
	int lim;
	struct edge {
		int to, cap, rev, flow;
		bool res;
		edge(int to_, int cap_, int rev_, bool res_)
			: to(to_), cap(cap_), rev(rev_), flow(0), res(res_) {}
	};

	vector<vector<edge>> g;
	vector<int> lev, beg;
	ll F;
	dinic(int n) : g(n), F(0) {}

	void add(int a, int b, int c) {
		g[a].emplace_back(b, c, g[b].size(), false);
		g[b].emplace_back(a, 0, g[a].size()-1, true);
	}
	bool bfs(int s, int t) {
		lev = vector<int>(g.size(), -1); lev[s] = 0;
		beg = vector<int>(g.size(), 0);
		queue<int> q; q.push(s);
		while (q.size()) {
			int u = q.front(); q.pop();
			for (auto& i : g[u]) {
				if (lev[i.to] != -1 or (i.flow == i.cap)) continue;
				if (scaling and i.cap - i.flow < lim) continue;
				lev[i.to] = lev[u] + 1;
				q.push(i.to);
			}
		}
		return lev[t] != -1;
	}
	int dfs(int v, int s, int f = INF) {
		if (!f or v == s) return f;
		for (int& i = beg[v]; i < g[v].size(); i++) {
			auto& e = g[v][i];
			if (lev[e.to] != lev[v] + 1) continue;
			int foi = dfs(e.to, s, min(f, e.cap - e.flow));
			if (!foi) continue;
			e.flow += foi, g[e.to][e.rev].flow -= foi;
			return foi;
		}
		return 0;
	}
	ll max_flow(int s, int t) {
		for (lim = scaling ? (1<<30) : 1; lim; lim /= 2)
			while (bfs(s, t)) while (int ff = dfs(s, t)) F += ff;
		return F;
	}

	// arestas com fluxo
	vector<pii> flow_edges(int s, int t) {
		max_flow(s, t);
		vector<pii> ans;
		int n = g.size();
		for (int i = 0; i < n; i++) {
			for (auto edge : g[i]) {
				if (!edge.res && edge.flow) 
					ans.emplace_back(i, edge.to);
			}
		}
		return ans;
	}

	// arestas no min cut
	vector<pii> cut_edges(int s, int t) {
		max_flow(s, t);
		vector<pii> cut;
		vector<int> vis(g.size(), 0), st = {s};
		vis[s] = 1;
		while (st.size()) {
			int u = st.back(); st.pop_back();
			for (auto e : g[u]) if (!vis[e.to] and e.flow < e.cap)
				vis[e.to] = 1, st.push_back(e.to);
		}
		for (int i = 0; i < g.size(); i++) for (auto e : g[i])
			if (vis[i] and !vis[e.to] and !e.res) cut.emplace_back(i, e.to);
		return cut;
	}
};
\end{lstlisting}

\subsection{Dominator Tree - Kawakami}
\begin{lstlisting}
// build - O(n)
// dominates - O(1)
// c80920

// importante que os vertices sejam de 0 a n - 1
int n;

namespace d_tree {
	vector<int> g[MAXN];

	// The dominator tree
	// em alguns problemas vc usa o tamanho da arvore da source
	// ent vale lembrar que nem todos os vertices fazem parte da arvore da source
	// ent a dominator tree na real eh uma floresta
	vector<int> tree[MAXN];
	int dfs_l[MAXN], dfs_r[MAXN];

	// Auxiliary data
	vector<int> rg[MAXN], bucket[MAXN];
	int idom[MAXN], sdom[MAXN], prv[MAXN], pre[MAXN];
	int ancestor[MAXN], label[MAXN];
	vector<int> preorder;

	void dfs(int v) {
		static int t = 0;
		pre[v] = ++t;
		sdom[v] = label[v] = v;
		preorder.push_back(v);
		for (int nxt: g[v]) {
			if (sdom[nxt] == -1) {
				prv[nxt] = v;
				dfs(nxt);
			}
			rg[nxt].push_back(v);
		}
	}
	int eval(int v) {
		if (ancestor[v] == -1) return v;
		if (ancestor[ancestor[v]] == -1) return label[v];
		int u = eval(ancestor[v]);
		if (pre[sdom[u]] < pre[sdom[label[v]]]) label[v] = u;
		ancestor[v] = ancestor[u];
		return label[v];
	}
	void dfs2(int v) {
		static int t = 0;
		dfs_l[v] = t++;
		for (int nxt: tree[v]) dfs2(nxt);
		dfs_r[v] = t++;
	}
	void build(int s) {
		for (int i = 0; i < n; i++) {
			sdom[i] = pre[i] = ancestor[i] = -1;
			rg[i].clear();
			tree[i].clear();
			bucket[i].clear();
		}
		preorder.clear();
		dfs(s);
		if (preorder.size() == 1) return;
		for (int i = int(preorder.size()) - 1; i >= 1; i--) {
			int w = preorder[i];
			for (int v: rg[w]) {
				int u = eval(v);
				if (pre[sdom[u]] < pre[sdom[w]]) sdom[w] = sdom[u];
			}
			bucket[sdom[w]].push_back(w);
			ancestor[w] = prv[w];
			for (int v: bucket[prv[w]]) {
				int u = eval(v);
				idom[v] = (u == v) ? sdom[v] : u;
			}
			bucket[prv[w]].clear();
		}
		for (int i = 1; i < preorder.size(); i++) {
			int w = preorder[i];
			if (idom[w] != sdom[w]) idom[w] = idom[idom[w]];
			tree[idom[w]].push_back(w);
		}
		idom[s] = sdom[s] = -1;
		dfs2(s);
	}

	// Whether every path from s to v passes through u
	bool dominates(int u, int v) {
		if (pre[v] == -1) return 1; // vacuously true
		return dfs_l[u] <= dfs_l[v] && dfs_r[v] <= dfs_r[u];
	}
};
\end{lstlisting}

\subsection{Floyd Warshall}
\begin{lstlisting}

int n;
int dist[MAXN][MAXN];
 
void FW() {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            for (int k = 1; k <= n; k++) {
                dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);
            }
        }
    }
}
\end{lstlisting}

\subsection{Graph Connectivity}
\begin{lstlisting}
// Given a Graph, we want to find what is the minimum ammount of vertices 
// we have to erase in order to disconnect the graph
// We can solve this with Menger's Theorem, and then we check a good enough ammount
// of pairs of vertices and check if the max flow between them is >= k
// If yes, then the graph is k-connected

// In this specific problem, we wanted to check if k was >= n/2
// Ideia: Para que G seja Strongly Matchable, todo subconjunto S deve ter N(S) >= n/2
// Isso ocorre sse o grafo for k-conexo com k >= n/2
// Pra verificar se um grafo é k-conexo usamos fluxo pra ver se tem k caminhos disjuntos entre todo par de nó
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, a, b;
    cin >> n >> m;
    dinic g(2 * n);
    for (int i = 0; i < n; i++) {
        g.add(i, i + n, 1);
    }
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        a--, b--;
        g.add(a + n, b, 1);
        g.add(b + n, a, 1);
    }
    bool ok = true;
    for (int i = 0; i < 7; i++) {
        int a = rng() % n;
        for (int j = 0; j < n; j++) {
            if (a == j) continue;
            dinic h = g;
            ok &= h.max_flow(a + n, j) >= n / 2;
        }
    }
    cout << (ok ? 1 : -1) << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Hungarian}
\begin{lstlisting}
// Resolve o problema de assignment (matriz n x n)
// Colocar os valores da matriz em 'a' (pode < 0)
// assignment() retorna um par com o valor do
// assignment minimo, e a coluna escolhida por cada linha
//
// O(n^3)
// 64c53e

template<typename T> struct hungarian {
	int n;
	vector<vector<T>> a;
	vector<T> u, v;
	vector<int> p, way;
	T inf;

	hungarian(int n_) : n(n_), u(n+1), v(n+1), p(n+1), way(n+1) {
		a = vector<vector<T>>(n, vector<T>(n));
		inf = numeric_limits<T>::max();
	}
	pair<T, vector<int>> assignment() {
		for (int i = 1; i <= n; i++) {
			p[0] = i;
			int j0 = 0;
			vector<T> minv(n+1, inf);
			vector<int> used(n+1, 0);
			do {
				used[j0] = true;
				int i0 = p[j0], j1 = -1;
				T delta = inf;
				for (int j = 1; j <= n; j++) if (!used[j]) {
					T cur = a[i0-1][j-1] - u[i0] - v[j];
					if (cur < minv[j]) minv[j] = cur, way[j] = j0;
					if (minv[j] < delta) delta = minv[j], j1 = j;
				}
				for (int j = 0; j <= n; j++)
					if (used[j]) u[p[j]] += delta, v[j] -= delta;
					else minv[j] -= delta;
				j0 = j1;
			} while (p[j0] != 0);
			do {
				int j1 = way[j0];
				p[j0] = p[j1];
				j0 = j1;
			} while (j0);
		}
		vector<int> ans(n);
		for (int j = 1; j <= n; j++) ans[p[j]-1] = j-1;
		return make_pair(-v[0], ans);
	}
};
\end{lstlisting}

\subsection{LCA}
\begin{lstlisting}

int dep[MAXN], tab[MAXL][MAXN];
vector<int> v[MAXN];

void dfs(int node, int pai = 0) {
    dep[node] = dep[pai] + 1;
    tab[0][node] = pai;
    for (int x : v[node]) {
        if (x != pai) dfs(x, node);
    }
}

void calcTab(int n) {
    for (int i = 1; i < MAXL; i++) {
        for (int j = 1; j <= n; j++) tab[i][j] = tab[i - 1][tab[i - 1][j]]; 
    }
}

int lca(int a, int b) {
    if (dep[a] < dep[b]) swap(a, b);
    for (int i = MAXL - 1; i >= 0; i--) {
        if (dep[a] - (1 << i) >= dep[b]) {
            a = tab[i][a];
        }
    }
    if (a == b) return a;
    for (int i = MAXL - 1; i >= 0; i--) {
        if (tab[i][a] != tab[i][b]) {
            a = tab[i][a];
            b = tab[i][b];
        }
    }
    return tab[0][a];
}
\end{lstlisting}

\subsection{Lower Bound Max Flow}
\begin{lstlisting}
// Max flow com lower bound nas arestas
// 
// add(a, b, l, r):
// 	adiciona aresta de a pra b, onde precisa passar f de fluxo, l <= f <= r
// add(a, b, c):
// 	adiciona aresta de a pra b com capacidade c
//
// Mesma complexidade do Dinic

// INF tem que ser int, de preferencia 1e9

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const int INF = 1e9;

struct dinic {
	const bool scaling = false;
	int lim;
	struct edge {
		int to, cap, rev, flow;
		bool res;
		edge(int to_, int cap_, int rev_, bool res_)
			: to(to_), cap(cap_), rev(rev_), flow(0), res(res_) {}
	};

	vector<vector<edge>> g;
	vector<int> lev, beg;
	ll F;
	dinic(int n) : g(n), F(0) {}

	void add(int a, int b, int c) {
		g[a].emplace_back(b, c, g[b].size(), false);
		g[b].emplace_back(a, 0, g[a].size()-1, true);
	}
	bool bfs(int s, int t) {
		lev = vector<int>(g.size(), -1); lev[s] = 0;
		beg = vector<int>(g.size(), 0);
		queue<int> q; q.push(s);
		while (q.size()) {
			int u = q.front(); q.pop();
			for (auto& i : g[u]) {
				if (lev[i.to] != -1 or (i.flow == i.cap)) continue;
				if (scaling and i.cap - i.flow < lim) continue;
				lev[i.to] = lev[u] + 1;
				q.push(i.to);
			}
		}
		return lev[t] != -1;
	}
	int dfs(int v, int s, int f = INF) {
		if (!f or v == s) return f;
		for (int& i = beg[v]; i < g[v].size(); i++) {
			auto& e = g[v][i];
			if (lev[e.to] != lev[v] + 1) continue;
			int foi = dfs(e.to, s, min(f, e.cap - e.flow));
			if (!foi) continue;
			e.flow += foi, g[e.to][e.rev].flow -= foi;
			return foi;
		}
		return 0;
	}
	ll max_flow(int s, int t) {
		for (lim = scaling ? (1<<30) : 1; lim; lim /= 2)
			while (bfs(s, t)) while (int ff = dfs(s, t)) F += ff;
		return F;
	}
};

struct lb_max_flow : dinic {
	vector<int> d;
	lb_max_flow(int n) : dinic(n + 2), d(n, 0) {}
	void add(int a, int b, int l, int r) {
		d[a] -= l;
		d[b] += l;
		dinic::add(a, b, r - l);
	}
	void add(int a, int b, int c) {
		dinic::add(a, b, c);
	}
	bool has_circulation() {
		int n = d.size();

		ll cost = 0;
		for (int i = 0; i < n; i++) {
			if (d[i] > 0) {
				cost += d[i];
				dinic::add(n, i, d[i]);
			} else if (d[i] < 0) {
				dinic::add(i, n+1, -d[i]);
			}
		}

		return (dinic::max_flow(n, n+1) == cost);
	}
	bool has_flow(int src, int snk) {
		dinic::add(snk, src, INF);
		return has_circulation();
	}
	ll max_flow(int src, int snk) {
		if (!has_flow(src, snk)) return -1;
		dinic::F = 0;
		return dinic::max_flow(src, snk);
	}
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

	// recebo o numero de vertices e m arestas do tipo
	// vai de a pra b e fluxo tem que estar entre [c, d]
	// note que nao preciso adicionar uma source nem uma sink
	// o algoritmo ja faz isso por mim
    int n, m;
	cin >> n >> m;
	lb_max_flow ber(n);
	map<pii, int> id;
	vector<int> ans(m);
	for (int i = 0; i < m; i++) {
		int a, b, c, d;
		cin >> a >> b >> c >> d;
		a--, b--;
		id[{a, b}] = i;
		ans[i] = c;
		ber.add(a, b, c, d);
	}

	// Se tem um fluxo que atende todas as exigencias
	if (ber.has_circulation()) {
		cout << "YES" << endl;
		
		// Importante: n eh a qtd de vertices
		for (int i = 0; i < n; i++) {
			for (auto edge : ber.g[i]) {
				if (edge.res) {
					int j = edge.to;
					if (j >= n) continue;
					ans[id[{j, i}]] -= edge.flow;
				}
			}
		}

		// imprime fluxo em cada aresta
		for (int x : ans) cout << x << '\n';
	}
	else {
		cout << "NO\n";
	}
    return 0;
}
\end{lstlisting}

\subsection{MinCostMaxFlow}
\begin{lstlisting}
// declara mcmf<int ou ll> nome(qtd de nodes)
// min_cost_flow(s, t, f) computa o par (fluxo, custo)
// com max(fluxo) <= f que tenha min(custo)
// min_cost_flow(s, t) -> Fluxo maximo de custo minimo de s pra t
// Se for um dag, da pra substituir o SPFA por uma DP pra nao
// para O(nm) no comeco
// Se nao tiver aresta com custo negativo, nao precisa do SPFA
//
// O(nm + f * m log n)
// 697b4c

template<typename T> struct mcmf {
	struct edge {
		int to, rev, flow, cap; // para, id da reversa, fluxo, capacidade
		bool res; // se eh reversa
		T cost; // custo da unidade de fluxo
		edge() : to(0), rev(0), flow(0), cap(0), cost(0), res(false) {}
		edge(int to_, int rev_, int flow_, int cap_, T cost_, bool res_)
			: to(to_), rev(rev_), flow(flow_), cap(cap_), res(res_), cost(cost_) {}
	};

	vector<vector<edge>> g;
	vector<int> par_idx, par;
	T inf;
	vector<T> dist;

	mcmf(int n) : g(n), par_idx(n), par(n), inf(numeric_limits<T>::max()/3) {}

	void add(int u, int v, int w, T cost) { // de u pra v com cap w e custo cost
		edge a = edge(v, g[v].size(), 0, w, cost, false);
		edge b = edge(u, g[u].size(), 0, 0, -cost, true);

		g[u].push_back(a);
		g[v].push_back(b);
	}

	vector<T> spfa(int s) { // nao precisa se nao tiver custo negativo
		deque<int> q;
		vector<bool> is_inside(g.size(), 0);
		dist = vector<T>(g.size(), inf);

		dist[s] = 0;
		q.push_back(s);
		is_inside[s] = true;

		while (!q.empty()) {
			int v = q.front();
			q.pop_front();
			is_inside[v] = false;

			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;

					if (is_inside[to]) continue;
					if (!q.empty() and dist[to] > dist[q.front()]) q.push_back(to);
					else q.push_front(to);
					is_inside[to] = true;
				}
			}
		}
		return dist;
	}
	bool dijkstra(int s, int t, vector<T>& pot) {
		priority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> q;
		dist = vector<T>(g.size(), inf);
		dist[s] = 0;
		q.emplace(0, s);
		while (q.size()) {
			auto [d, v] = q.top();
			q.pop();
			if (dist[v] < d) continue;
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				cost += pot[v] - pot[to];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
					q.emplace(dist[to], to);
					par_idx[to] = i, par[to] = v;
				}
			}
		}
		return dist[t] < inf;
	}

	pair<int, T> min_cost_flow(int s, int t, int flow = INF) {
		vector<T> pot(g.size(), 0);
		pot = spfa(s); // mudar algoritmo de caminho minimo aqui

		int f = 0;
		T ret = 0;
		while (f < flow and dijkstra(s, t, pot)) {
			for (int i = 0; i < g.size(); i++)
				if (dist[i] < inf) pot[i] += dist[i];

			int mn_flow = flow - f, u = t;
			while (u != s){
				mn_flow = min(mn_flow,
					g[par[u]][par_idx[u]].cap - g[par[u]][par_idx[u]].flow);
				u = par[u];
			}

			ret += pot[t] * mn_flow;

			u = t;
			while (u != s) {
				g[par[u]][par_idx[u]].flow += mn_flow;
				g[u][g[par[u]][par_idx[u]].rev].flow -= mn_flow;
				u = par[u];
			}

			f += mn_flow;
		}

		return make_pair(f, ret);
	}

	// Opcional: retorna as arestas originais por onde passa flow = cap
	vector<pair<int,int>> recover() {
		vector<pair<int,int>> used;
		for (int i = 0; i < g.size(); i++) for (edge e : g[i])
			if(e.flow == e.cap && !e.res) used.push_back({i, e.to});
		return used;
	}
};
\end{lstlisting}

\subsection{Topological Sort}
\begin{lstlisting}

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;

vector<int> v[MAXN], ans;
bool valid = true;
int cor[MAXN];
 
void dfs(int node) {
	cor[node] = 1;
	for (int x : v[node]) {
		if (cor[x] == 1) {
			valid = false;
			return;
		}
		if (!cor[x]) dfs(x);
	}
	cor[node] = 2;
	ans.push_back(node);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
	}
	for (int i = 1; i <= n && valid; i++) {
		if (!cor[i]) {
			dfs(i);
		}
	}
	if (!valid) cout << "IMPOSSIBLE\n";
	else {
		reverse(ans.begin(), ans.end());
		for (int x : ans) cout << x << ' ';
		cout << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{Tortoise and Hare}
\begin{lstlisting}
// Acha um ciclo com O(1) de memoria em O(n)
// Util para grafos funcionais implicitos em que vc calcula a resposta localmente 
// e depois envia a resposta em O(1)

// https://codeforces.com/gym/102501 (Problema H)

ll m = (1ll<<40);

ll prox(ll a) {
	return (a + (a>>20) + 12345) % m;
}

array<ll, 3> floyd() {

    // retornar a distancia ate o ciclo, inicio do ciclo e tamanho do ciclo
    array<ll, 3> ans = array<ll, 3>();

    // ponto de inicio
    ll slow = 1611516670, fast = 1611516670;

    // primeiro andamos ate que eles se encontrem
    do {
        slow = prox(slow);
        fast = prox(prox(fast));
    } while(slow != fast);

    // cout << "FASE 1 COMPLETA" << endl;

    // depois voltamos um deles para o comeco e andamos ate que eles se encontrem dnv
    slow = 1611516670;
    while (slow != fast) {
        ans[0]++;
        slow = prox(slow);
        fast = prox(fast);
    }

    // cout << "FASE 2 COMPLETA" << endl;
    
    // calcula o tamanho do ciclo
    ans[1] = slow;
    do {
        ans[2]++;
        slow = prox(slow);
    } while (slow != fast);
    return ans;
}
\end{lstlisting}

\subsection{Tree diameter}
\begin{lstlisting}
// int a = bfs(1, 0);
// int diametro = bfs(a, 1);

vector<int> v[MAXN];
int n;
 
int bfs(int node, bool flag) {
    // flag = true se estou fazendo a segunda BFS
	
    queue<pii> q;
	vector<int> check(n+1);
	check[node] = 1;
	q.push({node, 0});
	int resp = 0, fim = node;
	while (!q.empty()) {
		pii atual = q.front();
		q.pop();
		for (int x : v[atual.first]) {
			if (!check[x]) {
				check[x] = 1;
				q.push({x, atual.second+1});
				if (atual.second + 1 > resp) {
					resp = atual.second + 1;
					fim = x;
				}
			}
		}
	}
	return (flag ? resp : fim);
}
\end{lstlisting}

\subsection{Tree Isomorphism}
\begin{lstlisting}
// Acha se duas arvores enraizadas sao isomorficas
// Usa hashing 
// Se nao forem enraizadas basta achar os centroides
// ai tenta ver se uma arvore enraizada em um centroide eh igual a outra enraizada em um dos 2 centroides
#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
vector<int> v[2][MAXN];
int id = 0;
map<vector<int>, int> mp;
 
int dfs(int node, int p, bool at) {
    vector<int> val;
    for (int x : v[at][node]) {
        if (x != p) {
            val.push_back(dfs(x, node, at));
        }
    }
    sort(val.begin(), val.end());
    if (!mp[val]) mp[val] = ++id;
    return mp[val];
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        mp.clear();
        id = 0;
        int n, a, b;
        cin >> n;
        for (int i = 0; i < 2; i++) {
            for (int j = 1; j <= n; j++) {
                v[i][j].clear();
            }
            for (int j = 0; j < n - 1; j++) {
                cin >> a >> b;
                v[i][a].push_back(b);
                v[i][b].push_back(a);
            }
        }
        int s0 = dfs(1, -1, 0);
        int s1 = dfs(1, -1, 1);
        cout << (s0 == s1 ? "YES\n" : "NO\n");
    }
    return 0;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Math
%
%%%%%%%%%%%%%%%%%%%%

\section{Math}

\subsection{Comb Template}
\begin{lstlisting}
// template para problemas de combinatoria
int fat[MAXN], inv[MAXN];

ll fexp(ll b, ll e) {
    ll ans = 1;
    while (e) {
        if (e&1) ans = (ans * b) % MOD;
        b = (b * b) % MOD;
        e >>= 1;
    }
    return ans;
}

void precalc() {
    fat[0] = 1;
    for (int i = 1; i < MAXN; i++) fat[i] = (1ll * i * fat[i - 1]) % MOD;
    inv[MAXN - 1] = fexp(fat[MAXN - 1], MOD - 2);
    for (int i = MAXN - 2; i >= 0; i--) inv[i] = ((i + 1ll) * inv[i + 1]) % MOD;
}

int nck(int n, int k) {
    if (k > n || k < 0 || n < 0) return 0;
    return (((1ll * fat[n] * inv[k]) % MOD) * 1ll * inv[n - k]) % MOD; 
}

void add(int &a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
    if (a < 0) a += MOD;
}

int mul(int a, int b) {
    return (1ll * a * b) % MOD;
}
\end{lstlisting}

\subsection{Division Trick}
\begin{lstlisting}
// Gera o conjunto n/i, pra todo i, em O(sqrt(n))

for(int l = 1, r; l <= n; l = r + 1) {
	r = n / (n / l);
	// n / i has the same value for l <= i <= r
}
\end{lstlisting}

\subsection{Eliminacao Gaussiana}
\begin{lstlisting}
// Resolve sistema linear
// Retornar um par com o numero de solucoes
// e alguma solucao, caso exista
//
// O(n^2 * m)
// 1d10b5

template<typename T>
pair<int, vector<T>> gauss(vector<vector<T>> a, vector<T> b) {
	const double eps = 1e-6;
	int n = a.size(), m = a[0].size();
	for (int i = 0; i < n; i++) a[i].push_back(b[i]);

	vector<int> where(m, -1);
	for (int col = 0, row = 0; col < m and row < n; col++) {
		int sel = row;
		for (int i=row; i<n; ++i)
			if (abs(a[i][col]) > abs(a[sel][col])) sel = i;
		if (abs(a[sel][col]) < eps) continue;
		for (int i = col; i <= m; i++)
			swap(a[sel][i], a[row][i]);
		where[col] = row;

		for (int i = 0; i < n; i++) if (i != row) {
			T c = a[i][col] / a[row][col];
			for (int j = col; j <= m; j++)
				a[i][j] -= a[row][j] * c;
		}
		row++;
	}

	vector<T> ans(m, 0);
	for (int i = 0; i < m; i++) if (where[i] != -1)
		ans[i] = a[where[i]][m] / a[where[i]][i];
	for (int i = 0; i < n; i++) {
		T sum = 0;
		for (int j = 0; j < m; j++)
			sum += ans[j] * a[i][j];
		if (abs(sum - a[i][m]) > eps)
			return pair(0, vector<T>());
	}

	for (int i = 0; i < m; i++) if (where[i] == -1)
		return pair(INF, ans);
	return pair(1, ans);
}
\end{lstlisting}

\subsection{Eliminacao Gaussiana MOD}
\begin{lstlisting}
// Recebe a matriz a com os coeficientes aij e bi da equacao a11x1 + a12x2 ... = b1
// Devolve o vetor com os valores de xi
vector<ll> gauss(vector<vector<ll> > &a, ll MOD)
{
	int n = a.size(), m = a[0].size() - 1;
	for(int i = 0; i < n; i++){
		for(int j = 0; j <= m; j++){
			a[i][j] = (a[i][j] % MOD + MOD) % MOD;
	    }
    }
	vector<int> where(m, -1);
	for(int col = 0, row = 0; col < m && row < n; col++)
	{
		int sel = row;
		for(int i = row; i < n; i++)
			if(a[i][col] > a[sel][col])
				sel = i;
 
			if(a[sel][col] == 0) { where[col] = -1; continue; 
	}
        for(int i = col; i <= m; i++)
			swap(a[sel][i], a[row][i]);
		where[col] = row;
 
		ll c_inv = fexp(a[row][col], MOD - 2);
		for(int i = 0; i < n; i++)
			if(i != row)
			{
				if(a[i][col] == 0) continue;
			    	ll c = (a[i][col] * c_inv) % MOD;
			    	for(int j = 0; j <= m; j++)
				    a[i][j] = (a[i][j] - c * a[row][j] % MOD + MOD) % MOD;
			}
 
		row++;
    }
    vector<ll> ans(m, 0);
    ll result = 1;
    // for counting rank, take the count of where[i]==-1
    for(int i = 0; i < m; i++)
        if(where[i] != -1) ans[i] = (a[where[i]][m] * fexp(a[where[i]][i], MOD - 2)) % MOD;
		else result = (result * MOD) % MOD;
	// This is validity check probably wont be needed
    for(int i = 0; i < n; i++)
	{
		ll sum = a[i][m] % MOD;
		for(int j = 0; j < m; j++)
			sum = (sum + MOD - (ans[j] * a[i][j]) % MOD) % MOD;
	}
 
	return ans;
}
\end{lstlisting}

\subsection{Eliminacao Gaussiana Z2}
\begin{lstlisting}
// D eh dimensao do espaco vetorial
// add(v) - adiciona o vetor v na base (retorna se ele jah pertencia ao span da base)
// coord(v) - retorna as coordenadas (c) de v na base atual (basis^T.c = v)
// recover(v) - retorna as coordenadas de v nos vetores na ordem em que foram inseridos
// coord(v).first e recover(v).first - se v pertence ao span
//
// Complexidade:
// add, coord, recover: O(D^2 / 64)
// d0a4b3

template<int D> struct Gauss_z2 {
	bitset<D> basis[D], keep[D];
	int rk, in;
	vector<int> id;
	
	Gauss_z2 () : rk(0), in(-1), id(D, -1) {};

	bool add(bitset<D> v) {
		in++;
		bitset<D> k;
		for (int i = D - 1; i >= 0; i--) if (v[i]) {
			if (basis[i][i]) v ^= basis[i], k ^= keep[i];
			else {
				k[i] = true, id[i] = in, keep[i] = k;
				basis[i] = v, rk++;
				return true;
			}
		}
		return false;
	}
	pair<bool, bitset<D>> coord(bitset<D> v) {
		bitset<D> c;
		for (int i = D - 1; i >= 0; i--) if (v[i]) {
			if (basis[i][i]) v ^= basis[i], c[i] = true;
			else return {false, bitset<D>()};
		}
		return {true, c};
	}
	pair<bool, vector<int>> recover(bitset<D> v) {
		auto [span, bc] = coord(v);
		if (not span) return {false, {}};
		bitset<D> aux;
		for (int i = D - 1; i >= 0; i--) if (bc[i]) aux ^= keep[i];
		vector<int> oc;
		for (int i = D - 1; i >= 0; i--) if (aux[i]) oc.push_back(id[i]);
		return {true, oc};
	}
};
\end{lstlisting}

\subsection{Euler's Totient Function}
\begin{lstlisting}
// O(sqrt(n))

// be careful with overflow
int totient(int n){
	int ret = n;

	for (int i = 2; i*i <= n; i++) if (n % i == 0) {
		while (n % i == 0) n /= i;
		ret -= ret / i;
	}
	if (n > 1) ret -= ret / n;

	return ret;
}
\end{lstlisting}

\subsection{Exponenciacao de Matriz}
\begin{lstlisting}
// Exemplo de como usar em Broken Profile DP + Mat Expo
int tam;
struct mat {
	ll m[tam][tam];
	mat() {
		for (int i = 0; i < tam; i++) {
			for (int j = 0; j < tam; j++) m[i][j] = 0;
		}
	}
	mat operator * (mat x) {
		mat resp;
		for (int i = 0; i < tam; i++) {
			for (int j = 0; j < tam; j++) {
				resp.m[i][j] = 0;
				for (int k = 0; k < tam; k++) {
					resp.m[i][j] += (m[i][k] * x.m[k][j]) % MOD;
					if (resp.m[i][j] >= M) resp.m[i][j] -= MOD;
				}
			}
		}
		return resp;
	}
};
 
mat expo(mat &a, ll e) {
	if (e == 1) return a;
	mat ans = expo(a, e/2);
	ans = ans * ans;
	if (e&1) ans = ans * a;
	return ans;
}
\end{lstlisting}

\subsection{FFT}
\begin{lstlisting}
typedef complex<double> C;
void fft(vector<C>& a) {
    int n = a.size(), L = 31 - __builtin_clz(n);
    static vector<complex<long double>> R(2, 1);
    static vector<C> rt(2, 1);  // (^ 10% faster if double)
    for (static int k = 2; k < n; k *= 2) {
        R.resize(n); rt.resize(n);
        auto x = polar(1.0L, acos(-1.0L) / k);
        for (int i = k; i < 2 * k; i++) rt[i] = R[i] = i&1 ? R[i/2] * x : R[i/2];
    }
    vector<ll> rev(n);
    for (int i = 0; i < n; i++) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;
    for (int i = 0; i < n; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int k = 1; k < n; k *= 2) {
        for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                // C z = rt[j+k] * a[i+j+k]; // (25% faster if hand-rolled)  /// include-line
                auto x = (double *)&rt[j+k], y = (double *)&a[i+j+k];        /// exclude-line
                C z(x[0]*y[0] - x[1]*y[1], x[0]*y[1] + x[1]*y[0]);           /// exclude-line
                a[i + j + k] = a[i + j] - z;
                a[i + j] += z;
            }
        }
    }
}

vector<ll> conv(const vector<ll>& a, const vector<ll>& b) {
    if (a.empty() || b.empty()) return {};
    vector<ll> res(a.size() + b.size() - 1);
    int L = 32 - __builtin_clz(res.size()), n = 1 << L;
    vector<C> in(n), out(n);
    copy(a.begin(), a.end(), begin(in));
    for (int i = 0; i < b.size(); i++) in[i].imag(b[i]);
    fft(in);
    for (C &x : in) x *= x;
    for (int i = 0; i < n; i++) out[i] = in[-i & (n - 1)] - conj(in[i]);
    fft(out);
    for (int i = 0; i < res.size(); i++) res[i] = round(1.0*imag(out[i]) / (4 * n));
    return res;
}
\end{lstlisting}

\subsection{Miller-Rabin}
\begin{lstlisting}
// Testa se n eh primo, n <= 3 * 10^18
//
// O(log(n)), considerando multiplicacao
// e exponenciacao constantes
// 4ebecc

ll mul(ll a, ll b, ll m) {
	ll ret = a*b - ll((long double)1/m*a*b+0.5)*m;
	return ret < 0 ? ret+m : ret;
}

ll pow(ll x, ll y, ll m) {
	if (!y) return 1;
	ll ans = pow(mul(x, x, m), y/2, m);
	return y%2 ? mul(x, ans, m) : ans;
}

bool prime(ll n) {
	if (n < 2) return 0;
	if (n <= 3) return 1;
	if (n % 2 == 0) return 0;
	ll r = __builtin_ctzll(n - 1), d = n >> r;

 	// com esses primos, o teste funciona garantido para n <= 2^64
	// funciona para n <= 3*10^24 com os primos ate 41
	for (int a : {2, 325, 9375, 28178, 450775, 9780504, 795265022}) {
		ll x = pow(a, d, n);
		if (x == 1 or x == n - 1 or a % n == 0) continue;
		
		for (int j = 0; j < r - 1; j++) {
			x = mul(x, x, n);
			if (x == n - 1) break;
		}
		if (x != n - 1) return 0;
	}
	return 1;
}
\end{lstlisting}

\subsection{NTT}
\begin{lstlisting}
/**
 * NTT do KACTL
 * Description: ntt(a) computes $\hat f(k) = \sum_x a[x] g^{xk}$ for all $k$, where $g=\text{root}^{(MOD-1)/N}$.
 * N must be a power of 2.
 * Useful for convolution modulo specific nice primes of the form $2^a b+1$,
 * where the convolution result has size at most $2^a$. For arbitrary modulo, see FFTMod.
   \texttt{conv(a, b) = c}, where $c[x] = \sum a[i]b[x-i]$.
   For manual convolution: NTT the inputs, multiply
   pointwise, divide by n, reverse(start+1, end), NTT back.
 * Inputs must be in [0, MOD).
 * Time: O(N \log N)
 * Status: stress-tested
 */
const ll MOD = (119 << 23) + 1, root = 62; // = 998244353
// For p < 2^30 there is also e.g. 5 << 25, 7 << 26, 479 << 21
// and 483 << 21 (same root). The last two are > 10^9.
#pragma once

void ntt(vector<ll> &a) {
	int n = a.size(), L = 31 - __builtin_clz(n);
	static vector<ll> rt(2, 1);
	for (static int k = 2, s = 2; k < n; k *= 2, s++) {
		rt.resize(n);
		ll z[] = {1, fexp(root, MOD >> s)};
		for (int i = k; i < 2 * k; i++) rt[i] = rt[i / 2] * z[i & 1] % MOD;
	}
	vector<int> rev(n);
	for(int i = 0; i < n; i++) rev[i] = (rev[i / 2] | (i & 1) << L) / 2;
	for(int i = 0; i < n; i++) if (i < rev[i]) swap(a[i], a[rev[i]]);
	for (int k = 1; k < n; k *= 2) {
		for (int i = 0; i < n; i += 2 * k) {
            for (int j = 0; j < k; j++) {
                ll z = rt[j + k] * a[i + j + k] % MOD, &ai = a[i + j];
                a[i + j + k] = ai - z + (z > ai ? MOD : 0);
                ai += (ai + z >= MOD ? z - MOD : z);
            }
		}
    }
}
vector<ll> conv(const vector<ll> &a, const vector<ll> &b) {
	if (a.empty() || b.empty()) return {};
	int s = a.size() + b.size() - 1, B = 32 - __builtin_clz(s), n = 1 << B;
	int inv = fexp(n, MOD - 2);
	vector<ll> L(a), R(b), out(n);
	L.resize(n), R.resize(n);
	ntt(L), ntt(R);
	for(int i = 0; i < n; i++) out[-i & (n - 1)] = (ll)L[i] * R[i] % MOD * inv % MOD;
	ntt(out);
	return {out.begin(), out.begin() + s};
}
\end{lstlisting}

\subsection{Pollard's Rho Alg}
\begin{lstlisting}
// Usa o algoritmo de deteccao de ciclo de Floyd
// com uma otimizacao na qual o gcd eh acumulado
// A fatoracao nao sai necessariamente ordenada
// O algoritmo rho encontra um fator de n,
// e funciona muito bem quando n possui um fator pequeno
//
// Complexidades (considerando mul constante):
// rho - esperado O(n^(1/4)) no pior caso
// fact - esperado menos que O(n^(1/4) log(n)) no pior caso
// b00653

ll mul(ll a, ll b, ll m) {
	ll ret = a*b - ll((long double)1/m*a*b+0.5)*m;
	return ret < 0 ? ret+m : ret;
}

ll pow(ll x, ll y, ll m) {
	if (!y) return 1;
	ll ans = pow(mul(x, x, m), y/2, m);
	return y%2 ? mul(x, ans, m) : ans;
}

bool prime(ll n) {
	if (n < 2) return 0;
	if (n <= 3) return 1;
	if (n % 2 == 0) return 0;

	ll r = __builtin_ctzll(n - 1), d = n >> r;
	for (int a : {2, 325, 9375, 28178, 450775, 9780504, 795265022}) {
		ll x = pow(a, d, n);
		if (x == 1 or x == n - 1 or a % n == 0) continue;
		
		for (int j = 0; j < r - 1; j++) {
			x = mul(x, x, n);
			if (x == n - 1) break;
		}
		if (x != n - 1) return 0;
	}
	return 1;
}

ll rho(ll n) {
	if (n == 1 or prime(n)) return n;
	auto f = [n](ll x) {return mul(x, x, n) + 1;};

	ll x = 0, y = 0, t = 30, prd = 2, x0 = 1, q;
	while (t % 40 != 0 or gcd(prd, n) == 1) {
		if (x==y) x = ++x0, y = f(x);
		q = mul(prd, abs(x-y), n);
		if (q != 0) prd = q;
		x = f(x), y = f(f(y)), t++;
	}
	return gcd(prd, n);
}

vector<ll> fact(ll n) {
	if (n == 1) return {};
	if (prime(n)) return {n};
	ll d = rho(n);
	vector<ll> l = fact(d), r = fact(n / d);
	l.insert(l.end(), r.begin(), r.end());
	return l;
}
\end{lstlisting}

\subsection{Teorema Chines do Resto}
\begin{lstlisting}
// Combina equacoes modulares lineares: x = a (mod m)
// O m final eh o lcm dos m's, e a resposta eh unica mod o lcm
// Os m nao precisam ser coprimos
// Se nao tiver solucao, o 'a' vai ser -1
// 7cd7b3

template<typename T> tuple<T, T, T> ext_gcd(T a, T b) {
    if (!a) return {b, 0, 1};
    auto [g, x, y] = ext_gcd(b%a, a);
    return {g, y - b/a*x, x};
}

template<typename T = ll> struct crt {
	T a, m;

	crt() : a(0), m(1) {}
	crt(T a_, T m_) : a(a_), m(m_) {}
	crt operator * (crt C) {
		auto [g, x, y] = ext_gcd(m, C.m);
		if ((a - C.a) % g) a = -1;
		if (a == -1 or C.a == -1) return crt(-1, 0);
		T lcm = m/g*C.m;
		T ans = a + (x*(C.a-a)/g % (C.m/g))*m;
		return crt((ans % lcm + lcm) % lcm, lcm);
	}
};
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Problems
%
%%%%%%%%%%%%%%%%%%%%

\section{Problems}

\subsection{Birthday}
\begin{lstlisting}
// Given a set of strings, we want to find the maximal set of strings
// such that no string in the set is a substring of another string in the set
// Idea: Use Aho-Corasick to build the graph where a and b are connected
// if a is a substring of b
// Then we calculate the transitive closure of this graph, find the maximum antichain
// and recover this antichain

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 9;
const int MAXN = 1e3 + 5;
const int INF = 1e9;

// Aho-Corasick (Ber)
// 
// tamanho do alfabeto e soma dos tamanhos das strings
const int ALPHA = 2, SIZE = 1e7 + 5;
int I = 1;
 
// nodes do aho
// fail eh o fail link
// ch eh o automato
// podemos colocar mais coisas, tp um inteiro que diz quantas palavras terminam ali
// lembrando que temos que fazer uma dfs pra computar esse inteiro, por exemplo
struct node {
    int fail, nxt, ch[ALPHA] = {}, id = 0;
    bool end;
} T[SIZE];
 
void insert(string s, int i) {
    int x = 1;
    for (int j = 0; j < (int)s.size(); j++) {
        // mudar pra '0' se estivermos lidando com digitos
        if (T[x].ch[s[j] - 'a'] == 0)
            T[x].ch[s[j] - 'a'] = ++I;
        x = T[x].ch[s[j] - 'a'];
    }
    T[x].end |= 1;
    T[x].id = i;
}
 
void build() {
    queue<int> Q;
    int x = 1; 
    T[1].fail = 1;
    T[1].end = 1;
    T[1].id = -1;
    for (int i = 0; i < ALPHA; i++) {
        if (T[x].ch[i])
            T[T[x].ch[i]].fail = x, Q.push(T[x].ch[i]);
        else 
            T[x].ch[i] = 1;
    }
    while (!Q.empty()) {
        x = Q.front(); Q.pop();
        for (int i = 0; i < ALPHA; i++) {
            if (T[x].ch[i])
                T[T[x].ch[i]].fail = T[T[x].fail].ch[i], Q.push(T[x].ch[i]);
            else 
                T[x].ch[i] = T[T[x].fail].ch[i];
        }
        if (T[T[x].fail].end) T[x].nxt = T[T[x].fail].id;
        else T[x].nxt = T[T[x].fail].nxt;
    }
}

set<int> st[800];
vector<int> g[800];
int vis[800];

// rodar uma string pelo automato e computar alguma coisa
void run(string s, int at) {
    for (int i = 0, x = 1; i < s.size(); i++) {
        x = T[x].ch[s[i] - 'a'];
        if (i < s.size() - 1) {
            if (T[x].end)
                st[at].insert(T[x].id);
            else if (T[x].nxt != -1)
                st[at].insert(T[x].nxt);
        }
        else {
            if (T[x].nxt != -1)
                st[at].insert(T[x].nxt);
        }
    }
}

void dfs(int node, int root) {
    vis[node] = 1;
    if (node != root) g[root].push_back(node);
    for (int x : st[node]) 
        if (!vis[x]) dfs(x, root);
}

// Dinic
//
// O(min(m * max_flow, n^2 m))
// Grafo com capacidades 1 -> O(sqrt(n)*m)
// INF ta pra int
struct dinic {
	const bool scaling = false;
	int lim;
	struct edge {
		int to, cap, rev, flow;
		bool res;
		edge(int to_, int cap_, int rev_, bool res_)
			: to(to_), cap(cap_), rev(rev_), flow(0), res(res_) {}
	};

	vector<vector<edge>> g;
	vector<int> lev, beg;
	ll F;
	dinic(int n) : g(n), F(0) {}

	void add(int a, int b, int c) {
		g[a].emplace_back(b, c, g[b].size(), false);
		g[b].emplace_back(a, 0, g[a].size()-1, true);
	}
	bool bfs(int s, int t) {
		lev = vector<int>(g.size(), -1); lev[s] = 0;
		beg = vector<int>(g.size(), 0);
		queue<int> q; q.push(s);
		while (q.size()) {
			int u = q.front(); q.pop();
			for (auto& i : g[u]) {
				if (lev[i.to] != -1 or (i.flow == i.cap)) continue;
				if (scaling and i.cap - i.flow < lim) continue;
				lev[i.to] = lev[u] + 1;
				q.push(i.to);
			}
		}
		return lev[t] != -1;
	}
	int dfs(int v, int s, int f = INF) {
		if (!f or v == s) return f;
		for (int& i = beg[v]; i < g[v].size(); i++) {
			auto& e = g[v][i];
			if (lev[e.to] != lev[v] + 1) continue;
			int foi = dfs(e.to, s, min(f, e.cap - e.flow));
			if (!foi) continue;
			e.flow += foi, g[e.to][e.rev].flow -= foi;
			return foi;
		}
		return 0;
	}
	ll max_flow(int s, int t) {
		for (lim = scaling ? (1<<30) : 1; lim; lim /= 2)
			while (bfs(s, t)) while (int ff = dfs(s, t)) F += ff;
		return F;
	}

	// arestas com fluxo
	vector<pii> flow_edges(int s, int t) {
		max_flow(s, t);
		vector<pii> ans;
		int n = g.size();
		for (int i = 0; i < n; i++) {
			for (auto edge : g[i]) {
				if (!edge.res && edge.flow) 
					ans.emplace_back(i, edge.to);
			}
		}
		return ans;
	}

	// arestas no min cut
	vector<pii> cut_edges(int s, int t) {
		max_flow(s, t);
		vector<pii> cut;
		vector<int> vis(g.size(), 0), st = {s};
		vis[s] = 1;
		while (st.size()) {
			int u = st.back(); st.pop_back();
			for (auto e : g[u]) if (!vis[e.to] and e.flow < e.cap)
				vis[e.to] = 1, st.push_back(e.to);
		}
		for (int i = 0; i < g.size(); i++) for (auto e : g[i])
			if (vis[i] and !vis[e.to] and !e.res) cut.emplace_back(i, e.to);
		return cut;
	}
};

vector<string> v;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    v.resize(n);
    int at = 1;
    for (string &x : v) {
        cin >> x;
        insert(x, at++);
    }
    build();
    at = 1;
    for (string x : v) {
        run(x, at++);
    }
    for (int i = 1; i <= n; i++) {
        dfs(i, i);
        memset(vis, 0, sizeof(vis));
    }

    dinic ber(2 * n + 2);
    for (int i = 1; i <= n; i++) {
        ber.add(0, i, 1);
        for (int x : g[i]) ber.add(i, x + n, INF);
        ber.add(i + n, 2 * n + 1, 1);
    }
    vector<pii> ed = ber.cut_edges(0, 2 * n + 1);
    set<int> antichain;
    for (int i = 1; i <= n; i++) antichain.insert(i);
    for (pii x : ed) {
        if (x.first == 0) antichain.erase(x.second);
        else antichain.erase(x.first - n);
    }
    cout << antichain.size() << '\n';
    for (int x : antichain) cout << x << ' ';
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Broken Profile + Mat Expo}
\begin{lstlisting}
#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int M = 998244353;
 
struct mat {
	ll m[65][65];
	mat() {
		for (int i = 0; i < 65; i++) {
			for (int j = 0; j < 65; j++) m[i][j] = 0;
		}
	}
	mat operator * (mat x) {
		mat resp;
		for (int i = 0; i < 65; i++) {
			for (int j = 0; j < 65; j++) {
				resp.m[i][j] = 0;
				for (int k = 0; k < 65; k++) {
					resp.m[i][j] += (m[i][k] * x.m[k][j]) % M;
					if (resp.m[i][j] >= M) resp.m[i][j] -= M;
				}
			}
		}
		return resp;
	}
};
 
mat expo(mat &a, ll e) {
	if (e == 1) return a;
	mat ans = expo(a, e/2);
	ans = ans * ans;
	if (e&1) ans = ans * a;
	return ans;
}
 
int dp[7] = {1, 1, 2, 3, 5, 8, 13};
 
int main () { _
	int h;
	ll w;
	cin >> h >> w;
	mat freitas;
	for (int i = 0; i < (1<<h); i++) {
		for (int j = 0; j < (1<<h); j++) {
			int e = 1, count = 0;
			for (int k = 0; k < h; k++) {
				if (i & (1<<k)) {
					if (j & (1<<k)) e = 0;
					e *= dp[count];
					count = 0;
				}
				else if (j & (1<<k)) {
					e *= dp[count];
					count = 0;
				}
				else count++;
			}
			e *= dp[count];
			freitas.m[j][i] = e;
		}
	}
	freitas = expo(freitas, w);
	cout << freitas.m[0][0] << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Centroid: Query de distancia}
\begin{lstlisting}
// Query: Dado v e x, quantos vertices u tem tal que d(v, u) <= x?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
vector<pii> v[MAXN];
vector<ll> arv[MAXN], arv2[MAXN];
int sz[MAXN], pai[MAXN], lvl[MAXN], n, q;
bool vis[MAXN];
ll d[20][MAXN];


// centroid decomposition
int subtree(int node, int p = 0) {
    sz[node] = 1;
    for (pii x : v[node]) {
        if (!vis[x.first] && x.first != p) {
            sz[node] += subtree(x.first, node);
        }
    }
    return sz[node];
}
int centroid(int node, int desired, int p = 0) {
    for (pii x : v[node]) {
        if (!vis[x.first] && x.first != p && sz[x.first] > desired) {
            return centroid(x.first, desired, node);
        }
    }
    return node;
}
void dfs(int node, int p, int l, ll dist, int root) {
    d[l][node] = dist;
    for (pii x : v[node]) {
        if (!vis[x.first] && x.first != p) {
            dfs(x.first, node, l, dist + x.second, root);
        }
    }
}
void solve(int node, int p = 0) {
    int c = centroid(node, subtree(node) / 2);
    vis[c] = true;
    if (p == 0) {
        pai[c] = c;
        lvl[c] = 0;
    }
    else {
        pai[c] = p;
        lvl[c] = lvl[p] + 1;
    }
    dfs(c, p, lvl[c], 0, c);
    for (pii x : v[c]) {
        if (!vis[x.first]) {
            solve(x.first, c);
        }
    }
}
void build_arv() {
	for (int i = 1; i <= n; i++) {
		int u = i;
		while(1) {
			arv[u].push_back(d[lvl[u]][i]);
			if(u == pai[u])break;
			u = pai[u];
		}
	}
	for(int i = 1; i <= n; i++)
		sort(arv[i].begin(), arv[i].end());
}
void build_arv2() {
    for (int i = 1; i <= n; i++) {
		int u = i;
		while(1) {
			arv2[u].push_back(d[lvl[pai[u]]][i]);
			if(u == pai[u])break;
			u = pai[u];
		}
	}
	for(int i = 1; i <= n; i++)
		sort(arv2[i].begin(), arv2[i].end());
}
 
 
// queries
int query(int node, ll dist) {
    int ans = 0, x = node;
    ans += (upper_bound(arv[x].begin(), arv[x].end(), dist) - arv[x].begin());
    while (true) {
        if (x == pai[x]) break;
        ans += (upper_bound(arv[pai[x]].begin(), arv[pai[x]].end(), dist - d[lvl[pai[x]]][node]) - arv[pai[x]].begin());
        ans -= (upper_bound(arv2[x].begin(), arv2[x].end(), dist - d[lvl[pai[x]]][node]) - arv2[x].begin());
        x = pai[x];
    }
    return ans;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> q;
    int a, b, c;
    for (int i = 0; i < n - 1; i++) {
        cin >> a >> b >> c;
        v[a].emplace_back(b, c);
        v[b].emplace_back(a, c);
    }
    solve(1);
    build_arv();
    build_arv2();
    ll v, l;
    while (q--) {
        cin >> v >> l;
        cout << query(v, l) << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{Convex Hull Trick}
\begin{lstlisting}
#include<bits/stdc++.h>
	
using namespace std;
const int MAXN = 100100;
	
#define int long long
	
int t[MAXN];
int a[MAXN],b[MAXN];
int dp[MAXN];
	
int comp(int a,int c,int x){
	if(dp[a] + b[a] * x >= dp[c] + b[c] * x) return 1;
	return 0;
}
	
double f(int x,int y){
	return double(dp[x] - dp[y]) / double(b[y] - b[x]);
}
	
signed main(){
	int n;
	cin >> n;
	
	for(int i = 1;i <= n;i++) cin >> a[i];
	for(int i = 1;i <= n;i++) cin >> b[i];
	
	// dp[i] = dp[j] + bj * ai 
	
	int ini = 1,fim = 1;
	t[1] = 1;
	dp[1] = 0;
	
	for(int i = 2;i <= n;i++){
		while(ini < fim && comp(t[ini],t[ini + 1],a[i]) == 1) ini ++;
		dp[i] = dp[t[ini]] + b[t[ini]] * a[i];
		while(ini < fim && f(i,t[fim]) <= f(t[fim],t[fim - 1])) fim --;
		t[++fim] = i;
	}
	
	cout << dp[n] << endl;
}
\end{lstlisting}

\subsection{Divide and Conquer Optmization}
\begin{lstlisting}
#include<bits/stdc++.h>
    
using namespace std;
const int MAXN = 4010;
const int INF = 0x3f3f3f3f;
    
int v[MAXN][MAXN];
int c[MAXN][MAXN];
int s[MAXN][MAXN];
int memo[1000][MAXN];
int aux[MAXN];
    
void divide_opt(int l,int r,int optl,int optr,int it){
    int meio = (r + l) / 2;
    
    if(l > r) return;
    
    pair<int,int> best = {INF,-1};
    for(int i = optl;i <= min(optr,meio);i++){
        best = min(best,{memo[it - 1][i] + c[meio][i + 1],i});
    }
    
    memo[it][meio] = best.first;
    if(l == r) return;
    
    divide_opt(l,meio - 1,optl,best.second,it);
    divide_opt(meio + 1,r,best.second,optr,it);
}	
    
int read()
{
    int ret = 0;
    char c;
    while(!isdigit(c = getchar()));
    ret += c - '0';
    while(isdigit(c = getchar()))
        ret = 10 * ret + c - '0';
    return ret;
}
    
int main(){
    ios_base::sync_with_stdio(false), cin.tie(0);
    
    int n,k;
    n = read() , k = read();
    
    for(int i = 1;i <= n;i++)
        for(int j = 1;j <= n;j++){
            s[i][j] = s[i][j - 1]; 
            v[i][j] = read();
    
            s[i][j] += v[i][j];
        }
    
    for(int i = 1;i <= n;i++){
        for(int j = 1;j < i;j++){
            c[i][j] = c[i - 1][j] + s[i][i] - s[i][j - 1];
        }
    }
    
    memset(memo,INF,sizeof memo);
    memo[0][0] = 0;
    for(int i = 1;i <= k;i++){
        divide_opt(1,n,0,n,i);
    }
    
    printf("%d\n",memo[k][n]);
}
\end{lstlisting}

\subsection{Dynamic Connectivity}
\begin{lstlisting}
// Two types of queries:
// A new edge is created between nodes a and b
// An existing edge between nodes a and b is removed.

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const int INF = 2e9;

int ans[MAXN], pai[MAXN], sz[MAXN], resp;
map<pii, int> mp;
stack<int> st;

// Seg

struct no {
    vector<pii> v;
    no() {
        v = vector<pii> ();
    }
} a[4 * MAXN];
 
void update(int node, int i, int j, int ini, int fim, pii val) {
    if (j < ini || i > fim) return;
    else if (ini <= i && j <= fim) {
        a[node].v.push_back(val);
    }
    else {
        int m = (i + j) / 2;
        update(2 * node, i, m, ini, fim, val);
        update(2 * node + 1, m + 1, j, ini, fim, val);
    }
}
 
// DSU
 
int find(int x) {
    if (x == pai[x]) return x;
    return find(pai[x]);
}
 
void join(int a, int b) {
    a = find(a), b = find(b);
    if (sz[a] < sz[b]) {
        swap(a, b);
    }
    pai[b] = a;
    sz[a] += sz[b];
    st.push(b);
    resp--;
}
 
void rollback() {
    int at = st.top();
    st.pop();
    sz[pai[at]] -= sz[at];
    pai[at] = at;
    resp++;
}
 
//
 
void dfs(int node, int i, int j) {
    int cnt = 0;
    for (auto x : a[node].v) {
        if (find(x.first) != find(x.second)) {
            join(x.first, x.second);
            cnt++;
        }
    }
    if (i == j) {
        ans[i] = resp;
    }
    else {
        int m = (i + j) / 2;
        dfs(2 * node, i, m);
        dfs(2 * node + 1, m + 1, j);
    }
    for (int i = 0; i < cnt; i++) {
        rollback();
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, k, tipo, a, b;
    cin >> n >> m >> k;
    resp = n;
    for (int i = 1; i <= n; i++) pai[i] = i, sz[i] = 1;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        if (a > b) swap(a, b);
        mp[{a, b}] = 0;
    }
    for (int i = 1; i <= k; i++) {
        // tempo i
 
        cin >> tipo >> a >> b;
        if (a > b) swap(a, b);
        if (tipo == 1) {
            mp[{a, b}] = i;
        }
        else {
            update(1, 0, k + 1, mp[{a, b}], i - 1, {a, b});
            mp[{a, b}] = -1;
        }
    }
    for (auto x : mp) {
        // se x.second nao for -1, preciso fechar o intervalo da aresta
        
        if (x.second == -1) continue;
        update(1, 0, k + 1, x.second, k + 1, x.first);
    }
    dfs(1, 0, k + 1);
    for (int i = 0; i <= k; i++) cout << ans[i] << ' ';
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Li Chao Tree}
\begin{lstlisting}
#include<bits/stdc++.h>
    
using namespace std;
const int MAXN = 100100;
    
#define int long long
const long long INF = 0x3f3f3f3f;
    
pair<long long,long long> linf = {INF,INF*INF};
    
struct lct{
    lct *fe,*fd;
    int l,r,meio;
    pair<long long,long long> p;
    
    lct(int x,int y){
        l = x,r = y;
        meio = (x + y) / 2;
        if(meio == y && x != y) meio --;
    
        p = linf;
        fe = fd = NULL;
    }
    
    pair<pair<int,int>,int> comp(pair<int,int> k1,pair<int,int> k2){
        if(k1.first < k2.first) swap(k1,k2);
    
        if(k1.first * meio + k1.second <= k2.first * meio + k2.second){
            p = k1;
            return {k2,1};
        }
    
        p = k2;
        return {k1,0};
    }
    
    pair<int,int> minx(pair<int,int> k,int x){
        if(k.first * x + k.second <= p.first * x + p.second) return k;
        return p;
    }
    
    int res(pair<int,int> k,int x){
        return k.first * x + k.second;
    }
    
    void up(pair<int,int> ll){
        pair<pair<int,int>,int> k = comp(ll,p);
    
        if(l == r) return;
    
        if(k.second == 0){
            if(fe == NULL) fe = new lct(l,meio);
            fe->up(k.first);
        }
        else{
            if(fd == NULL) fd = new lct(meio + 1,r);
            fd->up(k.first);
        }
    }
    
    int get(pair<int,int> ll,int x){
        ll = minx(ll,x);
        if(l == r) return res(ll,x);
        if(x <= meio){
            if(fe == NULL) return res(ll,x);
            return fe->get(ll,x);
        } 
        else{
            if(fd == NULL) return res(ll,x);
            return fd->get(ll,x);
        }
    }
    
    ~lct(){
        if(fe != NULL) delete fe;
        if(fd != NULL) delete fd;
    }
};
    
int a[MAXN] , b[MAXN];
vector<pair<int,int>> vec[MAXN];
vector<int> grafo[MAXN];
long long p[MAXN],res[MAXN];
bool vis[MAXN];
lct *tree[MAXN];
    
void dfs(int x){
    vis[x] = true;
    
    pair<int,int> mex = {0,0};
    for(auto i : grafo[x]){
        if(vis[i] == true) continue;
        dfs(i);
    
        if(vec[p[i]].size() > mex.first) mex = {vec[p[i]].size(),p[i]};
    }
    
    if(mex.first == 0) p[x] = x;
    else p[x] = mex.second;
    
    if(mex.second == 0) tree[x] = new lct(-MAXN,MAXN);
    else tree[x] = tree[mex.second];
    
    for(auto i : grafo[x]){
        if(p[i] == mex.second) continue;
    
        for(auto j : vec[p[i]]){
            tree[x]->up(j);
            vec[p[x]].push_back(j);
        }
    
        delete tree[p[i]];
    }
    
    if(mex.second != 0) res[x] = tree[x]->get(linf,a[x]);
    
    tree[x]->up({b[x],res[x]});
    vec[p[x]].push_back({b[x],res[x]});
}
    
signed main(){
    int n;
    cin >> n;
    
    for(int i = 1;i <= n;i++) cin >> a[i];
    for(int i = 1;i <= n;i++) cin >> b[i];
    
    for(int i = 1;i < n;i++){
        int x,y;
        cin >> x >> y;
        grafo[x].push_back(y);
        grafo[y].push_back(x);
    }
    
    dfs(1);
    
    for(int i = 1;i <= n;i++) cout << res[i] << " ";
    cout << endl;
}
\end{lstlisting}

\subsection{Mo}
\begin{lstlisting}

const int X = 700;
 
struct que {
	int ans, l, r, b, id;
};
 
vector<que> qs;
 
int main() {
	int n, q;
	cin >> n >> q;
    // probably receive some input here
	que aux;
	for (int i = 0; i < q; i++) {
		cin >> aux.l >> aux.r;
		aux.id = i;
		aux.l--, aux.r--;
		aux.b = aux.l/X;
		qs.pb(aux);
	}
	sort(qs.begin(), qs.end(), [&] (que x, que y) {
		if (x.b != y.b) return x.b < y.b;
		return x.r < y.r;
	});
	int la, ra, resp;
	for (int i = 0; i < q; i++) {
		if (i == 0 || qs[i].b != qs[i-1].b) {
			// new batch
            // initialize resp
			resp = 0;
			for (int j = qs[i].l; j <= qs[i].r; j++) {
                // go forward
			}
		}
		else {
			for (int j = ra+1; j <= qs[i].r; j++) {
                // go forward
			}
			for (int j = la-1; j >= qs[i].l; j--) {
                // go backwards
			}
			for (int j = la; j < qs[i].l; j++) {
                // go forward
			}
		}
		qs[i].ans = resp;
		la = qs[i].l, ra = qs[i].r;
	}
	sort(qs.begin(), qs.end(), [&] (que x, que y) { return x.id < y.id; });
	for (que x : qs) cout << x.ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Mo + DSU}
\begin{lstlisting}

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 5e4 + 5;
const int INF = 2e9;
 
const int X = 225;

struct que {
	int ans, l, r, b, id;
};
 
int resp, ra, cnt;
vector<que> qs;
pii ed[MAXN];
int pai[MAXN], sz[MAXN];
stack<int> st;

int find(int x) {
    if (x == pai[x]) return x;
    return find(pai[x]);
}
 
void join(int a, int b) {
    a = find(a), b = find(b);
    if (sz[a] < sz[b]) {
        swap(a, b);
    }
    pai[b] = a;
    sz[a] += sz[b];
    st.push(b);
    resp--;
}

void rollback() {
    int at = st.top();
    st.pop();
    sz[pai[at]] -= sz[at];
    pai[at] = at;
    resp++;
}

int main() { 
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> ed[i].first >> ed[i].second;
	}
    int q;
    cin >> q;
    que aux;
	for (int i = 0; i < q; i++) {
		cin >> aux.l >> aux.r;
		aux.id = i;
		aux.b = aux.l/X;
		qs.push_back(aux);
	}
	sort(qs.begin(), qs.end(), [&] (que x, que y) {
		if (x.b != y.b) return x.b < y.b;
		return x.r < y.r;
	});
	for (int i = 0; i < q; i++) {
		if (i == 0 || qs[i].b != qs[i - 1].b) {
			// new batch
            while (!st.empty()) st.pop();
            for (int j = 1; j <= n; j++) {
                sz[j] = 1;
                pai[j] = j;
            }
			resp = n, ra = (qs[i].b + 1) * X - 1;
		}
        if (qs[i].r < (qs[i].b + 1) * X) {
            // naive
            for (int j = qs[i].l; j <= qs[i].r; j++) {
                if (find(ed[j].first) != find(ed[j].second)) {
                    cnt++;
                    join(ed[j].first, ed[j].second);
                }
            }
            qs[i].ans = resp;
            while (cnt) {
                rollback();
                cnt--;
            }
        }
        else {
            for (int j = ra + 1; j <= qs[i].r; j++) {
                if (find(ed[j].first) != find(ed[j].second)) {
                    join(ed[j].first, ed[j].second);
                }
            }
            for (int j = qs[i].l; j < (qs[i].b + 1) * X; j++) {
                if (find(ed[j].first) != find(ed[j].second)) {
                    cnt++;
                    join(ed[j].first, ed[j].second);
                }
            }
            ra = qs[i].r;
            qs[i].ans = resp;
            while (cnt) {
                rollback();
                cnt--;
            }
        }
	}

	sort(qs.begin(), qs.end(), [&] (que x, que y) { return x.id < y.id; });
	for (que x : qs) cout << x.ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Mo + DSU + Bipartition}
\begin{lstlisting}

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const int INF = 2e9;
 
const int X = 400;

struct que {
	int ans, l, r, b, id;
};
 
int resp, ra, cnt;
vector<que> qs;
pii ed[MAXN];
int pai[MAXN], sz[MAXN], len[MAXN];
stack<pii> st;

pii find(int x) {
    if (x == pai[x]) return {x, len[x]};
    pii ans = find(pai[x]);
    return {ans.first, ans.second ^ len[x]};
}
 
void join(int a, int b) {
    pii c = find(a), d = find(b);
    if (sz[c.first] < sz[d.first]) {
        swap(c, d);
    }
    pai[d.first] = c.first;
    sz[c.first] += sz[d.first];
    st.push({d.first, len[d.first]});
    len[d.first] = 1 ^ c.second ^ d.second;
}

void rollback() {
    pii at = st.top();
    st.pop();
    if (at.first) {
        sz[pai[at.first]] -= sz[at.first];
        len[at.first] = at.second;
        pai[at.first] = at.first;
    }
    else resp = 1;
}

int main() { 
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m, q;
	cin >> n >> m >> q;
	for (int i = 1; i <= m; i++) {
		cin >> ed[i].first >> ed[i].second;
	}
    que aux;
	for (int i = 0; i < q; i++) {
		cin >> aux.l >> aux.r;
		aux.id = i;
		aux.b = aux.l/X;
		qs.push_back(aux);
	}
	sort(qs.begin(), qs.end(), [&] (que x, que y) {
		if (x.b != y.b) return x.b < y.b;
		return x.r < y.r;
	});
	for (int i = 0; i < q; i++) {
		if (i == 0 || qs[i].b != qs[i - 1].b) {
			// new batch
            while (!st.empty()) st.pop();
            for (int j = 1; j <= n; j++) {
                sz[j] = 1;
                pai[j] = j;
                len[j] = 0;
            }
			resp = 1, ra = (qs[i].b + 1) * X - 1;
		}
        if (qs[i].r < (qs[i].b + 1) * X) {
            // naive
            for (int j = qs[i].l; j <= qs[i].r; j++) {
                pii c = find(ed[j].first), d = find(ed[j].second);
                if (c.first != d.first) {
                    cnt++;
                    join(ed[j].first, ed[j].second);
                }
                else {
                    if (resp == 1 && c.second ^ d.second == 0) {
                        cnt++;
                        resp = 0;
                        st.push({0, 0});
                    }
                }
            }
            qs[i].ans = resp;
            while (cnt) {
                rollback();
                cnt--;
            }
        }
        else {
            for (int j = ra + 1; j <= qs[i].r; j++) {
                pii c = find(ed[j].first), d = find(ed[j].second);
                if (c.first != d.first) {
                    join(ed[j].first, ed[j].second);
                }
                else {
                    if (resp == 1 && c.second ^ d.second == 0) {
                        resp = 0;
                        st.push({0, 0});
                    }
                }
            }
            for (int j = qs[i].l; j < (qs[i].b + 1) * X; j++) {
                pii c = find(ed[j].first), d = find(ed[j].second);
                if (c.first != d.first) {
                    cnt++;
                    join(ed[j].first, ed[j].second);
                }
                else {
                    if (resp == 1 && c.second ^ d.second == 0) {
                        cnt++;
                        resp = 0;
                        st.push({0, 0});
                    }
                }
            }
            ra = qs[i].r;
            qs[i].ans = resp;
            while (cnt) {
                rollback();
                cnt--;
            }
        }
	}

	sort(qs.begin(), qs.end(), [&] (que x, que y) { return x.id < y.id; });
	for (que x : qs) cout << (x.ans ? "Possible\n" : "Impossible\n");
    return 0;
}
\end{lstlisting}

\subsection{MST-XOR}
\begin{lstlisting}
// You are given a complete undirected graph with n vertices. 
// A number ai is assigned to each vertex, and the weight of an edge between vertices i and j is equal to ai xor aj.
// Calculate the weight of the minimum spanning tree in this graph.

#include <bits/stdc++.h>

using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;

mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;

int at = 0, trie[(int)6e6 + 5][2], qtd[(int)6e6 + 5];
int p[MAXN], sz[MAXN];
pii mn[MAXN]; 
vector<int> cmp[MAXN];
set<int> comps, apaga;
map<int, int> mp;

int find(int x) { return p[x] = (x == p[x] ? x : find(p[x])); }

void join(int a, int b) {
    a = find(a), b = find(b);
    if (sz[a] < sz[b]) swap(a, b);
    for (int x : cmp[b]) {
        cmp[a].push_back(x);
    }
    p[b] = a;
    sz[a] += sz[b];
    apaga.insert(b);
    cmp[b].clear();
}

void insert(int x, int add) {
    int node = 0;
    for (int i = 29; i >= 0; i--) {
        int &a = trie[node][!!(x & (1 << i))];
        if (!a) {
            a = ++at;
        }
        node = a;
        qtd[node] += add;
    }
}

pii mini(int x) {
    int node = 0, ans = 0, val = 0;
    for (int i = 29; i >= 0; i--) {
        if (trie[node][!!(x & (1 << i))] && qtd[trie[node][!!(x & (1 << i))]]) {
            node = trie[node][!!(x & (1 << i))];
            val += (x & (1 << i));
        }
        else {
            node = trie[node][!(x & (1 << i))];
            val += ((x & (1 << i)) ? 0 : (1 << i));
            ans += (1 << i);
        }
    }
    return {ans, find(mp[val])};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, aux;
    ll ans = 0;
    cin >> n;
    set<int> st;
    for (int i = 0; i < n; i++) {
        cin >> aux;
        st.insert(aux);
    }
    n = st.size();
    int cnt = 0;
    for (int x : st) {
        mp[x] = cnt;
        comps.insert(cnt);
        insert(x, 1);
        cmp[cnt].push_back(x);
        p[cnt] = cnt;
        sz[cnt] = 1;
        cnt++;
    }
    int qtd = n;
    while (qtd > 1) {
        for (int i : comps) {
            mn[i] = {(1 << 30), 0};
            for (int x : cmp[i]) {
                insert(x, -1);
            }
            for (int x : cmp[i]) {
                mn[i] = min(mn[i], mini(x));
            }
            for (int x : cmp[i]) {
                insert(x, 1);
            }
        }
        int nqtd = qtd;
        for (int i : comps) {
            if (find(mn[i].second) != find(i)) {
                // join
                nqtd--;
                ans += mn[i].first;
                join(mn[i].second, i);
            }
        }
        for (int x : apaga) comps.erase(x);
        apaga.clear();
        qtd = nqtd;
    }
    cout << ans << '\n';
    return 0;
};
\end{lstlisting}

\subsection{nclude<bits/stdc++.h>
}
\begin{lstlisting}
using namespace std;
#define int long long
 
const int MAXN = 2001000;
const int mod = 1000000007;
 
int n,k;
int fat[MAXN], y[MAXN];
 
int powmod(int a,int b){
  int res = 1;
  while(b > 0){
    if(b % 2 == 0) a *= a, a %= mod, b /= 2;
    else res *= a, res %= mod, b --;
  }
 
  return res;
}
 
int inter(int x){
 
  for(int i = 1;i <= k + 2;i++){
    y[i] = y[i - 1] + powmod(i,k);
    y[i] %= mod;
  }
 
  
  if(x <= k + 2) return y[x];
  k += 2;
  
  int px = 1;
  fat[0] = 1;
  for(int i = 1;i <= k;i++){ 
    px *= i - x;
    px %= mod;
 
    fat[i] = fat[i - 1] * i;
    fat[i] %= mod;
  }
  
  int res = 0;
  for(int i = 1;i <= k;i++){
    int at = px * powmod(i - x,mod - 2);
    at %= mod;
    
    at *= y[i];
    at %= mod;

    at *= powmod(fat[k - i],mod-2);
    at %= mod;
    
    if(i % 2 == 0) at *= -powmod(fat[i - 1],mod-2);
    else at *= powmod(fat[i - 1],mod-2);
    at %= mod;
 
    res += at;
    res %= mod;
  }
 
  return res;
}

// Radeck eh baitola
 
signed main(){
  cin >> n >> k;
 
  cout << (inter(n) + mod) % mod << endl;
}
\end{lstlisting}

\subsection{Parallel Binary Search}
\begin{lstlisting}
// M da Subregional 2022 - Hopscotch Marathon

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const int INF = 2e9;

int a[MAXN], cmp[MAXN], ans[MAXN];
ll primes[MAXN];
pii v[MAXN];

void add(int id, ll mul) {
    int c = v[id].first, d = v[id].second;
    vector<int> primos;
    while (c != 1) {
        primos.push_back(cmp[c]);
        c /= cmp[c];
    }
    sort(primos.begin(), primos.end());
    primos.erase(unique(primos.begin(), primos.end()), primos.end());
    int tam = primos.size();
    for (int msk = 1; msk < (1 << tam); msk++) {
        int num = 1;
        for (int j = 0; j < tam; j++) {
            if (msk & (1 << j)) num *= primos[j];
        }
        if (__builtin_popcount(msk) & 1) {
            primes[num] += mul * d;
        }
        else {
            primes[num] -= mul * d;
        }
    }
}

ll get_walk(int c) {
    vector<int> primos;
    while (c != 1) {
        primos.push_back(cmp[c]);
        c /= cmp[c];
    }
    sort(primos.begin(), primos.end());
    primos.erase(unique(primos.begin(), primos.end()), primos.end());
    int tam = primos.size();
    ll ans = 0;
    for (int msk = 1; msk < (1 << tam); msk++) {
        int num = 1;
        for (int j = 0; j < tam; j++) {
            if (msk & (1 << j)) num *= primos[j];
        }
        ans += primes[num];
    }
    return ans;
}

void parallel_binary_search(int l, int r, vector<int> &candidates) {
    
    if (candidates.empty()) return;
    if (l == r) {
        for (int x : candidates) {
            ans[x] = r;
        }
        return;
    }
    int m = (l + r) / 2;
    for (int i = l; i <= m; i++) add(i, 1);
    vector<int> ok, nok;

    for (int x : candidates) {
        if (get_walk(x) >= a[x]) ok.push_back(x);
        else nok.push_back(x);
    }
    candidates.clear();
    parallel_binary_search(m + 1, r, nok);
    for (int i = l; i <= m; i++) add(i, -1);
    parallel_binary_search(l, m, ok);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    for (int i = 2; i < MAXN; i++) {
        if (!cmp[i]) {
            for (int j = i; j < MAXN; j += i) cmp[j] = i;
        }
    }
    int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 0; i < q; i++) cin >> v[i].first >> v[i].second;
    vector<int> candidates;
    for (int i = 1; i <= n; i++) candidates.push_back(i);
    parallel_binary_search(0, q, candidates);
    for (int i = 1; i <= n; i++) cout << (ans[i] == q ? -1 : ans[i] + 1) << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Sack}
\begin{lstlisting}
// Lomsat Gelral
// Given a tree where every node has a color
// You have to find for every vertex the sum of dominanting colors
// of the subtree of that vertex
// A color is dominating a subtree if no other color appears more than that color
// Which means that more than one color can dominate

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;

vector<int> v[MAXN];
int cnt[MAXN], cor[MAXN], sz[MAXN], vsf;
ll ans[MAXN], qtd[MAXN];
bool big[MAXN];

int calcSz(int node, int pai) {
    sz[node] = 1;
    for (int x : v[node]) {
        if (x != pai) {
            sz[node] += calcSz(x, node);
        }
    }
    return sz[node];
}

// This is specific to the sack problem
void add(int node, int pai, int val) {
    qtd[cnt[cor[node]]] -= cor[node];
    cnt[cor[node]] += val;
    vsf = max(vsf, cnt[cor[node]]);
    qtd[cnt[cor[node]]] += cor[node];
    if (vsf && !qtd[vsf]) vsf--;
    for (int x : v[node]) {
        if (x != pai && !big[x]) {
            add(x, node, val);
        }
    }
}

void dfs(int node, int pai, bool keep) {
	// Find the bigChild
    int mx = -1, bigChild = -1;
    for (int x : v[node]) {
        if (x != pai && sz[x] > mx) {
            mx = sz[x], bigChild = x;
        }
    }
    // Find the answer for every small child and clear them from cnt
    for (int x : v[node]) {
        if (x != pai && x != bigChild) {
            dfs(x, node, 0);
        }
    }
    // Find the answer for the bigChild and maintain it in cnt
    // Mark the bigChild as big so that you dont add it to cnt again on add(node, pai, 1)
    if (bigChild != -1)
        dfs(bigChild, node, 1), big[bigChild] = 1;
    
    // Add the rest of the subtree of node to cnt
    add(node, pai, 1);
    // Save the answer
    ans[node] = qtd[vsf];
    if (bigChild != -1)
        big[bigChild] = 0;
    if(keep == 0)
        add(node, pai, -1);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, a, b;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> cor[i];
    for (int i = 0; i < n - 1; i++) {
        cin >> a >> b;
        v[a].push_back(b);
        v[b].push_back(a);
    }
    // First Calculate the size of every subtree
    calcSz(1, 0);
    // Dfs to calculate the answer
    dfs(1, 0, 0);
    for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Seg Beats}
\begin{lstlisting}
struct seg{
    seg *fe,*fd;
    int meio,l,r,soma,mix,smix,qmix,lazy;
 
    seg(int x,int y){
        meio = (x + y) / 2;
        l = x,r = y;
        soma = mix = lazy = 0;
        smix = INF;
        qmix = r - l + 1;
 
        if(l == r) return;
 
        fe = new seg(x,meio);
        fd = new seg(meio + 1,y);
    }
 
    void lazyup(){
        if(lazy == 0) return;
        if(mix >= lazy){
            lazy = 0;
            return;
        }
 
        soma += qmix * (lazy - mix);
        mix = max(mix,lazy);
 
        if(l != r)
            fe->lazy = max(fe->lazy,lazy), fd->lazy = max(fd->lazy,lazy);
        lazy = 0;
    }
 
    void up(int a,int b,int novo){
        lazyup();
        if(l > b || r < a || mix >= novo) return;
        if(l >= a && r <= b && smix > novo){
            lazy = novo;
            lazyup();
            return;
        }
 
        fe->up(a,b,novo);
        fd->up(a,b,novo);
 
        map<int,int> mapa;
        mapa[fe->mix] += fe->qmix;
        mapa[fd->mix] += fd->qmix37cc0d1;
        mapa[fe->smix] = 1;
        mapa[fd->smix] = 1;
 
        soma = fe->soma + fd->soma;
 
        int conta = 0;
 
        for(auto i : mapa){
            if(conta == 0){
                mix = i.first;
                qmix = i.second;
            }
            else{
                smix = i.first;
                break;
            }
            conta ++;
        }
    }
 
    int get(int a,int b){
        lazyup();
        if(l >= a && r <= b) return soma;
        if(l > b || r < a) return 0;
        return fe->get(a,b) + fd->get(a,b);
    }
};

﻿
\end{lstlisting}

\subsection{Sqrt Min Vector Partition}
\begin{lstlisting}
// Sqrt RMQ

#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 10;
const int SQ = 326;
int v[MAXN], mx[SQ], bl[MAXN], e[SQ], d[SQ];
int main() {
	for(int i = 0; i < SQ; i++) e[i] = MAXN;
	for(int i = 0; i < MAXN; i++) {
		bl[i] = i / SQ;
		e[bl[i]] = min(i, e[bl[i]]);
		d[bl[i]] = max(d[bl[i]], i);
	}
	int t;
	scanf("%d", &t);
	for(int ab = 0; ab < t; ab++) {
		printf("Scenario #%d:\n", ab + 1);
		int n, q;
		for(int i = 0; i < SQ; i++) {
			mx[i] = 1123456789;
		}
		scanf("%d %d", &n, &q);
		for(int i = 0; i < n; i++) {
			scanf("%d", &v[i]);
			mx[bl[i]] = min(mx[bl[i]], v[i]);
		}
		for(int i = 0; i < q; i++) {
			int a, b;
			scanf("%d %d", &a, &b); a--; b--;
			int resp = 1123456789;
			if(bl[a] == bl[b]) {
				for(int j = a; j <= b; j++) {
					resp = min(v[j], resp);
				}
			}
			else {
				for(int j = a; j <= d[bl[a]]; j++) {
					resp = min(resp, v[j]);
				}
				for(int j = b; j >= e[bl[b]]; j--) {
					resp = min(resp, v[j]);
				}
				for(int j = bl[a] + 1; j <= bl[b] - 1; j++) {
					resp = min(mx[j], resp);
				}
			}
			printf("%d\n", resp);
		}
	}
	return 0;
} 
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Structures
%
%%%%%%%%%%%%%%%%%%%%

\section{Structures}

\subsection{BIT 2D}
\begin{lstlisting}

struct bit2d{
    vector<int> x;
    vector<vector<int>> y, bit;
 
    bit2d(vector<pair<int,int>> p){
        sort(p.begin(),p.end());
 
        for(auto i : p){
            if(x.size() == 0 || x.back() != i.first)
                x.push_back(i.first);
        }
 
        bit.resize(x.size() + 1);
        y.resize(bit.size());
 
        for(auto &i : p){
            swap(i.first,i.second);
        }
 
        sort(p.begin(),p.end());
 
 
        for(auto &i : p){
            swap(i.first,i.second);
 
            for(int j = upper_bound(x.begin(),x.end(),i.first) - x.begin();j < bit.size();j += (j&-j)){
                if(y[j].size() == 0 || y[j].back() != i.second)
                    y[j].push_back(i.second);
            }
        }
    
        for(int i = 0;i < bit.size();i++){
            bit[i].resize(y[i].size() + 1,0);
        }
    }
 
    void up(pair<int,int> p,int novo){
        for(int i = upper_bound(x.begin(),x.end(),p.first) - x.begin();i < bit.size();i += (i&-i)){
            for(int j = upper_bound(y[i].begin(),y[i].end(),p.second) - y[i].begin();j < bit[i].size();j += (j&-j)){
                bit[i][j] += novo;
            }
        }
    }
 
    int get(pair<int,int> p){
        int res = 0;
        for(int i = upper_bound(x.begin(),x.end(),p.first) - x.begin();i > 0;i -= (i&-i)){
            for(int j = upper_bound(y[i].begin(),y[i].end(),p.second) - y[i].begin();j > 0;j -= (j&-j)){
                res += bit[i][j];
            }
        }
        return res;
    }
};
\end{lstlisting}

\subsection{Coordinate Compression}
\begin{lstlisting}
// 0 indexed
// if x is in arr, getL returns the compressed id of x and getR returns id + 1
// getR is unnecessary most times
// getVal returns the original value that corresponds to id

template<class T>
class CoordinateCompression {
public:
	CoordinateCompression(const vector<T> &a) {
		arr = a;
		sort(arr.begin(), arr.end());
		arr.resize(unique(arr.begin(), arr.end()) - arr.begin());
	}

	int getL(T x) { return lower_bound(arr.begin(), arr.end(), x) - arr.begin(); }
	int getR(T x) { return upper_bound(arr.begin(), arr.end(), x) - arr.begin(); }
    T getVal(int id) { return arr[id]; }
	int size() const { return (int) arr.size(); }
private:
	vector<T> arr;
};
\end{lstlisting}

\subsection{Fast RMQ using Sparse Table}
\begin{lstlisting}
// O(N) preprocessing, O(1) query Range Minimum Query
// qry(l, r) returns min from l to r - 1 (0 indexed)

template<class T>
class FastRMQ {
public:
	void init(const vector<T> &a) {
		original = a;
		int n = (int) a.size();
		if(n == 0) return;
		e = 1;
		while((1 << e) < n) e++;
		vector<T> groups;
		for(int i = 0; i < n; i++) {
			if(i % e == 0) {
				groups.push_back(a[i]);
			} else if(a[i] < groups.back()) {
				groups.back() = a[i];
			}
		}
		table.init(groups);
		mask.resize(n);
		for(int i = 0, curMask = 0; i < n; i++) {
			curMask = (curMask << 1) & ((1 << e) - 1);
			while(curMask) {
				int j = i - table.getPos(curMask & -curMask);
				if(a[i] < a[j]) {
					curMask ^= curMask & -curMask;
				} else {
					break;
				}
			}
			curMask |= 1;
			mask[i] = curMask;
		}
	}

	T qry(int l, int r) {
		// query in [l, r)
		if(r - l <= e) {
			return i_qry(r-1, r-l);
		} else {
			T ans = min(i_qry(l+e-1, e), i_qry(r-1, e));
			if(l / e + 1 < r / e) {
				ans = min(ans, table.qry(l / e + 1, r / e));
			}
			return ans;
		}
	}
private:
	int e;
	SparseTable<T> table;
	vector<T> original;
	vector<int> mask;

	T i_qry(int r, int size) {
		int curMask = mask[r] & ((1 << size) - 1);
		int pos = r - table.getPos(curMask);
		return original[pos];
	}
};
\end{lstlisting}

\subsection{Fenwick Tree (BIT)}
\begin{lstlisting}

template <class T>
class FenwickTree {
public:
	void init(int _n) {
		this->n = _n;
		bit.assign(n + 1, 0);
	}

	void init(const vector<T> &a) {
		n = a.size();
		bit.assign(n + 1, 0);
		for(int i = 1; i <= n; i++) {
			bit[i] += a[i - 1];
			if(i + (i & -i) <= n) {
				bit[i + (i & -i)] += bit[i];
			}
		}
	}

	T qry(int x) {
		x = min(x, (int)bit.size() - 1);
		T ans = 0;
		for(; x > 0; x -= x & -x) {
			ans += bit[x];
		}
		return ans;
	}

	void upd(int x, T v) {
		if(x <= 0) return;
		for(; x <= n; x += x & -x) {
			bit[x] += v;
		}
	}
private:
	int n;
	vector<T> bit;
};
\end{lstlisting}

\subsection{Max Queue}
\begin{lstlisting}

template <class T, class C = less<T>>
struct MaxQueue {
	MaxQueue() {
		clear();
	}

	void clear() {
		id = 0;
		q.clear();
	}

	void push(T x) {
		pair<int, T> nxt(1, x);
		while(q.size() > id && cmp(q.back().second, x)) {
			nxt.first += q.back().first;
			q.pop_back();
		}
		q.push_back(nxt);
	}

	T qry() {
		return q[id].second;
	}

	void pop() {
		q[id].first--;
		if(q[id].first == 0) {
			id++;
		}
	}
private:
	vector<pair<int, T>> q;
	int id;
	C cmp;
};
\end{lstlisting}

\subsection{SegTree 2D Iterativa}
\begin{lstlisting}
// Consultas 0-based
// Um valor inicial em (x, y) deve ser colocado em seg[x+n][y+n]
// Query: soma do retangulo ((x1, y1), (x2, y2))
// Update: muda o valor da posicao (x, y) para val
// Nao pergunte como que essa coisa funciona
//
// Para query com distancia de manhattan <= d, faca
// nx = x+y, ny = x-y
// Update em (nx, ny), query em ((nx-d, ny-d), (nx+d, ny+d))
//
// Se for de min/max, pode tirar os if's da 'query', e fazer
// sempre as 4 operacoes. Fica mais rapido
//
// Complexidades:
// build - O(n^2)
// query - O(log^2(n))
// update - O(log^2(n))
// 67b9e5

int seg[2*MAX][2*MAX], n;

void build() {
	for (int x = 2*n; x; x--) for (int y = 2*n; y; y--) {
		if (x < n) seg[x][y] = seg[2*x][y] + seg[2*x+1][y];
		if (y < n) seg[x][y] = seg[x][2*y] + seg[x][2*y+1];
	}
}

int query(int x1, int y1, int x2, int y2) {
	int ret = 0, y3 = y1 + n, y4 = y2 + n;
	for (x1 += n, x2 += n; x1 <= x2; ++x1 /= 2, --x2 /= 2)
		for (y1 = y3, y2 = y4; y1 <= y2; ++y1 /= 2, --y2 /= 2) {
			if (x1%2 == 1 and y1%2 == 1) ret += seg[x1][y1];
			if (x1%2 == 1 and y2%2 == 0) ret += seg[x1][y2];
			if (x2%2 == 0 and y1%2 == 1) ret += seg[x2][y1];
			if (x2%2 == 0 and y2%2 == 0) ret += seg[x2][y2];
		}
	
	return ret;
}

void update(int x, int y, int val) {
	int y2 = y += n;
	for (x += n; x; x /= 2, y = y2) {
		if (x >= n) seg[x][y] = val;
		else seg[x][y] = seg[2*x][y] + seg[2*x+1][y];
		
		while (y /= 2) seg[x][y] = seg[x][2*y] + seg[x][2*y+1];
	}
}
\end{lstlisting}

\subsection{Sparse Table}
\begin{lstlisting}
// don't know how to use without FastRMQ.cpp

template<class T>
struct Minimizer {
	T operator() (T a, T b) { return min(a, b); }
};

template <class T, class Merger = Minimizer<T>>
class SparseTable {
public:
	void init(const vector<T> &a) {
		int e = 0;
		int n = a.size();
		while((1 << e) / 2 < n) {
			e++;
		}
		table.assign(e, vector<T>(n));
		get.assign(n + 1, -1);
		for(int i = 0; i < n; i++) {
			table[0][i] = a[i];
			get[i+1] = get[(i+1)/2] + 1;
		}
		for(int i = 0; i + 1 < e; i++) {
			for(int j = 0; j + (1 << i) < n; j++) {
				table[i+1][j] = merge(table[i][j], table[i][j + (1 << i)]);
			}
		}
	}
	
	T qry(int l, int r) {
		int e = get[r - l];
		return merge(table[e][l], table[e][r - (1 << e)]);
	}

	int getPos(int x) {
		while(x >= (int) get.size()) get.push_back(get[(int) get.size() / 2] + 1);
		return get[x];
	}
private:
	vector<vector<T>> table;
	vector<int> get;
	Merger merge;
};
\end{lstlisting}

\subsection{Trie}
\begin{lstlisting}
// trie T() constroi uma trie para o alfabeto das letras minusculas
// trie T(tamanho do alfabeto, menor caracter) tambem pode ser usado
// 
// T.insert(s) - O(|s|*sigma)
// T.erase(s) - O(|s|)
// T.find(s) retorna a posicao, 0 se nao achar - O(|s|)
// T.count_pref(s) numero de strings que possuem s como prefixo - O(|s|)
//
// Nao funciona para string vazia
// 979609

struct trie {
	vector<vector<int>> to;
	vector<int> end, pref;
	int sigma; char norm;
	trie(int sigma_=26, char norm_='a') : sigma(sigma_), norm(norm_) {
		to = {vector<int>(sigma)};
		end = {0}, pref = {0};
	}
	void insert(string s) {
		int x = 0;
		for(auto c : s) {
			int &nxt = to[x][c-norm];
			if(!nxt) {
				nxt = to.size();
				to.push_back(vector<int>(sigma));
				end.push_back(0), pref.push_back(0);
			}
			x = nxt, pref[x]++;
		}
		end[x]++;
	}
	void erase(string s) {
		int x = 0;
		for(char c : s) {
			int &nxt = to[x][c-norm];
			x = nxt, pref[x]--;
			if(!pref[x]) nxt = 0;
		}
		end[x]--;
	}
	int find(string s) {
		int x = 0;
		for(auto c : s) {
			x = to[x][c-norm];
			if(!x) return 0;
		}
		return x;
	}
	int count_pref(string s) {
		return pref[find(s)];
	}
};
\end{lstlisting}

\subsection{Trie Binaria}
\begin{lstlisting}

const int tam = 6e6 + 5, MAXL = 30; // deve ser qtd de numeros * qtd maxima de bits
// cuidado que MAXL deve ser exatamente o maior bit que pode estar aceso
// mudar pra ll se precisar

int at = 0, trie[tam][2], qtd[tam];

void insert(int x, int add) {
    int node = 0;
    for (int i = MAXL; i >= 0; i--) {
        int &a = trie[node][!!(x & (1 << i))];
        if (!a) {
            a = ++at;
        }
        node = a;
        qtd[node] += add;
    }
}

int maxTrie(int x) {
    // devolve max(x ^ y) para todo y na trie
	int node = 0, resp = 0;
	for (int i = MAXL; i >= 0; i--) {
        int bit = !!(x & (1 << i));
		if (qtd[trie[node][!bit]]) {
			resp += (1<<i);
			node = trie[node][!bit];
		}
		else {
			node = trie[node][bit];
		}
	}
	return resp;
}

int minTrie(int x) {
    // devolve min(x ^ y) para todo y na trie
    int node = 0, resp = 0;
	for (int i = MAXL; i >= 0; i--) {
        int bit = !!(x & (1 << i));
		if (qtd[trie[node][bit]]) {
			node = trie[node][bit];
		}
		else {
			resp += (1<<i);
			node = trie[node][!bit];
		}
	}
	return resp;
}
\end{lstlisting}

\subsection{Union find (DSU)}
\begin{lstlisting}

class DSU {
public:
		void init(int _n, bool _compress = true) {
			n = _n;
			qt = _n;
			compress = _compress;
			size.assign(n + 1, 1);
			for(int i = 0; i <= n; i++) {
				pai.push_back(i);
			}
		}

		int find(int v) {
			if(pai[v] == v) return v;
			if(compress) {
				return pai[v] = find(pai[v]);
			}
			return find(pai[v]);
		}

		void join(int a, int b) {
			a = find(a); b = find(b);
			if(a == b) return;
			if(size[a] > size[b]) swap(a, b);
			size[b] += size[a];
			pai[a] = b;
			roll.push_back(a);
			qt--;
		}

		void rollback() {
			if(roll.empty()) return;
			int cur = roll[roll.size() - 1];
			roll.pop_back();
			size[pai[cur]] -= size[cur];
			pai[cur] = cur;
			qt++;
			return;
		}

		int getQt() {
			return qt;
		}


private:
		int n, qt;
		bool compress;
		vector <int> size, pai, roll;
};
\end{lstlisting}

\subsection{Union find (DSU) bipartido}
\begin{lstlisting}

class DSU {
public:
		void init(int _n) {
			n = _n;
			qt = _n;
            bipartite = 1;
			size.assign(n + 1, 1);
            len.assign(n + 1, 0);
			for(int i = 0; i <= n; i++) {
				pai.push_back(i);
			}
		}

		pii find(int v) {
			if(pai[v] == v) return {v, len[v]};
			pii resp = find(pai[v]);
            return {resp.first, resp.second ^ len[v]};
		}

		void join(int a, int b) {
			pii x = find(a), y = find(b);
			if(x == y) {
                if(x.second == y.second) {
                    rollb.push_back(bipartite);
                    bipartite = false;
                }
                else {
                    rollb.push_back(bipartite);
                }
                roll.push_back({-1, -1});
                return;
            }
			if(size[x.first] > size[y.first]) swap(x, y);
            roll.push_back({x.first, len[x.first]});
			size[y.first] += size[x.first]; 
			pai[x.first] = y.first;
            len[x.first] = (x.second ^ y.second ^ 1);
            rollb.push_back(bipartite);
			qt--;
		}

		void rollback() {
			if(roll.empty()) return;
			pii cur = roll[roll.size() - 1];
			roll.pop_back();
            bipartite = rollb[rollb.size() - 1];
            rollb.pop_back();
            if(cur.first == -1) return;
			size[pai[cur.first]] -= size[cur.first];
			pai[cur.first] = cur.first;
            len[cur.first] = cur.second;
			qt++;
			return;
		}

		int getQt() {
			return qt;
		}

        int getBp() {
            return bipartite;
        }

private:
		int n, qt;
        bool bipartite;
		vector <int> size, pai, len;
        vector <pii> roll;
        vector <bool> rollb;
};
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% String
%
%%%%%%%%%%%%%%%%%%%%

\section{String}

\subsection{Aho-Corasick (Ber)}
\begin{lstlisting}
// tamanho do alfabeto e soma dos tamanhos das strings
const int ALPHA = 26, SIZE = 305;
int I = 1;
 
// nodes do aho
// fail eh o fail link
// ch eh o automato
// podemos colocar mais coisas, tp um inteiro que diz quantas palavras terminam ali
// lembrando que temos que fazer uma dfs pra computar esse inteiro, por exemplo
struct node {
    int fail, ch[ALPHA] = {};
    // int qtd;
} T[SIZE];
 
// adj eh o grafo dos fail links invertidos, para podermos fazer a dfs e computar algm coisa 
vector<int> adj[SIZE];
 
void insert(string s, int i) {
    int x = 1;
    for (int j = 0; j < (int)s.size(); j++) {
        // mudar pra '0' se estivermos lidando com digitos
        if (T[x].ch[s[j] - 'a'] == 0)
            T[x].ch[s[j] - 'a'] = ++I;
        x = T[x].ch[s[j] - 'a'];
    }
    // T[x].qtd++; 
}
 
void build() {
    queue<int> Q;
    int x = 1; 
    T[1].fail = 1;
    for (int i = 0; i < ALPHA; i++) {
        if (T[x].ch[i])
            T[T[x].ch[i]].fail = x, Q.push(T[x].ch[i]);
        else 
            T[x].ch[i] = 1;
    }
    while (!Q.empty()) {
        x = Q.front(); Q.pop();
        for (int i = 0; i < ALPHA; i++) {
            if (T[x].ch[i])
                T[T[x].ch[i]].fail = T[T[x].fail].ch[i], Q.push(T[x].ch[i]);
            else 
                T[x].ch[i] = T[T[x].fail].ch[i];
        }
    }
    for (int i = 2; i <= I; i++)
        adj[i].push_back(T[i].fail);
}
 
int vis[SIZE];
 
int dfs(int u) {
    if (vis[u]) return T[u].qtd;
    vis[u] = 1;
    for (int v : adj[u])
        T[u].qtd += dfs(v);
    return T[u].qtd;
}

// rodar uma string pelo automato e computar alguma coisa
void run(string s) {
    for (int i = 0, x = 1; i < s.size(); i++) {
        x = T[x].ch[s[i] - 'a'];
        // T[x].cnt++;
    }
}
\end{lstlisting}

\subsection{KMP}
\begin{lstlisting}

vector<int> prefix_function(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i-1];
        while (j > 0 && s[i] != s[j])
            j = pi[j-1];
        if (s[i] == s[j])
            j++;
        pi[i] = j;
    }
    return pi;
}
\end{lstlisting}

\subsection{Suffix Array}
\begin{lstlisting}
// Para MAXN = 1e6, MAXB deve ser maior que 20

const int MAXB = 20;
 
struct suffix_array{
    const int alpha = 300;
 
    int c[MAXB][MAXN] , p[MAXN] , cn[MAXN] , pn[MAXN] , cnt[MAXN];
    string s;
 
    void suffix_ini(){
        memset(cnt,0,sizeof cnt);
        memset(c,-1,sizeof c);
 
        int n = s.size();
 
        for(int i = 0;i < n;i++) cnt[s[i]] ++;
        for(int i = 1;i < alpha;i++) cnt[i] += cnt[i - 1];
        for(int i = n - 1;i >= 0;i--) p[--cnt[s[i]]] = i;
 
        int cla = 0;
        c[0][p[0]] = 0;
 
        for(int i = 1;i < n;i++){
            if(s[p[i]] != s[p[i - 1]]) ++cla;
            c[0][p[i]] = cla;
        }
    }
 
    void suffix(){
        int n = s.size();
 
        for(int h = 0;(1 << h) < n;h++){
            for(int i = 0;i < n;i++){
                pn[i] = p[i] - (1 << h);
                if(pn[i] < 0) pn[i] += n;
            }
 
            memset(cnt,0,sizeof cnt);
 
            for(int i = 0;i < n;i++) cnt[c[h][pn[i]]] ++;
            for(int i = 0;i < n;i++) cnt[i] += cnt[i - 1];
            for(int i = n - 1;i >= 0;i--) p[--cnt[c[h][pn[i]]]] = pn[i];
 
            int cla = 0;
            cn[p[0]] = 0;
 
            for(int i = 1;i < n;i++){
                pair<int,int> cur = {c[h][p[i]],c[h][(p[i] + (1 << h)) % n]};
                pair<int,int> pre = {c[h][p[i - 1]],c[h][(p[i - 1] + (1 << h)) % n]};
 
                if(cur.first != pre.first || cur.second != pre.second) cla ++;
                cn[p[i]] = cla;
            }
 
            for(int i = 0;i < n;i++) c[h + 1][i] = cn[i];
        }
    }
    
    // Pre-calcula o vetor P e C (essa funcao deve ser a primeira a ser chamada)
    void sdo(string S){
        s = S;
        s += "&";
        suffix_ini();
        suffix();
    }
    
    // retorna o tamanho do maior prefixo comum
    // entre os sufixos que comecam em x e y
    int comp(int x,int y){
        int res = 0;
        int n = s.size();
 
        for(int i = MAXB - 1;i >= 0;i--){
            if(c[i][x] == -1 || c[i][y] == -1 || c[i][x] != c[i][y])
                continue;
 
            x += (1 << i);
            y += (1 << i);
            res += (1 << i);
 
            if(x >= n)
                x -= n;
            if(y >= n)
                y -= n;            
        }
 
        return res;
    }
 
    void printP(){
        cout << s << endl;
        for(int i = 0;i < s.size();i++){
            cout << p[i] << " "; 
        }
        cout << endl;
    }
};
\end{lstlisting}

\subsection{Z-function}
\begin{lstlisting}

vector<int> z_function(string s) {
    int n = (int) s.length();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r)
            z[i] = min (r - i + 1, z[i - l]);
        while (i + z[i] < n && s[z[i]] == s[i + z[i]])
            ++z[i];
        if (i + z[i] - 1 > r)
            l = i, r = i + z[i] - 1;
    }
    return z;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% DP
%
%%%%%%%%%%%%%%%%%%%%

\section{DP}

\subsection{SOS DP}
\begin{lstlisting}
// SOS DP inversa em h
for (int mask = 0; mask < (1 << n); mask++) {
    if(__builtin_popcount(mask) % 2) {
        h[mask] *= -1;
        add(h[mask], 0);
    }
}
for (int i = 0; i < n; i++) {
    for (int mask = (1 << n) - 1; mask >= 0; mask--) {
        if ((mask & (1 << i)) != 0) {
            add(h[mask], h[mask ^ (1 << i)]);
        }
    }
}
for (int mask = 0; mask < (1 << n); mask++) {
    if (__builtin_popcount(mask) % 2) {
        h[mask] *= -1;
        add(h[mask], 0);
    }
}
// dp1[x] = qtd de submasks de x
// dp2[x] = qtd de supermasks de x
// dp1[ inverso de x ] = qtd de disjuntos de x 
// aqui os valores vao ate 1e6
for (int i = 0; i <= 19; i++) {
    for (int j = (1<<20)-1; j >= 0; j--) {
        if (j & (1<<i)) {
            dp1[j] += dp1[j ^ (1<<i)];
        }
    }
    for (int j = 0; j <= 1e6; j++) {
        if (!(j & (1<<i)) && (j ^ (1<<i)) <= 1e6) {
            dp2[j] += dp2[j ^ (1<<i)];
        }
    }
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% Geometry
%
%%%%%%%%%%%%%%%%%%%%

\section{Geometry}

\subsection{Primitivas Geometricas}
\begin{lstlisting}

typedef double ld;
const ld DINF = 1e18;
const ld pi = acos(-1.0);
const ld eps = 1e-9;

#define sq(x) ((x)*(x))

bool eq(ld a, ld b) {
	return abs(a - b) <= eps;
}

// a8b7d6
struct pt { // ponto
	ld x, y;
	pt(ld x_ = 0, ld y_ = 0) : x(x_), y(y_) {}
	bool operator < (const pt p) const {
		if (!eq(x, p.x)) return x < p.x;
		if (!eq(y, p.y)) return y < p.y;
		return 0;
	}
	bool operator == (const pt p) const {
		return eq(x, p.x) and eq(y, p.y);
	}
	pt operator + (const pt p) const { return pt(x+p.x, y+p.y); }
	pt operator - (const pt p) const { return pt(x-p.x, y-p.y); }
	pt operator * (const ld c) const { return pt(x*c  , y*c  ); }
	pt operator / (const ld c) const { return pt(x/c  , y/c  ); }
	ld operator * (const pt p) const { return x*p.x + y*p.y; }
	ld operator ^ (const pt p) const { return x*p.y - y*p.x; }
	friend istream& operator >> (istream& in, pt& p) {
		return in >> p.x >> p.y;
	}
};

// 7ab617
struct line { // reta
	pt p, q;
	line() {}
	line(pt p_, pt q_) : p(p_), q(q_) {}
	friend istream& operator >> (istream& in, line& r) {
		return in >> r.p >> r.q;
	}
};

// PONTO & VETOR

// c684fb
ld dist(pt p, pt q) { // distancia
	return hypot(p.y - q.y, p.x - q.x);
}

// 80f2b6
ld dist2(pt p, pt q) { // quadrado da distancia
	return sq(p.x - q.x) + sq(p.y - q.y);
}

// cf7f33
ld norm(pt v) { // norma do vetor
	return dist(pt(0, 0), v);
}

// 404df7
ld angle(pt v) { // angulo do vetor com o eixo x
	ld ang = atan2(v.y, v.x);
	if (ang < 0) ang += 2*pi;
	return ang;
}

// 1b1d4a
ld sarea(pt p, pt q, pt r) { // area com sinal
	return ((q-p)^(r-q))/2;
}

// 98c42f
bool col(pt p, pt q, pt r) { // se p, q e r sao colin.
	return eq(sarea(p, q, r), 0);
}

// 85d09d
bool ccw(pt p, pt q, pt r) { // se p, q, r sao ccw
	return sarea(p, q, r) > eps;
}

// 41a7b4
pt rotate(pt p, ld th) { // rotaciona o ponto th radianos
	return pt(p.x * cos(th) - p.y * sin(th),
			p.x * sin(th) + p.y * cos(th));
}

// e4ad5e
pt rotate90(pt p) { // rotaciona 90 graus
	return pt(-p.y, p.x);
}

// RETA

// 0fb984
bool isvert(line r) { // se r eh vertical
	return eq(r.p.x, r.q.x);
}

// 726d68
bool isinseg(pt p, line r) { // se p pertence ao seg de r
	pt a = r.p - p, b = r.q - p;
	return eq((a ^ b), 0) and (a * b) < eps;
}

// a0a30b
ld get_t(pt v, line r) { // retorna t tal que t*v pertence a reta r
	return (r.p^r.q) / ((r.p-r.q)^v);
}

// 2329fe
pt proj(pt p, line r) { // projecao do ponto p na reta r
	if (r.p == r.q) return r.p;
	r.q = r.q - r.p; p = p - r.p;
	pt proj = r.q * ((p*r.q) / (r.q*r.q));
	return proj + r.p;
}

// 111fd2
pt inter(line r, line s) { // r inter s
	if (eq((r.p - r.q) ^ (s.p - s.q), 0)) return pt(DINF, DINF);
	r.q = r.q - r.p, s.p = s.p - r.p, s.q = s.q - r.p;
	return r.q * get_t(r.q, s) + r.p;
}

// 35998c
bool interseg(line r, line s) { // se o seg de r intersecta o seg de s
	if (isinseg(r.p, s) or isinseg(r.q, s)
		or isinseg(s.p, r) or isinseg(s.q, r)) return 1;

	return ccw(r.p, r.q, s.p) != ccw(r.p, r.q, s.q) and
			ccw(s.p, s.q, r.p) != ccw(s.p, s.q, r.q);
}

// 1b72e1
ld disttoline(pt p, line r) { // distancia do ponto a reta
	return 2 * abs(sarea(p, r.p, r.q)) / dist(r.p, r.q);
}

// 3679c0
ld disttoseg(pt p, line r) { // distancia do ponto ao seg
	if ((r.q - r.p)*(p - r.p) < 0) return dist(r.p, p);
	if ((r.p - r.q)*(p - r.q) < 0) return dist(r.q, p);
	return disttoline(p, r);
}

// 222358
ld distseg(line a, line b) { // distancia entre seg
	if (interseg(a, b)) return 0;

	ld ret = DINF;
	ret = min(ret, disttoseg(a.p, b));
	ret = min(ret, disttoseg(a.q, b));
	ret = min(ret, disttoseg(b.p, a));
	ret = min(ret, disttoseg(b.q, a));

	return ret;
}

// POLIGONO

// corta poligono com a reta r deixando os pontos p tal que 
// ccw(r.p, r.q, p)
// 2538f9
vector<pt> cut_polygon(vector<pt> v, line r) { // O(n)
	vector<pt> ret;
	for (int j = 0; j < v.size(); j++) {
		if (ccw(r.p, r.q, v[j])) ret.push_back(v[j]);
		if (v.size() == 1) continue;
		line s(v[j], v[(j+1)%v.size()]);
		pt p = inter(r, s);
		if (isinseg(p, s)) ret.push_back(p);
	}
	ret.erase(unique(ret.begin(), ret.end()), ret.end());
	if (ret.size() > 1 and ret.back() == ret[0]) ret.pop_back();
	return ret;
}

// distancia entre os retangulos a e b (lados paralelos aos eixos)
// assume que ta representado (inferior esquerdo, superior direito)
// 630253
ld dist_rect(pair<pt, pt> a, pair<pt, pt> b) {
	ld hor = 0, vert = 0;
	if (a.second.x < b.first.x) hor = b.first.x - a.second.x;
	else if (b.second.x < a.first.x) hor = a.first.x - b.second.x;
	if (a.second.y < b.first.y) vert = b.first.y - a.second.y;
	else if (b.second.y < a.first.y) vert = a.first.y - b.second.y;
	return dist(pt(0, 0), pt(hor, vert));
}

// 5df9cf
ld polarea(vector<pt> v) { // area do poligono
	ld ret = 0;
	for (int i = 0; i < v.size(); i++)
		ret += sarea(pt(0, 0), v[i], v[(i + 1) % v.size()]);
	return abs(ret);
}

// se o ponto ta dentro do poligono: retorna 0 se ta fora,
// 1 se ta no interior e 2 se ta na borda
// a6423f
int inpol(vector<pt>& v, pt p) { // O(n)
	int qt = 0;
	for (int i = 0; i < v.size(); i++) {
		if (p == v[i]) return 2;
		int j = (i+1)%v.size();
		if (eq(p.y, v[i].y) and eq(p.y, v[j].y)) {
			if ((v[i]-p)*(v[j]-p) < eps) return 2;
			continue;
		}
		bool baixo = v[i].y+eps < p.y;
		if (baixo == (v[j].y+eps < p.y)) continue;
		auto t = (p-v[i])^(v[j]-v[i]);
		if (eq(t, 0)) return 2;
		if (baixo == (t > eps)) qt += baixo ? 1 : -1;
	}
	return qt != 0;
}

// c58350
bool interpol(vector<pt> v1, vector<pt> v2) { // se dois poligonos se intersectam - O(n*m)
	int n = v1.size(), m = v2.size();
	for (int i = 0; i < n; i++) if (inpol(v2, v1[i])) return 1;
	for (int i = 0; i < n; i++) if (inpol(v1, v2[i])) return 1;
	for (int i = 0; i < n; i++) for (int j = 0; j < m; j++)
		if (interseg(line(v1[i], v1[(i+1)%n]), line(v2[j], v2[(j+1)%m]))) return 1;
	return 0;
}

// 12559f
ld distpol(vector<pt> v1, vector<pt> v2) { // distancia entre poligonos
	if (interpol(v1, v2)) return 0;

	ld ret = DINF;

	for (int i = 0; i < v1.size(); i++) for (int j = 0; j < v2.size(); j++)
		ret = min(ret, distseg(line(v1[i], v1[(i + 1) % v1.size()]),
					line(v2[j], v2[(j + 1) % v2.size()])));
	return ret;
}

// 32623c
vector<pt> convex_hull(vector<pt> v) { // convex hull - O(n log(n))
	if (v.size() <= 1) return v;
	vector<pt> l, u;
	sort(v.begin(), v.end());
	for (int i = 0; i < v.size(); i++) {
		while (l.size() > 1 and !ccw(l[l.size()-2], l.back(), v[i]))
			l.pop_back();
		l.push_back(v[i]);
	}
	for (int i = v.size() - 1; i >= 0; i--) {
		while (u.size() > 1 and !ccw(u[u.size()-2], u.back(), v[i]))
			u.pop_back();
		u.push_back(v[i]);
	}
	l.pop_back(); u.pop_back();
	for (pt i : u) l.push_back(i);
	return l;
}

struct convex_pol {
	vector<pt> pol;

	// nao pode ter ponto colinear no convex hull
	convex_pol() {}
	convex_pol(vector<pt> v) : pol(convex_hull(v)) {}

	// se o ponto ta dentro do hull - O(log(n))
	// 800813
	bool is_inside(pt p) {
		if (pol.size() == 1) return p == pol[0];
		int l = 1, r = pol.size();
		while (l < r) {
			int m = (l+r)/2;
			if (ccw(p, pol[0], pol[m])) l = m+1;
			else r = m;
		}
		if (l == 1) return isinseg(p, line(pol[0], pol[1]));
		if (l == pol.size()) return false;
		return !ccw(p, pol[l], pol[l-1]);
	}
	// ponto extremo em relacao a cmp(p, q) = p mais extremo q
	// (copiado de https://github.com/gustavoM32/caderno-zika)
	// 56ccd2
	int extreme(const function<bool(pt, pt)>& cmp) {
		int n = pol.size();
		auto extr = [&](int i, bool& cur_dir) {
			cur_dir = cmp(pol[(i+1)%n], pol[i]);
			return !cur_dir and !cmp(pol[(i+n-1)%n], pol[i]);
		};
		bool last_dir, cur_dir;
		if (extr(0, last_dir)) return 0;
		int l = 0, r = n;
		while (l+1 < r) {
			int m = (l+r)/2;
			if (extr(m, cur_dir)) return m;
			bool rel_dir = cmp(pol[m], pol[l]);
			if ((!last_dir and cur_dir) or
					(last_dir == cur_dir and rel_dir == cur_dir)) {
				l = m;
				last_dir = cur_dir;
			} else r = m;
		}
		return l;
	}
	int max_dot(pt v) {
		return extreme([&](pt p, pt q) { return p*v > q*v; });
	}
	pair<int, int> tangents(pt p) {
		auto L = [&](pt q, pt r) { return ccw(p, q, r); };
		auto R = [&](pt q, pt r) { return ccw(p, r, q); };
		return {extreme(L), extreme(R)};
	}
};

// CIRCUNFERENCIA

// a125e4
pt getcenter(pt a, pt b, pt c) { // centro da circunf dado 3 pontos
	b = (a + b) / 2;
	c = (a + c) / 2;
	return inter(line(b, b + rotate90(a - b)),
			line(c, c + rotate90(a - c)));
}

// cd80c0
vector<pt> circ_line_inter(pt a, pt b, pt c, ld r) { // intersecao da circunf (c, r) e reta ab
	vector<pt> ret;
	b = b-a, a = a-c;
	ld A = b*b;
	ld B = a*b;
	ld C = a*a - r*r;
	ld D = B*B - A*C;
	if (D < -eps) return ret;
	ret.push_back(c+a+b*(-B+sqrt(D+eps))/A);
	if (D > eps) ret.push_back(c+a+b*(-B-sqrt(D))/A);
	return ret;
}

// fb11d8
vector<pt> circ_inter(pt a, pt b, ld r, ld R) { // intersecao da circunf (a, r) e (b, R)
	vector<pt> ret;
	ld d = dist(a, b);
	if (d > r+R or d+min(r, R) < max(r, R)) return ret;
	ld x = (d*d-R*R+r*r)/(2*d);
	ld y = sqrt(r*r-x*x);
	pt v = (b-a)/d;
	ret.push_back(a+v*x + rotate90(v)*y);
	if (y > 0) ret.push_back(a+v*x - rotate90(v)*y);
	return ret;
}

// 3a44fb
bool operator <(const line& a, const line& b) { // comparador pra reta
	// assume que as retas tem p < q
	pt v1 = a.q - a.p, v2 = b.q - b.p;
	if (!eq(angle(v1), angle(v2))) return angle(v1) < angle(v2);
	return ccw(a.p, a.q, b.p); // mesmo angulo
}
bool operator ==(const line& a, const line& b) {
	return !(a < b) and !(b < a);
}

// comparador pro set pra fazer sweep line com segmentos
// 36729f
struct cmp_sweepline {
	bool operator () (const line& a, const line& b) const {
		// assume que os segmentos tem p < q
		if (a.p == b.p) return ccw(a.p, a.q, b.q);
		if (!eq(a.p.x, a.q.x) and (eq(b.p.x, b.q.x) or a.p.x+eps < b.p.x))
			return ccw(a.p, a.q, b.p);
		return ccw(a.p, b.q, b.p);
	}
};

// comparador pro set pra fazer sweep angle com segmentos
// f778aa
pt dir;
struct cmp_sweepangle {
	bool operator () (const line& a, const line& b) const {
		return get_t(dir, a) + eps < get_t(dir, b);
	}
};
\end{lstlisting}

\subsection{Primitivas Geometricas 3D}
\begin{lstlisting}

typedef double ld;
const ld DINF = 1e18;
const ld pi = acos(-1.0);
const ld eps = 1e-9;

#define sq(x) ((x)*(x))

bool eq(ld a, ld b) {
	return abs(a - b) <= eps;
}

struct pt { // ponto
	ld x, y, z;
	pt(ld x_ = 0, ld y_ = 0, ld z_ = 0) : x(x_), y(y_), z(z_) {}
	bool operator < (const pt p) const {
		if (!eq(x, p.x)) return x < p.x;
		if (!eq(y, p.y)) return y < p.y;
		if (!eq(z, p.z)) return z < p.z;
		return 0;
	}
	bool operator == (const pt p) const {
		return eq(x, p.x) and eq(y, p.y) and eq(z, p.z);
	}
	pt operator + (const pt p) const { return pt(x+p.x, y+p.y, z+p.z); }
	pt operator - (const pt p) const { return pt(x-p.x, y-p.y, z-p.z); }
	pt operator * (const ld c) const { return pt(x*c  , y*c  , z*c  ); }
	pt operator / (const ld c) const { return pt(x/c  , y/c  , z/c  ); }
	ld operator * (const pt p) const { return x*p.x + y*p.y + z*p.z; }
	pt operator ^ (const pt p) const { return pt(y*p.z - z*p.y, z*p.x - x*p.z, x*p.y - y*p.x); }
};

// converte de coordenadas polares para cartesianas
// (angulos devem estar em radianos)
// phi eh o angulo com o eixo z (cima) theta eh o angulo de rotacao ao redor de z
pt convert(ld rho, ld th, ld phi) {
	return pt(sin(phi) * cos(th), sin(phi) * sin(th), cos(phi)) * rho;
}

// distancia
ld dist(pt a, pt b) {
	return sqrt(sq(a.x-b.x) + sq(a.y-b.y) + sq(a.z-b.z));
}

// rotaciona p ao redor do eixo u por um angulo a
pt rotate(pt p, pt u, ld a) {
	u = u / dist(u, pt());
	return u * (u * p) + (u ^ p ^ u) * cos(a) + (u ^ p) * sin(a);
}
\end{lstlisting}

\subsection{Primitivas Geometricas Inteiras}
\begin{lstlisting}

#define sq(x) ((x)*(ll)(x))

// 840720
struct pt { // ponto
	int x, y;
	pt(int x_ = 0, int y_ = 0) : x(x_), y(y_) {}
	bool operator < (const pt p) const {
		if (x != p.x) return x < p.x;
		return y < p.y;
	}
	bool operator == (const pt p) const {
		return x == p.x and y == p.y;
	}
	pt operator + (const pt p) const { return pt(x+p.x, y+p.y); }
	pt operator - (const pt p) const { return pt(x-p.x, y-p.y); }
	pt operator * (const int c) const { return pt(x*c, y*c); }
	ll operator * (const pt p) const { return x*(ll)p.x + y*(ll)p.y; }
	ll operator ^ (const pt p) const { return x*(ll)p.y - y*(ll)p.x; }
	friend istream& operator >> (istream& in, pt& p) {
		return in >> p.x >> p.y;
	}
};

// 7ab617
struct line { // reta
	pt p, q;
	line() {}
	line(pt p_, pt q_) : p(p_), q(q_) {}
	friend istream& operator >> (istream& in, line& r) {
		return in >> r.p >> r.q;
	}
};

// PONTO & VETOR

// 51563e
ll dist2(pt p, pt q) { // quadrado da distancia
	return sq(p.x - q.x) + sq(p.y - q.y);
}

// bf431d
ll sarea2(pt p, pt q, pt r) { // 2 * area com sinal
	return (q-p)^(r-q);
}

// a082d3
bool col(pt p, pt q, pt r) { // se p, q e r sao colin.
	return sarea2(p, q, r) == 0;
}

// 42bb09
bool ccw(pt p, pt q, pt r) { // se p, q, r sao ccw
	return sarea2(p, q, r) > 0;
}

// fcf924
int quad(pt p) { // quadrante de um ponto
	return (p.x<0)^3*(p.y<0);
}

// 77187b
bool compare_angle(pt p, pt q) { // retorna se ang(p) < ang(q)
	if (quad(p) != quad(q)) return quad(p) < quad(q);
	return ccw(q, pt(0, 0), p);
}

// e4ad5e
pt rotate90(pt p) { // rotaciona 90 graus
	return pt(-p.y, p.x);
}

// RETA

// c9f07f
bool isinseg(pt p, line r) { // se p pertence ao seg de r
	pt a = r.p - p, b = r.q - p;
	return (a ^ b) == 0 and (a * b) <= 0;
}

// 35998c
bool interseg(line r, line s) { // se o seg de r intersecta o seg de s
	if (isinseg(r.p, s) or isinseg(r.q, s)
		or isinseg(s.p, r) or isinseg(s.q, r)) return 1;

	return ccw(r.p, r.q, s.p) != ccw(r.p, r.q, s.q) and
			ccw(s.p, s.q, r.p) != ccw(s.p, s.q, r.q);
}

// dd8702
int segpoints(line r) { // numero de pontos inteiros no segmento
	return 1 + __gcd(abs(r.p.x - r.q.x), abs(r.p.y - r.q.y));
}

// d273be
double get_t(pt v, line r) { // retorna t tal que t*v pertence a reta r
	return (r.p^r.q) / (double) ((r.p-r.q)^v);
}

// POLIGONO

// quadrado da distancia entre os retangulos a e b (lados paralelos aos eixos)
// assume que ta representado (inferior esquerdo, superior direito)
// e13018
ll dist2_rect(pair<pt, pt> a, pair<pt, pt> b) {
	int hor = 0, vert = 0;
	if (a.second.x < b.first.x) hor = b.first.x - a.second.x;
	else if (b.second.x < a.first.x) hor = a.first.x - b.second.x;
	if (a.second.y < b.first.y) vert = b.first.y - a.second.y;
	else if (b.second.y < a.first.y) vert = a.first.y - b.second.y;
	return sq(hor) + sq(vert);
}

// d5f693
ll polarea2(vector<pt> v) { // 2 * area do poligono
	ll ret = 0;
	for (int i = 0; i < v.size(); i++)
		ret += sarea2(pt(0, 0), v[i], v[(i + 1) % v.size()]);
	return abs(ret);
}

// se o ponto ta dentro do poligono: retorna 0 se ta fora,
// 1 se ta no interior e 2 se ta na borda
// afd587
int inpol(vector<pt>& v, pt p) { // O(n)
	int qt = 0;
	for (int i = 0; i < v.size(); i++) {
		if (p == v[i]) return 2;
		int j = (i+1)%v.size();
		if (p.y == v[i].y and p.y == v[j].y) {
			if ((v[i]-p)*(v[j]-p) <= 0) return 2;
			continue;
		}
		bool baixo = v[i].y < p.y;
		if (baixo == (v[j].y < p.y)) continue;
		auto t = (p-v[i])^(v[j]-v[i]);
		if (!t) return 2;
		if (baixo == (t > 0)) qt += baixo ? 1 : -1;
	}
	return qt != 0;
}

// 32623c
vector<pt> convex_hull(vector<pt> v) { // convex hull - O(n log(n))
	if (v.size() <= 1) return v;
	vector<pt> l, u;
	sort(v.begin(), v.end());
	for (int i = 0; i < v.size(); i++) {
		while (l.size() > 1 and !ccw(l[l.size()-2], l.back(), v[i]))
			l.pop_back();
		l.push_back(v[i]);
	}
	for (int i = v.size() - 1; i >= 0; i--) {
		while (u.size() > 1 and !ccw(u[u.size()-2], u.back(), v[i]))
			u.pop_back();
		u.push_back(v[i]);
	}
	l.pop_back(); u.pop_back();
	for (pt i : u) l.push_back(i);
	return l;
}

// af2d96
ll interior_points(vector<pt> v) { // pontos inteiros dentro de um poligono simples
	ll b = 0;
	for (int i = 0; i < v.size(); i++)
		b += segpoints(line(v[i], v[(i+1)%v.size()])) - 1;
	return (polarea2(v) - b) / 2 + 1;
}

struct convex_pol {
	vector<pt> pol;

	// nao pode ter ponto colinear no convex hull
	convex_pol() {}
	convex_pol(vector<pt> v) : pol(convex_hull(v)) {}

	// se o ponto ta dentro do hull - O(log(n))
	// 800813
	bool is_inside(pt p) {
		if (pol.size() == 1) return p == pol[0];
		int l = 1, r = pol.size();
		while (l < r) {
			int m = (l+r)/2;
			if (ccw(p, pol[0], pol[m])) l = m+1;
			else r = m;
		}
		if (l == 1) return isinseg(p, line(pol[0], pol[1]));
		if (l == pol.size()) return false;
		return !ccw(p, pol[l], pol[l-1]);
	}
	// ponto extremo em relacao a cmp(p, q) = p mais extremo q
	// (copiado de https://github.com/gustavoM32/caderno-zika)
	// 56ccd2
	int extreme(const function<bool(pt, pt)>& cmp) {
		int n = pol.size();
		auto extr = [&](int i, bool& cur_dir) {
			cur_dir = cmp(pol[(i+1)%n], pol[i]);
			return !cur_dir and !cmp(pol[(i+n-1)%n], pol[i]);
		};
		bool last_dir, cur_dir;
		if (extr(0, last_dir)) return 0;
		int l = 0, r = n;
		while (l+1 < r) {
			int m = (l+r)/2;
			if (extr(m, cur_dir)) return m;
			bool rel_dir = cmp(pol[m], pol[l]);
			if ((!last_dir and cur_dir) or
					(last_dir == cur_dir and rel_dir == cur_dir)) {
				l = m;
				last_dir = cur_dir;
			} else r = m;
		}
		return l;
	}
	int max_dot(pt v) {
		return extreme([&](pt p, pt q) { return p*v > q*v; });
	}
	pair<int, int> tangents(pt p) {
		auto L = [&](pt q, pt r) { return ccw(p, q, r); };
		auto R = [&](pt q, pt r) { return ccw(p, r, q); };
		return {extreme(L), extreme(R)};
	}
};

// dca598
bool operator <(const line& a, const line& b) { // comparador pra reta
	// assume que as retas tem p < q
	pt v1 = a.q - a.p, v2 = b.q - b.p;
	bool b1 = compare_angle(v1, v2), b2 = compare_angle(v2, v1);
	if (b1 or b2) return b1;
	return ccw(a.p, a.q, b.p); // mesmo angulo
}
bool operator ==(const line& a, const line& b) {
	return !(a < b) and !(b < a);
}

// comparador pro set pra fazer sweep line com segmentos
// 6774df
struct cmp_sweepline {
	bool operator () (const line& a, const line& b) const {
		// assume que os segmentos tem p < q
		if (a.p == b.p) return ccw(a.p, a.q, b.q);
		if (a.p.x != a.q.x and (b.p.x == b.q.x or a.p.x < b.p.x))
			return ccw(a.p, a.q, b.p);
		return ccw(a.p, b.q, b.p);
	}
};

// comparador pro set pra fazer sweep angle com segmentos
// 1ee7f5
pt dir;
struct cmp_sweepangle {
    bool operator () (const line& a, const line& b) const {
        return get_t(dir, a) < get_t(dir, b);
    }
};
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% CSES - Additional Problems
%
%%%%%%%%%%%%%%%%%%%%

\section{CSES - Additional Problems}

\subsection{Acyclic Graph Edges}
\begin{lstlisting}
// Problem name: Acyclic Graph Edges
// Problem Link: https://cses.fi/problemset/task/1756
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
vector<int> v[MAXN];
vector<pii> edg;
int lvl[MAXN];
 
void dfs(int node, int pai) {
	lvl[node] = lvl[pai]+1;
	for (int x : v[node]) 
		if (!lvl[x]) dfs(x, node);
}
 
int main () { _
	int n, m, a, b;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
		edg.pb({a, b});
	}
	for (int i = 1; i <= n; i++) if (!lvl[i]) dfs(i, 0);
	for (pii x : edg) {
		if (lvl[x.F] > lvl[x.S]) cout << x.S << ' ' << x.F << '\n';
		else cout << x.F << ' ' << x.S << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{Advertisement}
\begin{lstlisting}
// Problem name: Advertisement
// Problem Link: https://cses.fi/problemset/task/1142
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A fence consists of n vertical boards. The width of each board is 1 and their heights may vary.
// You want to attach a rectangular advertisement to the fence. What is the maximum area of such an advertisement?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int v[MAXN];
 
int main () { _
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> v[i];
	v[n+1] = 0;
	vector<pii> sk;
	sk.pb({v[1], 1});
	ll ans = 0;
	for (int i = 2; i <= n+1; i++) {
		while (!sk.empty() && sk.back().F >= v[i]) {
			ans = max(ans, 1ll * (i-1 - ((int)sk.size() == 1 ? 0 : sk[(int)sk.size()-2].S)) * sk.back().F);
			sk.pop_back();
		}
		sk.pb({v[i], i});
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Area of Rectangles}
\begin{lstlisting}
// Problem name: Area of Rectangles
// Problem Link: https://cses.fi/problemset/task/1741
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given n rectangles, your task is to determine the total area of their union.

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const int INF = 2e9;
 
struct op {
    int x, y1, y2;
    bool open;
    op(int _x = 0, int _y1 = 0, int _y2 = 0, bool _open = false) {
        x = _x, y1 = _y1, y2 = _y2, open = _open;
    }
};
 
bool comp(op a, op b) {
    if (a.x != b.x) return a.x < b.x;
    return a.open > b.open;
}
 
struct no {
    int mn, qtd, lz;
    no(int _mn = 0, int _qtd = 0, int _lz = 0) {
        mn = _mn, qtd = _qtd, lz = _lz;
    }
    no operator + (const no &x) const {
        no aux;
        if (mn < x.mn) {
            aux.mn = mn;
            aux.qtd = qtd;
        }
        else if (mn == x.mn) {
            aux.mn = mn;
            aux.qtd = qtd + x.qtd;
        }
        else {
            aux.mn = x.mn;
            aux.qtd = x.qtd;
        }
        aux.lz = lz;
        return aux;
    }
}a[4 * MAXN];
 
void build(int node, int i, int j) {
    if (i == j) {
        a[node] = no(0, 1, 0);
    }
    else {
        int m = (i + j) / 2;
        build(2 * node, i, m), build(2 * node + 1, m + 1, j);
        a[node] = a[2 * node] + a[2 * node + 1];
    }
}
 
void push(int node, int i, int j) {
    if (a[node].lz) {
        a[node].mn += a[node].lz;
        if (i != j) {
            a[2 * node].lz += a[node].lz;
            a[2 * node + 1].lz += a[node].lz;
        }
        a[node].lz = 0;
    }
}
 
void update(int node, int i, int j, int ini, int fim, int val) {
    push(node, i, j);
    if (j < ini || i > fim) return;
    else if (ini <= i && j <= fim) {
        a[node].lz += val;
        push(node, i, j);
    }
    else {
        int m = (i + j) / 2;
        update(2 * node, i, m, ini, fim, val);
        update(2 * node + 1, m + 1, j, ini, fim, val);
        a[node] = a[2 * node] + a[2 * node + 1];
    }
}
 
ll query(int node, int i, int j) {
    push(node, i, j);
    return a[1].qtd;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, a, b, c, d;
    cin >> n;
    build(1, 0, 2000000);
    vector<op> v(2 * n);
    for (int i = 0; i < n; i++) {
        cin >> a >> b >> c >> d;
        b += 1000000, d += 1000000 - 1;
        v[2 * i] = op(a, b, d, true), v[2 * i + 1] = op(c, b, d, false);
    }
    sort(v.begin(), v.end(), comp);
    int lst = -1000000;
    ll ans = (2000001ll) * (2000001ll);
    for (auto o : v) {
        if (o.x != lst) {
            // novo x
            ans -= query(1, 0, 2000000) * (o.x - lst);
            lst = o.x;
        }
        if (o.open) {
            // comeco de intervalo
            update(1, 0, 2000000, o.y1, o.y2, 1);
        }
        else {
            // fim de intervalo
            update(1, 0, 2000000, o.y1, o.y2, -1);
        }
    }
    cout << ans - query(1, 0, 2000000) * (1000000 - lst + 1) << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Binary Subsequences}
\begin{lstlisting}
// Problem name: Binary Subsequences
// Problem Link: https://cses.fi/problemset/task/2430
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to find a minimum length bit string that has exactly n distinct subsequences.
// For example, a correct solution for n=6 is 101 whose distinct subsequences are 0, 1, 01, 10, 11 and 101.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 5e5 + 5;
const ll INF = 1e18;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    int mn = n + 1, ans = -1;
    for (int i = 0; i <= n / 2; i++) {
        // try i and n - i
        int cnt = 0;
        int a = i, b = n - i;
        bool ok = true;
        while (a || b) {
            if (a < b) swap(a, b);
            if (a == b) {
                ok = false;
                break;
            }
            cnt += a / (b + 1);
            a %= (b + 1);
        }
        if (ok && cnt < mn) {
            mn = cnt;
            ans = i;
        } 
    }
    string s;
    int a = ans, b = n - a, z = 0;
    while (a || b) {
        if (a < b) {
            swap(a, b);
            z ^= 1;
        }
        int tot = a / (b + 1);
        for (int i = 0; i < tot; i++) s += '0' + z;
        a %= (b + 1);
    }
    cout << s << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Bit Inversions}
\begin{lstlisting}
// Problem name: Bit Inversions
// Problem Link: https://cses.fi/problemset/task/1188
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There is a bit string consisting of n bits. Then, there are some changes that invert one given bit. 
// Your task is to report, after each change, the length of the longest substring whose each bit is the same.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
struct t{
	int pre, suf, ans, tam;
};
 
string s;
t a[4*MAXN][2];
 
void merge(int node) {
	a[node][0].tam = a[2*node][0].tam + a[2*node+1][0].tam;
	if (a[2*node][0].pre == a[2*node][0].tam) 
		a[node][0].pre = a[2*node][0].pre + a[2*node+1][0].pre;
	else a[node][0].pre = a[2*node][0].pre;
 
	if (a[2*node][1].pre == a[2*node][0].tam) 
		a[node][1].pre = a[2*node][1].pre + a[2*node+1][1].pre;
	else a[node][1].pre = a[2*node][1].pre;
 
	if (a[2*node+1][0].suf == a[2*node+1][0].tam) 
		a[node][0].suf = a[2*node][0].suf + a[2*node+1][0].suf;
	else a[node][0].suf = a[2*node+1][0].suf;
 
	if (a[2*node+1][1].suf == a[2*node+1][0].tam) 
		a[node][1].suf = a[2*node][1].suf + a[2*node+1][1].suf;
	else a[node][1].suf = a[2*node+1][1].suf;
 
	a[node][0].ans = max({a[node][0].pre, a[node][0].suf, a[2*node][0].ans, a[2*node+1][0].ans, a[2*node][0].suf + a[2*node+1][0].pre});
	a[node][1].ans = max({a[node][1].pre, a[node][1].suf, a[2*node][1].ans, a[2*node+1][1].ans, a[2*node][1].suf + a[2*node+1][1].pre});
}
 
void build(int node, int i, int j) {
	if (i == j) {
		a[node][0].ans = a[node][0].pre = a[node][0].suf = (s[i] == '0');
		a[node][1].ans = a[node][1].pre = a[node][1].suf = (s[i] == '1');
		a[node][0].tam = 1;
	}
	else {
		int m = (i+j)/2;
		build(2*node, i, m);
		build(2*node+1, m+1, j);
		merge(node);
	}
}
 
void upd(int node, int i, int j, int pos) {
	if (i == j) {
		a[node][0].ans = a[node][0].pre = a[node][0].suf = (s[i] == '0');
		a[node][1].ans = a[node][1].pre = a[node][1].suf = (s[i] == '1');
	}
	else {
		int m = (i+j)/2;
		if (m >= pos) upd(2*node, i, m, pos);
		else upd(2*node+1, m+1, j, pos);
		merge(node);
	}
}
 
int main () { _
	cin >> s;
	int n = (int)s.size();
	build(1, 0, n-1);
	int q;
	cin >> q;
	int pos;
	for (int i = 0; i < q; i++) {
		cin >> pos;
		pos--;
		s[pos] = (s[pos] == '1' ? '0' : '1');
		upd(1, 0, n-1, pos);
		cout << max(a[1][0].ans, a[1][1].ans) << ' ';
	}
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Bit Problem}
\begin{lstlisting}
// Problem name: Bit Problem
// Problem Link: https://cses.fi/problemset/task/1654
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a list of n integers, your task is to calculate for each element x:
//     the number of elements y such that x | y = x
//     the number of elements y such that x & y = x
//     the number of elements y such that x & y != 0

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1<<20;
const ll INF = 2e18;
 
int v[200100], dp1[MAXN], dp2[MAXN], c[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> v[i];
		dp1[v[i]]++;
		dp2[v[i]]++;
		c[v[i]] = (v[i] ^ ((1<<20)-1));
	}
	for (int i = 0; i <= 19; i++) {
		for (int j = (1<<20)-1; j >= 0; j--) {
			if (j & (1<<i)) {
				dp1[j] += dp1[j ^ (1<<i)];
			}
		}
		for (int j = 0; j <= 1e6; j++) {
			if (!(j & (1<<i)) && (j ^ (1<<i)) <= 1e6) {
                dp2[j] += dp2[j ^ (1<<i)];
            }
		}
	}
	for (int i = 0; i < n; i++) {
		cout << dp1[v[i]] << ' ' << dp2[v[i]] << ' ' << n - dp1[c[v[i]]] << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{Bit Substrings}
\begin{lstlisting}
// Problem name: Bit Substrings
// Problem Link: https://cses.fi/problemset/task/2115
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a bit string of length n. 
// Your task is to calculate for each k between 0...n 
// the number of non-empty substrings that contain exactly k ones.
// For example, if the string is 101, there are:
//     1 substring that contains 0 ones: 0
//     4 substrings that contain 1 one: 01, 1, 1, 10
//     1 substring that contains 2 ones: 101
//     0 substrings that contain 3 ones

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
using cd = complex<double>;
const double PI = acos(-1);
 
void fft(vector<cd> & a, bool invert) {
    int n = a.size();
 
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;
 
        if (i < j)
            swap(a[i], a[j]);
    }
 
    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            cd w(1);
            for (int j = 0; j < len / 2; j++) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
 
    if (invert) {
        for (cd & x : a)
            x /= n;
    }
}
 
vector<ll> multiply(vector<int> const& a, vector<int> const& b) {
    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n < (int)(a.size() + b.size())) 
        n <<= 1;
    fa.resize(n);
    fb.resize(n);
 
    fft(fa, false);
    fft(fb, false);
    for (int i = 0; i < n; i++)
        fa[i] *= fb[i];
    fft(fa, true);
 
    vector<ll> result(n);
    for (int i = 0; i < n; i++)
        result[i] = round(fa[i].real());
    return result;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	string s;
    cin >> s;
    int n = (int)s.size();
    vector<int> v, w;
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        if (s[i] == '1') {
            v.push_back(cnt+1);
            cnt = 0;
        }
        else cnt++;
    }
    v.push_back(cnt+1);
    w = v;
    reverse(w.begin(), w.end());
    vector<ll> ans = multiply(v, w);
    ll zero = 0;
    for (int x : v) zero += (1ll * x * (x-1) / 2);
    cout << zero << ' ';
    int tot = 1;
    for (int i = (int)v.size(); i < (int)ans.size() && tot < n+1; i++) {
        cout << ans[i] << ' ';
        tot++;
    }
    while (tot < n+1) {
        cout << "0 ";
        tot++;
    }
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Book Shop II}
\begin{lstlisting}
// Problem name: Book Shop II
// Problem Link: https://cses.fi/problemset/task/1159
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are in a book shop which sells n different books. 
// You know the price, the number of pages and the number of copies of each book.
// You have decided that the total price of your purchases will be at most x. 
// What is the maximum number of pages you can buy? You can buy several copies of the same book.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
int cop[MAXN], pr[MAXN], pg[MAXN], dp[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, x;
    cin >> n >> x;
    for (int i = 0; i < n; i++) 
        cin >> pr[i];
    for (int i = 0; i < n; i++) 
        cin >> pg[i];  
    
    vector<int> pages, price;
    for (int i = 0; i < n; i++) {
        cin >> cop[i];
        int tot = 0;
        for (int j = 0; j < 10; j++) {
            if (cop[i] >= (1 << (j+1))) {
                pages.push_back(pg[i] * (1<<j));
                price.push_back(pr[i] * (1<<j));
                tot += (1<<j);
            }
        }
        pages.push_back(pg[i] * (cop[i] - tot));
        price.push_back(pr[i] * (cop[i] - tot));
    }
    int m = (int)pages.size();
    for (int i = 0; i < m; i++) {
        for (int j = x; j >= price[i]; j--) {
            dp[j] = max(dp[j-price[i]] + pages[i], dp[j]);
        }
    }
    int ans = 0;
    for (int i = 0; i <= x; i++) ans = max(ans, dp[i]);
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Chess Tournament}
\begin{lstlisting}
// Problem name: Chess Tournament
// Problem Link: https://cses.fi/problemset/task/1697
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There will be a chess tournament of n players. 
// Each player has announced the number of games they want to play.
// Each pair of players can play at most one game. 
// Your task is to determine which games will be played so that everybody will be happy.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int v[MAXN];
 
int main () { _
	int n;
	cin >> n;
	priority_queue<pii> fila;
	int tot = 0;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		if (v[i]) fila.push({v[i], i});
		tot = (v[i]&1 ? 1-tot : tot);
	}
	if (tot&1) cout << "IMPOSSIBLE\n";
	else {
		pii a1, a2;
		bool ok = true;
		vector<pii> ans;
		while (!fila.empty()) {
			a1 = fila.top();
			fila.pop();
			vector<pii> falta;
			while (v[a1.S]) {
				if (fila.empty()) {
					ok = false;
					break;
				}
				a2 = fila.top();
				fila.pop();
				v[a1.S]--, v[a2.S]--;
				ans.pb({a1.S, a2.S});
				if (v[a2.S]) falta.pb({v[a2.S], a2.S});
			}
			for (pii x : falta) fila.push(x);
		}
		if (!ok) cout << "IMPOSSIBLE\n";
		else {
			cout << ans.size() << '\n';
			for (pii x : ans) cout << x.F << ' ' << x.S << '\n';
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{Coding Company}
\begin{lstlisting}
// Problem name: Coding Company
// Problem Link: https://cses.fi/problemset/task/1665
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your company has n coders, and each of them has a skill level between 0 and 100.
// Your task is to divide the coders into teams that work together.
// Based on your experience, you know that teams work well when the 
// skill levels of the coders are about the same. 
// For this reason, the penalty for creating a team is the skill level difference between the best and the worst coder.
// In how many ways can you divide the coders into teams such that the sum of the penalties is at most x?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
int dp1[105][10010], dp2[105][10010], v[105];
 
int add(int a, int b) {
    if (a + b >= MOD)
        return a + b - MOD;
    if (a + b < 0)
        return a + b + MOD;
    return a + b;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, x;
    cin >> n >> x;
    for (int i = 1; i <= n; i++) cin >> v[i];
    sort(v + 1, v + n + 1);
    // dp1 receives from dp2
    dp2[0][5000] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= i; j++) {
            for (int k = 0; k <= 10000; k++) {
                dp1[j][k] = add(dp1[j][k], (1ll * dp2[j][k] * (j+1)) % MOD);
                if (k + v[i] <= 10000 && j) 
                    dp1[j][k] = add(dp1[j][k], dp2[j-1][k + v[i]]);
                if (k - v[i] >= 0)
                    dp1[j][k] = add(dp1[j][k], (1ll * dp2[j+1][k-v[i]] * (j+1)) % MOD);
            }
        }
        for (int j = 0; j <= i; j++) {
            for (int k = 0; k <= 5000 + x; k++) {
                dp2[j][k] = dp1[j][k];
                dp1[j][k] = 0;
            }
        }
    }
    int ans = 0;
    for (int i = 5000; i <= 10000; i++) 
        ans = add(ans, dp2[0][i]);
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Coin Arrangement}
\begin{lstlisting}
// Problem name: Coin Arrangement
// Problem Link: https://cses.fi/problemset/task/2180
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There is a 2 x n grid whose each cell contains some number of coins. The total number of coins is 2n.
// Your task is to arrange the coins so that each cell contains exactly one coin. 
// On each move you can choose any coin and move it one step left, right, up or down.
// What is the minimum number of moves if you act optimally?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
int v1[MAXN], v2[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n;
	cin >> n;
	for (int i = 0; i < n; i++) 
        cin >> v1[i], v1[i]--;
    for (int i = 0; i < n; i++) 
        cin >> v2[i], v2[i]--;
    int cima = 0, baixo = 0;
    ll ans = 0;
    for (int i = 0; i < n; i++) {
        ans += abs(cima) + abs(baixo);
        cima += v1[i];
        baixo += v2[i];
        while (cima > 0 && baixo < 0) 
            cima--, baixo++, ans++;
        while (cima < 0 && baixo > 0)
            cima++, baixo--, ans++;
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Coin Grid}
\begin{lstlisting}
// Problem name: Coin Grid
// Problem Link: https://cses.fi/problemset/task/1709
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There is an n x n grid whose each square is empty or has a coin. 
// On each move, you can remove all coins in a row or column.
// What is the minimum number of moves after which the grid is empty?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int n;
int vis[505];
vector<vector<int>> residualGraph;
 
bool bfs(vector<vector<int>>& residualGraph, vector<int>& level, int source, int sink) {
    fill(level.begin(), level.end(), -1);
	level[source] = 0;
	
	queue<int> q;
	q.push(source);
 
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		for (int v=0; v < n; v++)
		{
			if (u != v && residualGraph[u][v] > 0 && level[v] < 0)
			{
 
				level[v] = level[u] + 1;
				q.push(v);
			}
		}
	}
	return level[sink] < 0 ? false : true ;
}
 
int sendFlow(vector<vector<int>>& residualGraph, vector<int>& level, vector<int>& count, int u, int sink, int flow) {
	if (u == sink)
		return flow;
 
    if (count[u] == (int)residualGraph[u].size())
	    return 0;
 
	for (int v=0; v < n; v++)
	{
		if (residualGraph[u][v] > 0)
		{
		    count[u]++;
			if (level[v] == level[u]+1)
			{
			 	int curr_flow = min(flow, residualGraph[u][v]);
 
			    int min_cap = sendFlow(residualGraph, level, count, v, sink, curr_flow);
			    if (min_cap > 0)
			    {
                    residualGraph[u][v] -= min_cap;
                    residualGraph[v][u] += min_cap;
				    return min_cap;
			    }
			}
		}
	}
	return 0;
}
 
int dinic_algorithm(vector<vector<int>>& graph, int source, int sink) {
	if (source == sink)
		return -1;
 
	int max_flow = 0;
    residualGraph = graph;
    vector<int> level(n, -1);
 
	while (bfs(residualGraph, level, source, sink) == true)
	{
		vector<int> count(n, 0);
 
		while (int flow = sendFlow(residualGraph, level, count, source, sink, INT_MAX))
			max_flow += flow;
	}
	return max_flow;
}
 
void addEdge(vector<vector<int>>& graph, int u, int v, int w) {
    graph[u][v] = w;
}
 
int main() { _
	cin >> n;
	int tam = n;
	n = 2*n+2;
    vector<vector<int>> graph(n, vector<int> (n, 0));
	for (int i = 1; i <= tam; i++) {
		addEdge(graph, 0, i, 1);
		addEdge(graph, i+tam, n-1, 1);
		for (int j = tam+1; j <= 2*tam; j++) {
			char c;
			cin >> c;
			if (c == 'o') addEdge(graph, i, j, 200);
		}
	}
	cout <<  dinic_algorithm(graph, 0, n-1) << '\n';
	memset(vis, 0, sizeof(vis));
	queue<int> fila;
	fila.push(0);
	vis[0] = 1;
	while (!fila.empty()) {
		int atual = fila.front();
		fila.pop();
		for (int i = 1; i < n; i++) {
			if (!vis[i] && residualGraph[atual][i]) {
				vis[i] = 1;
				fila.push(i);
			}
		}
	}
	for (int i = 1; i <= tam; i++) {
		if (vis[0] != vis[i]) cout << "1 " << i << '\n';
	}
	for (int i = tam+1; i <= 2*tam; i++) {
		if (vis[n-1] != vis[i]) cout << "2 " << i-tam << '\n';
	}
	return 0;
}
\end{lstlisting}

\subsection{Counting Bishops}
\begin{lstlisting}
// Problem name: Counting Bishops
// Problem Link: https://cses.fi/problemset/task/2176
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to count the number of ways k bishops can be placed on an n x n chessboard 
// so that no two bishops attack each other.
// Two bishops attack each other if they are on the same diagonal.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e6 + 5;
const ll INF = 1e18;
 
int dp[1005][250010], n, k;
 
int count(int diag) {
    if (diag&1) return diag / 4 * 2 + 1;
    return (diag-1) / 4 * 2 + 2;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> k;
    if (k > 2*n-1) cout << "0\n";
    else {
        dp[0][0] = dp[1][0] = 1;
        dp[1][1] = 1;
        for (int i = 0; i < 2*n-2; i++) {
            for (int j = 0; j <= k; j++) {
                if (dp[i][j]) {
                    dp[i+2][j] += dp[i][j];
                    if (dp[i+2][j] >= MOD) dp[i+2][j] -= MOD;
                    if (count(i+2) - j > 0) {
                        dp[i+2][j+1] += (1ll * dp[i][j] * (count(i+2) - j)) % MOD;
                        if (dp[i+2][j+1] >= MOD) dp[i+2][j+1] -= MOD;
                    }
                }
            }
        }
        int ans = 0;
        for (int i = 0; i <= k; i++) {
            ans += (1ll * dp[2*n-1][i] * dp[2*n-2][k-i]) % MOD;
            if (ans >= MOD) ans -= MOD;
        }
        cout << ans << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{Counting Bits}
\begin{lstlisting}
// Problem name: Counting Bits
// Problem Link: https://cses.fi/problemset/task/1146
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to count the number of one bits in the binary representations of integers between 1 and n.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	ll n;
	cin >> n;
	ll ans = 0, aux, add, two;
	n++;

	for (int i = 0; i <= 60; i++) {
		two = (1ll<<i);
		aux = n - two;
		if (aux < 0) break;
		add = aux / two;
		if (add&1) add = ((add+1) / 2) * two;
		else add = add * two / 2 + aux % two;
		ans += add;
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Counting Reorders}
\begin{lstlisting}
// Problem name: Counting Reorders
// Problem Link: https://cses.fi/problemset/task/2421
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Calculate the number of ways you can reorder the characters 
// of a string so that no two adjacent characters are the same.
// For example, the answer for aabc is 6, 
// because the possible orders are abac, abca, acab, acba, baca, and caba.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 5e3 + 5;
const ll INF = 2e18;
 
int fat[MAXN], inv[MAXN], dp1[MAXN], dp2[MAXN], qtd[26];
 
ll fexp(ll b, ll e) {
    ll ans = 1;
    while (e) {
        if (e&1) ans = (ans * b) % MOD;
        b = (b * b) % MOD;
        e >>= 1;
    }
    return ans;
}
 
void precalc() {
    fat[0] = 1;
    for (int i = 1; i < MAXN; i++) fat[i] = (1ll * i * fat[i - 1]) % MOD;
    inv[MAXN - 1] = fexp(fat[MAXN - 1], MOD - 2);
    for (int i = MAXN - 2; i >= 0; i--) inv[i] = ((i + 1ll) * inv[i + 1]) % MOD;
}
 
int nck(int n, int k) {
    if (k > n || k < 0 || n < 0) return 0;
    return (((1ll * fat[n] * inv[k]) % MOD) * 1ll * inv[n - k]) % MOD; 
}
 
void add(int &a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
    if (a < 0) a += MOD;
}
 
int mul(int a, int b) {
    return (1ll * a * b) % MOD;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    precalc();
    string s;
    cin >> s;
    int n = s.size(), tot = 0;
    for (auto x : s) qtd[x - 'a']++;
    dp1[0] = 1;
    for (int i = 0; i < 26; i++) {
        // char atual
 
        if (!qtd[i]) continue;
        for (int j = 0; j <= tot; j++) {
            // qtd de grupos q eu tenho
 
            for (int k = 1; k <= qtd[i]; k++) {
                // qtd de grupos q vou add
 
                add(dp2[j + k], mul(dp1[j], mul(nck(qtd[i] - 1, k - 1), nck(j + k, k))));
            }
        }
        tot += qtd[i];
        for (int j = 0; j <= tot; j++) {
            dp1[j] = dp2[j];
            dp2[j] = 0;
        }
    }
    int ans = 0;
    for (int i = n; i > 0; i--) {
        if ((n - i) & 1) add(ans, MOD - dp1[i]);
        else add(ans, dp1[i]);
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Counting Sequences}
\begin{lstlisting}
// Problem name: Counting Sequences
// Problem Link: https://cses.fi/problemset/task/2228
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to count the number of sequences of length n where each element is an integer between 1...k
// and each integer between 1…k appears at least once in the sequence.
// For example, when n=6 and k=4, some valid sequences are [1,3,1,4,3,2] and [2,2,1,3,4,2].

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e6 + 5;
const ll INF = 2e18;
 
int fat[MAXN], inv[MAXN];
 
int fexp(ll b, int e) {
    ll ans = 1;
    while (e) {
        if (e & 1) ans = (ans * b) % MOD;
        b = (b * b) % MOD;
        e >>= 1;
    }
    return ans;
}
 
void init() {
    fat[0] = 1;
    for (int i = 1; i < MAXN; i++) fat[i] = (1ll * fat[i - 1] * i) % MOD;
    inv[MAXN - 1] = fexp(fat[MAXN - 1], MOD - 2);
    for (int i = MAXN - 2; i >= 0; i--) inv[i] = (1ll * inv[i + 1] * (i + 1)) % MOD;
}
 
int mul(int a, int b) {
    return 1ll * a * b % MOD;
}
 
void add(int &a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
    if (a < 0) a += MOD;
}
 
int nck(int n, int k) {
    if (k > n || k < 0) return 0;
    return (((1ll * fat[n] * inv[k]) % MOD) * 1ll * inv[n - k]) % MOD;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    init();
    int n, k;
    cin >> n >> k;
    int ans = 0;
    for (int i = 0; i < k; i++) {
        add(ans, (i % 2 == 0 ? 1 : -1) * mul(fexp(k - i, n), nck(k, k - i)));
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Course Schedule II}
\begin{lstlisting}
// Problem name: Course Schedule II
// Problem Link: https://cses.fi/problemset/task/1757
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You want to complete n courses that have requirements of the form "course a has to be completed before course b".
// You want to complete course 1 as soon as possible. If there are several ways to do this, 
// you want then to complete course 2 as soon as possible, and so on.
// Your task is to determine the order in which you complete the courses.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
vector<int> v[MAXN];
int deg[MAXN], ans1[MAXN], ans2[MAXN];
 
int main () { _
	int n, m;
	cin >> n >> m;
	set<int> s;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[b].pb(a);
		deg[a]++;
	}
	for (int i = 1; i <= n; i++) 
		if (!deg[i]) s.insert(i);
	int cnt = n;
	while (!s.empty()) {
		auto x = s.end();
		x--;
		int a = *x;
		s.erase(a);
		ans1[a] = cnt--;
		for (int x : v[a]) {
			deg[x]--;
			if (!deg[x]) s.insert(x);
		}
	}
	for (int i = 1; i <= n; i++) ans2[ans1[i]] = i;
	for (int i = 1; i <= n; i++) cout << ans2[i] << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Creating Offices}
\begin{lstlisting}
// Problem name: Creating Offices
// Problem Link: https://cses.fi/problemset/task/1752
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n cities and n−1 roads between them. 
// There is a unique route between any two cities, and their distance is the number of roads on that route.
// A company wants to have offices in some cities,
// but the distance between any two offices has to be at least d. 
// What is the maximum number of offices they can have?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
vector<int> v[MAXN], ord;
int sz[MAXN], to[20][MAXN], dist[20][MAXN], dep[MAXN], pai[MAXN], ans[MAXN], lvl[MAXN], n, d, tot;
bool vis[MAXN], usei[MAXN];
 
// preprocess
void dfs(int node, int p = 0) {
    if (!p) to[0][node] = node;
    else to[0][node] = p;
    dep[node] = dep[p] + 1;
    for (int x : v[node]) {
        if (x != p) dfs(x, node);
    }
}
void preprocess() {
    dfs(1);
    for (int i = 1; i < 20; i++) {
        for (int j = 1; j <= n; j++) to[i][j] = to[i - 1][to[i - 1][j]];
    }
}
int lca(int a, int b) {
    if (dep[a] < dep[b]) swap(a, b);
    for (int i = 19; i >= 0; i--) {
        if (dep[a] - (1 << i) >= dep[b]) {
            a = to[i][a];
        }
    }
    if (a == b) return a;
    for (int i = 19; i >= 0; i--) {
        if (to[i][a] != to[i][b]) {
            a = to[i][a];
            b = to[i][b];
        }
    }
    return to[0][a];
}
 
 
// centroid decomposition
int subtree(int node, int p = 0) {
    sz[node] = 1;
    for (int x : v[node]) {
        if (!vis[x] && x != p) {
            sz[node] += subtree(x, node);
        }
    }
    return sz[node];
}
int centroid(int node, int desired, int p = 0) {
    for (int x : v[node]) {
        if (!vis[x] && x != p && sz[x] > desired) {
            return centroid(x, desired, node);
        }
    }
    return node;
}
void dfs1(int node, int p, int l, int d) {
    dist[l][node] = d;
    for (int x : v[node]) {
        if (!vis[x] && x != p) {
            dfs1(x, node, l, d + 1);
        }
    }
}
void solve(int node, int p = 0) {
    int c = centroid(node, subtree(node) / 2);
    vis[c] = true;
    if (p == 0) {
        pai[c] = c;
        lvl[c] = 0;
    } 
    else {
        pai[c] = p;
        lvl[c] = lvl[p] + 1;
    }
    dfs1(c, p, lvl[c], 0);
    for (int x : v[c]) {
        if (!vis[x]) {
            solve(x, c);
        }
    }
}
 
 
// queries
void upd(int node) {
    tot++;
    usei[node] = true;
    int x = node;
    while (true) {
        ans[x] = min(ans[x], dist[lvl[x]][node]);
        if (x == pai[x]) break;
        x = pai[x];
    }
}
int query(int node) {
    int mn = n + 5, x = node;
    while (true) {
        mn = min(mn, ans[x] + dist[lvl[x]][node]);
        if (x == pai[x]) break;
        x = pai[x];
    }
    return mn;
}
 
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> d;
    int a, b;
    for (int i = 0; i < n - 1; i++) {
        cin >> a >> b;
        v[a].push_back(b);
        v[b].push_back(a);
    }
    preprocess();
    solve(1);
    for (int i = 1; i <= n; i++) {
        ans[i] = 1e9;
        ord.push_back(i);
    }
    sort(ord.begin(), ord.end(), [&] (int a, int b){
        return dep[a] > dep[b];
    }); 
    upd(ord[0]);
    for (int i = 1; i < n; i++) {
        if (query(ord[i]) >= d) {
            upd(ord[i]);
        }
    }
    cout << tot << '\n';
    for (int i = 1; i <= n; i++) {
        if (usei[i]) cout << i << ' ';
    }
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Critical Cities}
\begin{lstlisting}
// Problem name: Critical Cities
// Problem Link: https://cses.fi/problemset/task/1703
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n cities and m flight connections between them. 
// A city is called a critical city if it appears on every route from a city to another city.
// Your task is to find all critical cities from 1 to n

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
// Dominator Tree - Kawakami
//
// Se vira pra usar ai
//
// build - O(n)
// dominates - O(1)
// c80920
 
int n;
 
namespace d_tree {
	vector<int> g[MAXN];
 
	// The dominator tree
	vector<int> tree[MAXN];
	int dfs_l[MAXN], dfs_r[MAXN];
 
	// Auxiliary data
	vector<int> rg[MAXN], bucket[MAXN];
	int idom[MAXN], sdom[MAXN], prv[MAXN], pre[MAXN];
	int ancestor[MAXN], label[MAXN];
	vector<int> preorder;
 
	void dfs(int v) {
		static int t = 0;
		pre[v] = ++t;
		sdom[v] = label[v] = v;
		preorder.push_back(v);
		for (int nxt: g[v]) {
			if (sdom[nxt] == -1) {
				prv[nxt] = v;
				dfs(nxt);
			}
			rg[nxt].push_back(v);
		}
	}
	int eval(int v) {
		if (ancestor[v] == -1) return v;
		if (ancestor[ancestor[v]] == -1) return label[v];
		int u = eval(ancestor[v]);
		if (pre[sdom[u]] < pre[sdom[label[v]]]) label[v] = u;
		ancestor[v] = ancestor[u];
		return label[v];
	}
	void dfs2(int v) {
		static int t = 0;
		dfs_l[v] = t++;
		for (int nxt: tree[v]) dfs2(nxt);
		dfs_r[v] = t++;
	}
	void build(int s) {
		for (int i = 0; i < n; i++) {
			sdom[i] = pre[i] = ancestor[i] = -1;
			rg[i].clear();
			tree[i].clear();
			bucket[i].clear();
		}
		preorder.clear();
		dfs(s);
		if (preorder.size() == 1) return;
		for (int i = int(preorder.size()) - 1; i >= 1; i--) {
			int w = preorder[i];
			for (int v: rg[w]) {
				int u = eval(v);
				if (pre[sdom[u]] < pre[sdom[w]]) sdom[w] = sdom[u];
			}
			bucket[sdom[w]].push_back(w);
			ancestor[w] = prv[w];
			for (int v: bucket[prv[w]]) {
				int u = eval(v);
				idom[v] = (u == v) ? sdom[v] : u;
			}
			bucket[prv[w]].clear();
		}
		for (int i = 1; i < preorder.size(); i++) {
			int w = preorder[i];
			if (idom[w] != sdom[w]) idom[w] = idom[idom[w]];
			tree[idom[w]].push_back(w);
		}
		idom[s] = sdom[s] = -1;
		dfs2(s);
	}
 
	// Whether every path from s to v passes through u
	bool dominates(int u, int v) {
		if (pre[v] == -1) return 1; // vacuously true
		return dfs_l[u] <= dfs_l[v] && dfs_r[v] <= dfs_r[u];
	}
};
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int m, a, b;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		a--, b--;
		d_tree::g[a].push_back(b);
	}
	d_tree::build(0);
	vector<int> ans;
	for (int i = 0; i < n; i++) {
		if (d_tree::dominates(i, n - 1)) ans.push_back(i + 1);
	}
	cout << ans.size() << '\n';
	for (int x : ans) cout << x << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Cyclic Array}
\begin{lstlisting}
// Problem name: Cyclic Array
// Problem Link: https://cses.fi/problemset/task/1191
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a cyclic array consisting of n values. Each element has two neighbors; 
// the elements at positions n and 1 are also considered neighbors.
// Your task is to divide the array into subarrays so that the sum of each subarray is at most k. 
// What is the minimum number of subarrays?


#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const ll INF = 2e18;
 
ll v[MAXN], pre[MAXN], to[MAXN], n, b;
 
void solve() {
    int r = 1; 
    for (int l = 1; l <= 2 * n; l++) {
        while (r <= 2 * n && pre[r + 1] - pre[l - 1] <= b) r++;
        to[l] = r;
    }
    int mn = 2 * n + 1, id = -1;
    for (int i = 1; i <= n; i++) {
        if (to[i] - i + 1 < mn) {
            mn = to[i] - i + 1;
            id = i;
        }
    }
    int st = id, ans = 1e9;
    for (int i = id; i <= id + mn; i++) {
        int cur = st, cnt = 0;
        while (cur - st < n) {
            cur = to[cur] + 1;
            cnt++;
        }
        ans = min(ans, cnt);
        st = st % n + 1;
    }
    cout << ans << '\n';
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> b;
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
        v[i + n] = v[i];
    }
    for (int i = 1; i <= 2 * n; i++) {
        pre[i] = v[i] + pre[i - 1];
    }
    solve();
    return 0;
}
\end{lstlisting}

\subsection{Empty String}
\begin{lstlisting}
// Problem name: Empty String
// Problem Link: https://cses.fi/problemset/task/1080
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a string consisting of n characters between a and z.
// On each turn, you may remove any two adjacent characters that are equal. 
// Your goal is to construct an empty string by removing all the characters.
// In how many ways can you do this?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
int add(int a, int b) {
    if (a + b >= MOD)
        return a + b - MOD;
    if (a + b < 0)
        return a + b + MOD;
    return a + b;
}
 
int dp[505][505], c[505][505];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    int n = (int)s.size();
    c[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        c[i][0] = 1;
        for (int j = 1; j <= i; j++) {
            c[i][j] = add(c[i-1][j], c[i-1][j-1]);
        }
    }
    for (int i = 0; i+1 <= n; i++) 
        dp[i+1][i] = 1;
 
    for (int i = n-1; i >= 0; i--) {
        for (int j = i+1; j < n; j+=2) {
            for (int k = i+1; k <= j; k+=2) {
                if (s[i] == s[k]) 
                    dp[i][j] = add(dp[i][j], (((1ll * dp[i+1][k-1] * dp[k+1][j]) % MOD) * c[(j-i+1)/2][(k-i+1)/2]) % MOD);            
            }
        }
    }
    cout << dp[0][n-1] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Even Outdegree Edges}
\begin{lstlisting}
// Problem name: Even Outdegree Edges
// Problem Link: https://cses.fi/problemset/task/2179
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given an undirected graph, your task is to choose a direction for each edge so 
// that in the resulting directed graph each node has an even outdegree. 
// The outdegree of a node is the number of edges coming out of that node.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
vector<int> v[MAXN];
int vis[MAXN], cnt = 0, deg[MAXN], dep[MAXN];
 
void dfs(int node, int pai) {
	dep[node] = dep[pai]+1;
	vis[node] = 1;
	for (int x : v[node]) {
		cnt++;
		if (x == pai) continue;
		if (!vis[x]) 
			dfs(x, node);
	}
}
 
void dfs2(int node, int pai) {
	vis[node] = 1;
	for (int x : v[node]) {
		if (x == pai) continue;
		if (!vis[x]) {
			dfs2(x, node);
			if (deg[x]) 
				cout << x << ' ' << node << '\n';
			else {
				cout << node << ' ' << x << '\n';
				deg[node] ^= 1;
			}
		}
		else if (dep[node] > dep[x]) {
			cout << node << ' ' << x << '\n';
			deg[node] ^= 1;
		}
	}
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	bool valid = true;
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			cnt = 0;
			dfs(i, 0);
			cnt /= 2;
			valid &= (cnt % 2 == 0);
		}
	}
	if (!valid) cout << "IMPOSSIBLE\n";
	else {
		memset(vis, 0, sizeof(vis));
		for (int i = 1; i <= n; i++) {
			if (!vis[i]) {
				dfs2(i, 0);
			}
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{Filling Trominos}
\begin{lstlisting}
// Problem name: Filling Trominos
// Problem Link: https://cses.fi/problemset/task/2423
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to fill an n×m grid using L-trominos 
// (three squares that have an L-shape).

#include <bits/stdc++.h>
 
using namespace std;
 
int v[105][105];
string impar[] = {
	"ABBAA",
	"AABAB",
	"BBABB",
	"ABAAC",
	"AABCC",
	"CBBDD",
	"CCAAD",
	"ABBAC",
	"AABCC"
};
 
void even(int x, int y, int n, int m) {
	for (int i = x; i < n; i += 3) {
		for (int j = y; j < m; j += 2) {
			
			// preencher um 3x2
			set<int> st;
			st.insert(v[i - 1][j]);
			st.insert(v[i - 1][j + 1]);
			st.insert(v[i][j - 1]);
			st.insert(v[i + 1][j - 1]);
			int cor;
			for (int k = 0; k <= 4; k++) {
				if (st.count(k) == 0) {
					cor = k;
					break;
				}
			}
			v[i][j] = v[i + 1][j] = v[i][j + 1] = cor;
			st.clear();
			st.insert(cor);
			st.insert(v[i + 2][j - 1]);
			for (int k = 0; k <= 2; k++) {
				if (st.count(k) == 0) {
					cor = k;
					break;
				}
			}
			v[i + 2][j] = v[i + 1][j + 1] = v[i + 2][j + 1] = cor;
		}
	}
}
 
void odd(int x, int j, int n, int m) {
	for (int i = x; i < n; i += 2) {
		set<int> st;
		st.insert(v[i - 1][j]);
		st.insert(v[i - 1][j + 1]);
		st.insert(v[i][j - 1]);
		st.insert(v[i + 1][j - 1]);
		int cor;
		for (int k = 0; k <= 4; k++) {
			if (st.count(k) == 0) {
				cor = k;
				break;
			}
		}
		v[i][j] = v[i + 1][j] = v[i][j + 1] = cor;
		st.clear();
		st.insert(cor);
		st.insert(v[i - 1][j + 2]);
		for (int k = 0; k <= 2; k++) {
			if (st.count(k) == 0) {
				cor = k;
				break;
			}
		}
		v[i][j + 2] = v[i + 1][j + 1] = v[i + 1][j + 2] = cor;
	}
	even(x, j + 3, n, m);
}
 
void oodd(int x, int y, int n, int m) {
	for (int i = x; i < x + 9; i++) {
		for (int j = y; j < y + 5; j++) v[i][j] = impar[i - x][j - y] - 'A';
	}
	odd(x + 9, y, n, y + 5);
	even(x, y + 5, n, m);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
	cin >> t;
	while (t--) {
		int n, m;
		cin >> n >> m;
		bool sw = false, ok = false;
		if (n % 3 != 0) {
			swap(n, m);
			sw = true;
		}
		if (n % 3 != 0 || min(n, m) < 2) cout << "NO\n";
		else if (m % 2 == 0) {
			// m par e n par ou impar
			
			ok = true;
			even(1, 1, n + 1, m + 1);
 
		}
		else if (n % 2 == 0) {
			// n par e m impar
			
			ok = true;	
			odd(1, 1, n + 1, m + 1);
		}
		else {
			// ambos impares
			
			if (n < 9 || m < 5) cout << "NO\n";
			else {
				ok = true;
				oodd(1, 1, n + 1, m + 1);
			}
		}
		if (ok) {
			cout << "YES\n";
			if (sw) {
				for (int i = 1; i <= m; i++) {
					for (int j = 1; j <= n; j++) cout << char('A' + v[j][i]);
					cout << '\n';
				}
			}
			else {
				for (int i = 1; i <= n; i++) {
					for (int j = 1; j <= m; j++) cout << char('A' + v[i][j]);
					cout << '\n';
				}
			}
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{Flight Route Requests}
\begin{lstlisting}
// Problem name: Flight Route Requests
// Problem Link: https://cses.fi/problemset/task/1699
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n cities with airports but no flight connections. 
// You are given m requests which routes should be possible to travel.
// Your task is to determine the minimum number of one-way flight connections 
// which makes it possible to fulfil all requests.


#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 10;
const ll INF = 2e18;
 
vector<int> v[MAXN], w[MAXN], cmp[MAXN];
int at = 0, vis[MAXN];
 
void dfs(int node) {
    vis[node] = 1;
    cmp[at].push_back(node);
    for (int x : w[node]) {
        if (!vis[x]) dfs(x);
    }
}
 
bool dfs2(int node) {
    bool cic = false;
    vis[node] = 1;
    for (int x : v[node]) {
        if (vis[x] == 1) cic = true;
        if (!vis[x]) cic |= dfs2(x);
    }
    vis[node] = 2;
    return cic;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
    cin >> n >> m;
    int a, b;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        v[a].push_back(b);
        w[a].push_back(b);
        w[b].push_back(a);
    }
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) {
            dfs(i);
            at++;
        }
    }
    memset(vis, 0, sizeof(vis));
    int ans = 0;
    for (int i = 0; i < at; i++) {
        bool cic = false;
        for (int x : cmp[i]) {
            if (!vis[x]) cic |= dfs2(x);
        }
        if (cic) ans += cmp[i].size();
        else ans += cmp[i].size() - 1;
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Food Division}
\begin{lstlisting}
// Problem name: Food Division
// Problem Link: https://cses.fi/problemset/task/1189
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n children around a round table. 
// For each child, you know the amount of food they currently have and the amount of food they want. 
// The total amount of food in the table is correct.
// At each step, a child can give one unit of food to his or her neighbour. 
// What is the minimum number of steps needed?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const ll INF = 2e18;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    vector<int> a(n), b(n), flow(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }
    for (int i = 0; i < n; i++) {
        cin >> b[i];
        a[i] = b[i] - a[i];
        if (i) flow[i] = flow[i - 1] + a[i - 1];
    }
    sort(flow.begin(), flow.end());
    int ans = flow[n / 2];
    ll tot = 0;
    for (int i = 0; i < n; i++) {
        tot += abs(flow[i] - ans);
    }
    cout << tot << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Forbidden Cities}
\begin{lstlisting}
// Problem name: Forbidden Cities
// Problem Link: https://cses.fi/problemset/task/1705
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n cities and m bidirectional roads between them
// You are given q queries of the form a, b, c
// For each query, answer if it is possible to travel from city a to city b without going through city c

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
// Block-Cut Tree
//
// Cria a block-cut tree, uma arvore com os blocos
// e os pontos de articulacao
// Blocos sao componentes 2-vertice-conexos maximais
// Uma 2-coloracao da arvore eh tal que uma cor sao
// os blocos, e a outra cor sao os pontos de art.
// Funciona para grafo nao conexo
//
// art[i] responde o numero de novas componentes conexas
// criadas apos a remocao de i do grafo g
// Se art[i] >= 1, i eh ponto de articulacao
// 
// Para todo i <= blocks.size()
// blocks[i] eh uma componente 2-vertce-conexa maximal
// edgblocks[i] sao as arestas do bloco i
// tree[i] eh um vertice da arvore que corresponde ao bloco i
// 
// pos[i] responde a qual vertice da arvore vertice i pertence
// Arvore tem no maximo 2n vertices
//
// O(n+m)
// 056fa2
 
struct block_cut_tree {
	vector<vector<int>> g, blocks, tree;
	vector<vector<pair<int, int>>> edgblocks;
	stack<int> s;
	stack<pair<int, int>> s2;
	vector<int> id, art, pos;
	
	block_cut_tree(vector<vector<int>> g_) : g(g_) {
		int n = g.size();
		id.resize(n, -1), art.resize(n), pos.resize(n);
		build();
	}
 
	int dfs(int i, int& t, int p = -1) {
		int lo = id[i] = t++;
		s.push(i);	
		
		if (p != -1) s2.emplace(i, p);
		for (int j : g[i]) if (j != p and id[j] != -1) s2.emplace(i, j);
		
		for (int j : g[i]) if (j != p) {
			if (id[j] == -1) {
				int val = dfs(j, t, i);
				lo = min(lo, val);
 
				if (val >= id[i]) {
					art[i]++;
					blocks.emplace_back(1, i);
					while (blocks.back().back() != j) 
						blocks.back().push_back(s.top()), s.pop();
 
					edgblocks.emplace_back(1, s2.top()), s2.pop();
					while (edgblocks.back().back() != pair(j, i))
						edgblocks.back().push_back(s2.top()), s2.pop();
				}
				// if (val > id[i]) aresta i-j eh ponte
			}
			else lo = min(lo, id[j]);
		}
		
		if (p == -1 and art[i]) art[i]--;
		return lo;
	}
 
	void build() {
		int t = 0;
		for (int i = 0; i < g.size(); i++) if (id[i] == -1) dfs(i, t, -1);
		
		tree.resize(blocks.size());
		for (int i = 0; i < g.size(); i++) if (art[i]) 
			pos[i] = tree.size(), tree.emplace_back();
 
		for (int i = 0; i < blocks.size(); i++) for (int j : blocks[i]) {
			if (!art[j]) pos[j] = i;
			else tree[i].push_back(pos[j]), tree[pos[j]].push_back(i);
		}
	}
};
 
int tab[20][MAXN], dep[MAXN];
vector<vector<int>> g;
 
int lca(int a, int b) {
    if (dep[a] < dep[b]) swap(a, b);
    for (int i = 19; i >= 0; i--) {
        if (dep[a] - (1 << i) >= dep[b]) a = tab[i][a];
    }
    if (a == b) return a;
    for (int i = 19; i >= 0; i--) {
        if (tab[i][a] != tab[i][b]) {
            a = tab[i][a], b = tab[i][b];
        }
    }
    return tab[0][a];
}
 
void dfs(int node, int pai, block_cut_tree &ber) {
    dep[node] = dep[pai] + 1;
    tab[0][node] = pai;
    for (int i = 1; i < 20; i++) tab[i][node] = tab[i - 1][tab[i - 1][node]];
    for (int x : ber.tree[node]) {
        if (x != pai)
            dfs(x, node, ber);
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, q, a, b, c;
    cin >> n >> m >> q;
    g.resize(n);
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        a--, b--;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    block_cut_tree ber(g);
    dfs(ber.pos[0], ber.pos[0], ber);
    for (int i = 0; i < q; i++) {
        cin >> a >> b >> c;
        a--, b--, c--;
        if (a == c || b == c) cout << "NO\n";
        else if (!ber.art[c]) cout << "YES\n";
        else {
            a = ber.pos[a], b = ber.pos[b], c = ber.pos[c];
            int x = lca(a, b), y = lca(a, c), z = lca(b, c);
            if (x == c || (y == x && z == c) || (z == x && y == c)) cout << "NO\n";
            else cout << "YES\n"; 
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{Functional Graph Distribution}
\begin{lstlisting}
// Problem name: Functional Graph Distribution
// Problem Link: https://cses.fi/problemset/task/2415
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given n, your task is to calculate for each k=1...n 
// the number of functional graphs that have n nodes and k components.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 5e3 + 5;
const ll INF = 2e18;
 
int fat[MAXN], inv[MAXN], pwr[MAXN], stirling[MAXN][MAXN];
 
ll fexp(ll b, ll e) {
    ll ans = 1;
    while (e) {
        if (e&1) ans = (ans * b) % MOD;
        b = (b * b) % MOD;
        e >>= 1;
    }
    return ans;
}
 
ll nck(int n, int k) {
    if (k > n || k < 0 || n < 0) return 0;
    return (((1ll * fat[n] * inv[k]) % MOD) * 1ll * inv[n - k]) % MOD; 
}
 
void add(int &a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
    if (a < 0) a += MOD;
}
 
int mul(ll a, ll b) {
    return (a * b) % MOD;
}
 
void precalc(ll n) {
    fat[0] = 1;
    for (ll i = 1; i < MAXN; i++) fat[i] = (i * fat[i - 1]) % MOD;
    inv[MAXN - 1] = fexp(fat[MAXN - 1], MOD - 2);
    for (ll i = MAXN - 2; i >= 0; i--) inv[i] = ((i + 1ll) * inv[i + 1]) % MOD;
    pwr[0] = 1;
    for (int i = 1; i < MAXN; i++) pwr[i] = (n * pwr[i - 1]) % MOD;
    stirling[0][0] = 1;
    for (int i = 1; i < MAXN; i++) {
        for (int j = 1; j < MAXN; j++) {
            stirling[i][j] = mul(i - 1, stirling[i - 1][j]);
            add(stirling[i][j], stirling[i - 1][j - 1]);
        }
    }
}
 
int ans[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    precalc(n);
    for (int k = 1; k <= n; k++) {
        for (int x = k; x <= n; x++) {
            if (x < n)
                add(ans[k], mul(mul(nck(n, x), stirling[x][k]), mul(x, pwr[n - x - 1])));
            else 
                add(ans[k], mul(nck(n, x), stirling[x][k]));
        }
        cout << ans[k] << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{Graph Girth}
\begin{lstlisting}
// Problem name: Graph Girth
// Problem Link: https://cses.fi/problemset/task/1707
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given an undirected graph, your task is to determine its girth, i.e., the length of its shortest cycle.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2505
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
vector<int> v[MAXN];
int dist[MAXN];
 
int main() { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	int ans = MAXN;
	for (int i = 1; i <= n; i++) {
		memset(dist, -1, sizeof(dist));
		dist[i] = 0;
		queue<int> fila;
		fila.push(i);
		int achei = MAXN, atual;
		while (!fila.empty() && dist[atual] <= achei) {
			atual = fila.front();
			fila.pop();
			for (int x : v[atual]) {
				if (dist[x] == -1) {
					dist[x] = dist[atual]+1;
					fila.push(x);
				}
				else if (dist[x] >= dist[atual]) {
					ans = min(ans, dist[x] + dist[atual] + 1);
					achei = dist[atual];
				}
			}
		}
	}
	cout << (ans==MAXN ? -1 : ans) << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Grid Completion}
\begin{lstlisting}
// Problem name: Grid Completion
// Problem Link: https://cses.fi/problemset/task/2429
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 5e2 + 5;
const ll INF = 2e18;
 
ll fat[MAXN], inv[MAXN];
 
ll fexp(ll b, ll e) {
    ll ans = 1;
    while (e) {
        if (e&1) ans = (ans * b) % MOD;
        b = (b * b) % MOD;
        e >>= 1;
    }
    return ans;
}
 
void precalc() {
    fat[0] = 1;
    for (ll i = 1; i < MAXN; i++) fat[i] = (i * fat[i - 1]) % MOD;
    inv[MAXN - 1] = fexp(fat[MAXN - 1], MOD - 2);
    for (ll i = MAXN - 2; i >= 0; i--) inv[i] = ((i + 1ll) * inv[i + 1]) % MOD;
}
 
ll nck(int n, int k) {
    if (k > n || k < 0 || n < 0) return 0;
    return (((fat[n] * inv[k]) % MOD) * inv[n - k]) % MOD; 
}
 
void add(int &a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
    if (a < 0) a += MOD;
}
 
ll mul(ll a, ll b) {
    return (a * b) % MOD;
}
 
int inl[505], inc[505], outl[505], outc[505], v[6], dp[505];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    precalc();
    int n;
    cin >> n;
    char c;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> c;
            if (c == 'A') {
                outl[i] = j;
                inc[j] = i;
            }
            if (c == 'B') {
                inl[i] = j;
                outc[j] = i;
            }
        }
    }
    for (int i = 1; i <= n; i++) {
        v[0] += (!inl[i] && !outl[i]);
        v[1] += (!inc[i] && !outc[i]);
        v[2] += (outl[i] && !outc[outl[i]] && !inl[i]);
        v[3] += (outc[i] && !outl[outc[i]] && !inc[i]);
        v[4] += (!outl[i]);
        v[5] += (!inl[i]);
    }
    for (int i = 0; i <= min(v[0], v[1]); i++) {
        for (int j = 0; j <= v[2]; j++) {
            for (int k = 0; k <= v[3]; k++) {
                ll nv = mul(nck(v[0], i), nck(v[1], i));
                nv = mul(nv, nck(v[2], j));
                nv = mul(nv, nck(v[3], k));
                nv = mul(nv, fat[v[4] - i - k]);
                nv = mul(nv, fat[v[5] - i - j]);
                nv = mul(nv, fat[i]);
                add(dp[i + j + k], nv);
            }
        }
    }
    int ans = 0;
    for (int i = 0; i <= n; i++) {
        add(ans, (i&1 ? MOD - dp[i] : dp[i]));
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Grid Path Construction}
\begin{lstlisting}
// Problem name: Grid Path Construction
// Problem Link: https://cses.fi/problemset/task/2418
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given an nxm grid and two squares a=(y1,x1) and b=(y2,x2), 
// create a path from a to b that visits each square exactly once.

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const int INF = 2e9;
 
int dist(int a, int b, int c, int d) {
    return abs(a - c) + abs(b - d);
}
 
bool hamilton(int n, int m, int l1, int c1, int l2, int c2) {
    // recebe linhas, colunas e dois pontos
    // retorna se tem caminho hamiltoniano entre os pontos no grid
 
    int mn = min(n, m), mx = max(n, m);
    int p1 = (l1 + c1) % 2, p2 = (l2 + c2) % 2;
    bool ok = true;
    if ((n * m) % 2 == 0) {
        ok &= (p1 != p2);
        if (mn == 1) {
            ok &= dist(l1, c1, l2, c2) == mx - 1;
        }
        else if (mn == 2) {
            if (n >= m) {
                ok &= (l1 != l2 || l1 == 1 || l1 == n);
            }
            if (n < m) {
                ok &= (c1 != c2 || c1 == 1 || c1 == m);
            }
        }
        else if (mn == 3) {
            if (n >= m) {
                if (p1) {
                    if (c1 == 2 && l1 < l2) ok = false;
                    if (c1 != 2 && l1 < l2 - 1) ok = false;
                }
                if (p2) {
                    if (c2 == 2 && l2 < l1) ok = false;
                    if (c2 != 2 && l2 < l1 - 1) ok = false;
                }
            }
            if (n < m) {
                if (p1) {
                    if (l1 == 2 && c1 < c2) ok = false;
                    if (l1 != 2 && c1 < c2 - 1) ok = false;
                }
                if (p2) {
                    if (l2 == 2 && c2 < c1) ok = false;
                    if (l2 != 2 && c2 < c1 - 1) ok = false;
                }
            }
        }
    }
    if ((n * m) % 2 == 1) {
        ok &= (!p1 && !p2);
        if (mn == 1) {
            ok &= dist(l1, c1, l2, c2) == mx - 1;
        }
    }
    return ok;
}
 
int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};
char c[4] = {'D', 'U', 'R', 'L'};
map<char, int> mp = {{'D', 0}, {'U', 1}, {'R', 2}, {'L', 3}};
 
string top;
int check[51][51];
bool valid(int x, int y, int n, int m) { return (x > 0 && x <= n && y > 0 && y <= m && !check[x][y]); }
bool miou(int x, int y, int gx, int gy, int n, int m) {
    if (x == gx && y == gy) return true;
    if (min(n, m) > 2) return false;
    if (valid(x+1, y, n, m) && valid(x-1, y, n, m) && !valid(x, y+1, n, m) && !valid(x, y-1, n, m)) return true;
    if (!valid(x+1, y, n, m) && !valid(x-1, y, n, m) && valid(x, y+1, n, m) && valid(x, y-1, n, m)) return true;
    return false;
}
 
bool run(int x, int y, int gx, int gy, int n, int m) {
    if (top.size() == n * m - 1) return true;
    if (miou(x, y, gx, gy, n, m)) return false;
    check[x][y] = 1;
    bool ok = false;
    for (int i = 0; i < 4; i++) {
        if (valid(x + dx[i], y + dy[i], n, m)) {
            top += c[i];
            ok |= run(x + dx[i], y + dy[i], gx, gy, n, m);
            if (ok) break;
            top.pop_back();
        }
    }
    check[x][y] = 0;
    return ok;
}
 
string brute(int n, int m, int l1, int c1, int l2, int c2) {
    top.clear();
    run(l1, c1, l2, c2, n, m);
    return top;
}
 
void upd(pii *a, char c) {
    a->first += dx[mp[c]];
    a->second += dy[mp[c]];
}
 
string solve(int n, int m, int l1, int c1, int l2, int c2) {
    int mn = min(n, m), mx = max(n, m);
    if ((mn == 1) || (mn == 2) || (mn == 3 && mx == 3) || (mn == 4 && mx <= 5)) {
        // prime grid
        return brute(n, m, l1, c1, l2, c2);
    }
 
    // STRIP
    string ans, nv;
    // dois de cima
    if (n > 3 && l1 > 2 && l2 > 2 && hamilton(n - 2, m, l1 - 2, c1, l2 - 2, c2)) {
        ans = solve(n - 2, m, l1 - 2, c1, l2 - 2, c2);
        pii pos = {l1, c1};
        bool ja = false;
        for (int i = 0; i < (int)ans.size(); i++) {
            if (ans[i] == 'R' && pos.first == 3 && !ja) {
                nv += 'U';
                nv += solve(2, m, 2, pos.second, 2, pos.second + 1);
                nv += 'D';
                ja = true;
                upd(&pos, ans[i]);
                continue;
            }
            if (ans[i] == 'L' && pos.first == 3 && !ja) {
                nv += 'U';
                nv += solve(2, m, 2, pos.second, 2, pos.second - 1);
                nv += 'D';
                ja = true;
                upd(&pos, ans[i]);
                continue;
            }
            nv += ans[i];
            upd(&pos, ans[i]);
        }
        return nv;
    }
 
    // dois de baixo
    if (n > 3 && l1 < n - 1 && l2 < n - 1 && hamilton(n - 2, m, l1, c1, l2, c2)) {
        ans = solve(n - 2, m, l1, c1, l2, c2);
        pii pos = {l1, c1};
        bool ja = false;
        for (int i = 0; i < (int)ans.size(); i++) {
            if (ans[i] == 'R' && pos.first == n - 2 && !ja) {
                nv += 'D';
                nv += solve(2, m, 1, pos.second, 1, pos.second + 1);
                nv += 'U';
                ja = true;
                upd(&pos, ans[i]);
                continue;
            }
            if (ans[i] == 'L' && pos.first == n - 2 && !ja) {
                nv += 'D';
                nv += solve(2, m, 1, pos.second, 1, pos.second - 1);
                nv += 'U';
                ja = true;
                upd(&pos, ans[i]);
                continue;
            }
            nv += ans[i];
            upd(&pos, ans[i]);
        }
        return nv;
    }
 
    // dois da esquerda
    if (m > 3 && c1 > 2 && c2 > 2 && hamilton(n, m - 2, l1, c1 - 2, l2, c2 - 2)) {
        ans = solve(n, m - 2, l1, c1 - 2, l2, c2 - 2);
        pii pos = {l1, c1};
        bool ja = false;
        for (int i = 0; i < (int)ans.size(); i++) {
            if (ans[i] == 'U' && pos.second == 3 && !ja) {
                nv += 'L';
                nv += solve(n, 2, pos.first, 2, pos.first - 1, 2);
                nv += 'R';
                ja = true;
                upd(&pos, ans[i]);
                continue;
            }
            if (ans[i] == 'D' && pos.second == 3 && !ja) {
                nv += 'L';
                nv += solve(n, 2, pos.first, 2, pos.first + 1, 2);
                nv += 'R';
                ja = true;
                upd(&pos, ans[i]);
                continue;
            }
            nv += ans[i];
            upd(&pos, ans[i]);
        }
        return nv;
    }
 
    // dois da direita
    if (m > 3 && c1 < m - 1 && c2 < m - 1 && hamilton(n, m - 2, l1, c1, l2, c2)) {
        ans = solve(n, m - 2, l1, c1, l2, c2);
        pii pos = {l1, c1};
        bool ja = false;
        for (int i = 0; i < (int)ans.size(); i++) {
            if (ans[i] == 'U' && pos.second == m - 2 && !ja) {
                nv += 'R';
                nv += solve(n, 2, pos.first, 1, pos.first - 1, 1);
                nv += 'L';
                ja = true;
                upd(&pos, ans[i]);
                continue;
            }
            if (ans[i] == 'D' && pos.second == m - 2 && !ja) {
                nv += 'R';
                nv += solve(n, 2, pos.first, 1, pos.first + 1, 1);
                nv += 'L';
                ja = true;
                upd(&pos, ans[i]);
                continue;
            }
            nv += ans[i];
            upd(&pos, ans[i]);
        }
        return nv;
    }
 
    // SPLIT
    int p1 = (l1 + c1) % 2, p2 = (l2 + c2) % 2;
 
    // dois de cima
    if (n > 3 && min(l1, l2) <= 2 && max(l1, l2) > 2) {
        if (min(l1, l2) == l1) {
            for (int i = 1 + p1; i <= m; i += 2) {
                if (hamilton(2, m, l1, c1, 2, i) && hamilton(n - 2, m, 1, i, l2 - 2, c2)) {
                    return solve(2, m, l1, c1, 2, i) + 'D' + solve(n - 2, m, 1, i, l2 - 2, c2);
                }
            }
        }
        if (min(l1, l2) == l2) {
            for (int i = 1 + p2; i <= m; i += 2) {
                if (hamilton(n - 2, m, l1 - 2, c1, 1, i) && hamilton(2, m, 2, i, l2, c2)) {
                    return solve(n - 2, m, l1 - 2, c1, 1, i) + 'U' + solve(2, m, 2, i, l2, c2);
                }
            }
        }
    }
    // dois de baixo
    if (n > 3 && max(l1, l2) >= n - 1 && min(l1, l2) < n - 1) {
        if (max(l1, l2) == l1) {
            for (int i = 1 + p1; i <= m; i += 2) {
                if (hamilton(2, m, l1 - n + 2, c1, 1, i) && hamilton(n - 2, m, n - 2, i, l2, c2)) {
                    return solve(2, m, l1 - n + 2, c1, 1, i) + 'U' + solve(n - 2, m, n - 2, i, l2, c2);
                }
            }
        }
        if (max(l1, l2) == l2) {
            for (int i = 1 + p2; i <= m; i += 2) {
                if (hamilton(n - 2, m, l1, c1, n - 2, i) && hamilton(2, m, 1, i, l2 - n + 2, c2)) {
                    return solve(n - 2, m, l1, c1, n - 2, i) + 'D' + solve(2, m, 1, i, l2 - n + 2, c2);
                }
            }
        }
    }
    // dois da esquerda
    if (m > 3 && min(c1, c2) <= 2 && max(c1, c2) > 2) {
        if (min(c1, c2) == c1) {
            for (int i = 1 + p1; i <= n; i += 2) {
                if (hamilton(n, 2, l1, c1, i, 2) && hamilton(n, m - 2, i, 1, l2, c2 - 2)) {
                    return solve(n, 2, l1, c1, i, 2) + 'R' + solve(n, m - 2, i, 1, l2, c2 - 2);
                }
            }
        }
        if (min(c1, c2) == c2) {
            for (int i = 1 + p2; i <= n; i += 2) {
                if (hamilton(n, m - 2, l1, c1 - 2, i, 1) && hamilton(n, 2, i, 2, l2, c2)) {
                    return solve(n, m - 2, l1, c1 - 2, i, 1) + 'L' + solve(n, 2, i, 2, l2, c2);
                }
            }
        }
    }
    // dois da direita
    if (m > 3 && max(c1, c2) >= m - 1 && min(c1, c2) < m - 1) {
        if (min(c1, c2) == c1) {
            for (int i = 1 + p1; i <= n; i += 2) {
                if (hamilton(n, 2, l1, c1 - m + 2, i, 1) && hamilton(n, m - 2, i, m - 2, l2, c2)) {
                    return solve(n, 2, l1, c1 - m + 2, i, 1) + 'L' + solve(n, m - 2, i, m - 2, l2, c2);
				}
			}
		}
		if (min(c1, c2) == c2) {
			for (int i = 1 + p2; i <= n; i += 2) {
				if (hamilton(n, m - 2, l1, c1, i, m - 2) && hamilton(n, 2, i, 1, l2, c2 - m + 2)) {
					return solve(n, m - 2, l1, c1, i, m - 2) + 'R' + solve(n, 2, i, 1, l2, c2 - m + 2);
				}
			}
		}
	}
}
 
int main () {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int t;
	cin >> t;
	while (t--) {
		int n, m, l1, c1, l2, c2;
		cin >> n >> m >> l1 >> c1 >> l2 >> c2;
		if (hamilton(n, m, l1, c1, l2, c2)) {
			cout << "YES\n";
			cout << solve(n, m, l1, c1, l2, c2) << '\n';
		}
		else {
			cout << "NO\n";
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{Grid Paths}
\begin{lstlisting}
// Problem name: Grid Paths
// Problem Link: https://cses.fi/problemset/task/1078
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Consider an n x n grid whose top-left square is (1,1) and bottom-right square is (n,n).
// Your task is to move from the top-left square to the bottom-right square. 
//On each step you may move one square right or down. 
// In addition, there are m traps in the grid. You cannot move to a square with a trap.
// What is the total number of possible paths?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int fexp(ll b, int e) {
	ll resp = 1;
	while (e) {
		if (e&1) resp = (resp * b) % M;
		e = (e>>1);
		b = (b * b) % M;
	}
	return resp;
}
 
int main () { _
	int h, w, n;
	cin >> h >> n;
	w = h;
	vector<ll> inv(1000100, 1), fat(2000100, 1), dp(n);
	ll f;
	for (int i = 2; i < 2000050; i++) {
		f = fat[i-1]*i % M;
		fat[i] = f;
	}
	inv[1000050] = fexp(fat[1000050], M-2);
	for (int i = 1000049; i >= 0; i--) {
		inv[i] = (inv[i+1] * (i+1)) % M;
	}
	vector<pii> v(n);
	for (int i = 0; i < n; i++) cin >> v[i].F >> v[i].S;
	sort(v.begin(), v.end());
	for (int i = 0; i < n; i++) {
		dp[i] = fat[v[i].F + v[i].S - 2] * inv[v[i].F - 1] % M;
		dp[i] = dp[i] * inv[v[i].S - 1] % M;
		for (int j = i-1; j >= 0; j--) {
			if (v[j].F <= v[i].F && v[j].S <= v[i].S) {
				ll nova = dp[j] * fat[v[i].F - v[j].F + v[i].S - v[j].S] % M;
				nova = nova * inv[v[i].F - v[j].F] % M;
				nova = nova * inv[v[i].S - v[j].S] % M;
				dp[i] -= nova;	
				if (dp[i] < 0) dp[i] += M;
			}
		}
	}
	ll total = fat[h+w-2] * inv[h-1] % M;
	total = total * inv[w-1] % M;
	for (int i = 0; i < n; i++) {
		dp[i] = dp[i] * fat[h + w - v[i].F - v[i].S] % M;
		dp[i] = dp[i] * inv[h - v[i].F] % M;
		dp[i] = dp[i] * inv[w - v[i].S] % M;
		total -= dp[i];
		if (total < 0) total += M;
	}
	cout << total << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Grid Puzzle I}
\begin{lstlisting}
// Problem name: Grid Puzzle I
// Problem Link: https://cses.fi/problemset/task/2432
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There is an n x n grid, and your task is to choose from each row and column some number of squares. 
// How can you do that?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 4e5 + 5;
const ll INF = 2e18;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    priority_queue<pii> fila;
    pii aux;
    vector<int> linha(n);
    for (int i = 0; i < n; i++) {
        cin >> linha[i];
        aux.first = linha[i];
        aux.second = i;
        fila.push(aux);
    }
    vector<vector<char>> ans(n, vector<char> (n, '.'));
    int a;
    for (int i = 0; i < n; i++) {
        cin >> a;
        vector<pii> b;
        for (int j = 0; j < a; j++) {
            b.push_back(fila.top());
            fila.pop();
        } 
        for (auto x : b) {
            ans[x.second][i] = 'X';
            x.first--;
            fila.push(x);
        }
    }
    bool ok = true;
    for (int i = 0; i < n; i++) {
        int cnt = 0;
        for (int j = 0; j < n; j++) {
            cnt += ans[i][j] == 'X';
        }
        ok &= cnt == linha[i];
    }
    if (!ok) cout << "-1\n";
    else {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                cout << ans[i][j];
            }
            cout << '\n';
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{Grid Puzzle II}
\begin{lstlisting}
// Problem name: Grid Puzzle II
// Problem Link: https://cses.fi/problemset/task/2131
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There is an n x n grid whose each square has some number of coins in it.
// You know for each row and column how many squares you must choose from that row or column. 
// You get all coins from every square you choose. What is the maximum number of coins you can collect 
// and how could you choose the squares so that the given conditions are satisfied?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
// MinCostMaxFlow
//
// min_cost_flow(s, t, f) computa o par (fluxo, custo)
// com max(fluxo) <= f que tenha min(custo)
// min_cost_flow(s, t) -> Fluxo maximo de custo minimo de s pra t
// Se for um dag, da pra substituir o SPFA por uma DP pra nao
// para O(nm) no comeco
// Se nao tiver aresta com custo negativo, nao precisa do SPFA
//
// O(nm + f * m log n)
// 697b4c
 
template<typename T = int> struct mcmf {
	struct edge {
		int to, rev, flow, cap; // para, id da reversa, fluxo, capacidade
		bool res; // se eh reversa
		T cost; // custo da unidade de fluxo
		edge() : to(0), rev(0), flow(0), cap(0), cost(0), res(false) {}
		edge(int to_, int rev_, int flow_, int cap_, T cost_, bool res_)
			: to(to_), rev(rev_), flow(flow_), cap(cap_), res(res_), cost(cost_) {}
	};
 
	vector<vector<edge>> g;
	vector<int> par_idx, par;
	T inf;
	vector<T> dist;
 
	mcmf(int n) : g(n), par_idx(n), par(n), inf(numeric_limits<T>::max()/3) {}
 
	void add(int u, int v, int w, T cost) { // de u pra v com cap w e custo cost
		edge a = edge(v, g[v].size(), 0, w, cost, false);
		edge b = edge(u, g[u].size(), 0, 0, -cost, true);
 
		g[u].push_back(a);
		g[v].push_back(b);
	}
 
	vector<T> spfa(int s) { // nao precisa se nao tiver custo negativo
		deque<int> q;
		vector<bool> is_inside(g.size(), 0);
		dist = vector<T>(g.size(), inf);
 
		dist[s] = 0;
		q.push_back(s);
		is_inside[s] = true;
 
		while (!q.empty()) {
			int v = q.front();
			q.pop_front();
			is_inside[v] = false;
 
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
 
					if (is_inside[to]) continue;
					if (!q.empty() and dist[to] > dist[q.front()]) q.push_back(to);
					else q.push_front(to);
					is_inside[to] = true;
				}
			}
		}
		return dist;
	}
	bool dijkstra(int s, int t, vector<T>& pot) {
		priority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> q;
		dist = vector<T>(g.size(), inf);
		dist[s] = 0;
		q.emplace(0, s);
		while (q.size()) {
			auto [d, v] = q.top();
			q.pop();
			if (dist[v] < d) continue;
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				cost += pot[v] - pot[to];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
					q.emplace(dist[to], to);
					par_idx[to] = i, par[to] = v;
				}
			}
		}
		return dist[t] < inf;
	}
 
	pair<int, T> min_cost_flow(int s, int t, int flow) {
		vector<T> pot(g.size(), 0);
		pot = spfa(s); // mudar algoritmo de caminho minimo aqui
 
		int f = 0;
		T ret = 0;
		while (f < flow and dijkstra(s, t, pot)) {
			for (int i = 0; i < g.size(); i++)
				if (dist[i] < inf) pot[i] += dist[i];
 
			int mn_flow = flow - f, u = t;
			while (u != s){
				mn_flow = min(mn_flow,
					g[par[u]][par_idx[u]].cap - g[par[u]][par_idx[u]].flow);
				u = par[u];
			}
 
			ret += pot[t] * mn_flow;
 
			u = t;
			while (u != s) {
				g[par[u]][par_idx[u]].flow += mn_flow;
				g[u][g[par[u]][par_idx[u]].rev].flow -= mn_flow;
				u = par[u];
			}
 
			f += mn_flow;
		}
 
		return make_pair(f, ret);
	}
 
	// Opcional: retorna as arestas originais por onde passa flow = cap
	vector<pair<int,int>> recover() {
		vector<pair<int,int>> used;
		for (int i = 0; i < g.size(); i++) for (edge e : g[i])
			if(e.flow == e.cap && !e.res) used.push_back({i, e.to});
		return used;
	}
};
 
int resp[55][55];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, x;
    cin >> n;
    mcmf ber(2 * n + 2);
    int fluxo = 0;
    for (int i = 1; i <= n; i++) {
        cin >> x;
        fluxo += x;
        ber.add(0, i, x, 0);
    }
    for (int i = n + 1; i <= 2 * n; i++) {
        cin >> x;
        ber.add(i, 2*n + 1, x, 0);
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> x;
            ber.add(i + 1, n + j + 1, 1, -x);
        }
    }
    pii ans = ber.min_cost_flow(0, 2 * n + 1, ber.inf);
    if (ans.first < fluxo) cout << "-1\n";
    else {
        cout << -ans.second << '\n';
        vector<pii> ed = ber.recover();
        for (auto x : ed) {
            if (x.first != 0 && x.second != 2 * n + 1) 
                resp[x.first - 1][x.second - n - 1] = 1;
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                cout << (resp[i][j] ? 'X' : '.');
            }
            cout << '\n';
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{Increasing Array II}
\begin{lstlisting}
// Problem name: Increasing Array II
// Problem Link: https://cses.fi/problemset/task/2132
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an array of n integers. You want to modify the array so that it is increasing, 
// i.e., every element is at least as large as the previous element.
// On each move, you can increase or decrease the value of any element by one. 
// What is the minimum number of moves required?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
priority_queue<int> fila;
 
int main () { _
	int n, aux;
	cin >> n;
	ll ans = 0;
	for (int i = 0; i < n; i++) {
		cin >> aux;
		fila.push(aux);
		ans += fila.top() - aux;
		fila.pop();
		fila.push(aux);
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Increasing Subsequence II}
\begin{lstlisting}
// Problem name: Increasing Subsequence II
// Problem Link: https://cses.fi/problemset/task/1748
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

//Given an array of n integers, your task is to calculate the number of increasing subsequences it contains. 
// If two subsequences have the same values but in different positions in the array, they are counted separately.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
ll a[MAXN], dp[MAXN];
int v[MAXN];
 
void upd(int pos, ll val) { for (; pos < MAXN; pos += (pos & -pos)) a[pos] = (a[pos] + val) % M; }
 
ll sum(int pos) {
	ll ans = 1;
	for (; pos > 0; pos -= (pos & -pos)) {
		ans += a[pos];
		if (ans >= M) ans -= M;
	}
	return ans;
}
 
int main () { _
	int n;
	cin >> n;
	vector<int> w;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		w.pb(v[i]);
	}
	sort(w.begin(), w.end());
	w.erase(unique(w.begin(), w.end()), w.end());
	for (int i = 1; i <= n; i++) {
		v[i] = upper_bound(w.begin(), w.end(), v[i]) - w.begin();
	}
	for (int i = 1; i <= n; i++) {
		dp[i] += sum(v[i]-1);
		dp[i] %= M;
		upd(v[i], dp[i]);
	}
	cout << sum(MAXN-1) - 1 << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Intersection Points}
\begin{lstlisting}
// Problem name: Intersection Points
// Problem Link: https://cses.fi/problemset/task/1740
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given n horizontal and vertical line segments, your task is to calculate the number of their intersection points.
// You can assume that no parallel line segments intersect, and no endpoint of a line segment is an intersection point.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
struct line {
	int x1, x2, y1, y2, hor, take;
};
 
ll a[MAXN];
vector<line> l[MAXN];
 
void upd(int pos, int val) {for (; pos < MAXN; pos += (pos & -pos)) a[pos]+=val; }
 
ll sum(int pos) {
	ll ans = 0;
	for (; pos; pos -= (pos & -pos)) ans += a[pos];
	return ans;
}
 
int main () { _
	int n;
	cin >> n;
	line aux;
	for (int i = 0; i < n; i++) {
		cin >> aux.x1 >> aux.y1 >> aux.x2 >> aux.y2;
		aux.x1 += 1e6, aux.x2 += 1e6, aux.y1 += 1e6, aux.y2 += 1e6;
		aux.hor = (aux.y1 == aux.y2);
		aux.take = 1;
		l[aux.x1].pb(aux);
	}
	ll ans = 0;
	for (int i = 0; i <= 2e6; i++) {
		if (!l[i].empty()) {
			sort(l[i].begin(), l[i].end(), [&] (line a, line b) { return a.hor > b.hor; });
			for (line &x : l[i]) {
				if (x.hor) {
					upd(x.y1, x.take);
					if (x.take == 1) {
						x.take = -1;
						l[x.x2].pb(x);
					}
				}
				else ans += sum(x.y2) - sum(x.y1-1);
			}
		}
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Inverse Inversions}
\begin{lstlisting}
// Problem name: Inverse Inversions
// Problem Link: https://cses.fi/problemset/task/2214
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to create a permutation of numbers 1,2,...,n that has exactly k inversions.
// An inversion is a pair (a,b) where a<b and pa>pb where pi denotes the number at position i in the permutation.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    ll n, k;
    cin >> n >> k;
    vector<int> v;
    int at = n-1;
    while (k) {
        if (k - at >= 0) {
            k -= at;
            v.push_back(at);
        }
        at--;
    }
    int baixo = 1, cima = n, id = 0;
    vector<int> perm(n);
    for (int i = n-1; i >= 0; i--) {
        if (id < (int)v.size() && i == v[id]) {
            perm[i] = baixo;
            baixo++;
            id++;
        }
        else {
            perm[i] = cima;
            cima--;
        }
    }
    for (int x : perm) cout << x << ' ';
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Letter Pair Move Game}
\begin{lstlisting}
// Problem name: Letter Pair Move Game
// Problem Link: https://cses.fi/problemset/task/2427
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are 2n boxes in a line. Two adjacent boxes are empty, 
// and all other boxes have a letter "A" or "B". Both letters appear in exactly n−1 boxes.
// Your task is to move the letters so that all letters "A" appear before any letter "B". 
// On each turn you can choose any two adjacent boxes that have a letter 
// and move the letters to the two adjacent empty boxes, preserving their order.
// It can be proven that either there is a solution that consists of at most 10n turns 
// or there are no solutions.

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const int INF = 2e9;
 
int n;
map<vector<char>, pii> mp;
map<vector<char>, bool> vis;
 
bool ok(vector<char> v) {
    int ca = 0;
    bool ja = false;
    for (int i = 0; i < 2 * n; i++) {
        if (v[i] == 'A' && !ja) ca++;
        if (v[i] == 'B') ja = true;
    }
    return ca == n - 1;
}
 
int findPre(vector<char> v) {
    int ca = 0;
    bool ja = false;
    for (int i = 0; i < 2 * n; i++) {
        if (v[i] == 'A' && !ja) ca++;
        if (v[i] == 'B') ja = true;
    }
    return ca;
}
 
int findPos(vector<char> v) {
    int pos;
    for (int i = 0; i < 2 * n - 1; i++) {
        if (v[i] == '.') {
            pos = i;
            break;
        }
    }
    return pos;
}
 
void change(int a, int b, vector<char> &v) {
    swap(v[a], v[b]);
    swap(v[a + 1], v[b + 1]);
}
 
int main () {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n;
    vector<char> v(2 * n);
    for (char &x : v) cin >> x;
    vector<vector<char>> ans;
    if (n < 3) {
        if (ok(v)) cout << "0\n";
        else cout << "-1\n";
    }
    else if (n == 3) {
        queue<vector<char>> fila;
        fila.push(v);
        vector<char> at;
        bool find = false;
        while (!fila.empty()) {
            at = fila.front();
            fila.pop();
            if (ok(at)) {
                find = true;
                break;
            }
            int pos = findPos(at);
            for (int i = 0; i < 2 * n - 1; i++) {
                if (at[i] != '.' && at[i + 1] != '.') {
                    change(i, pos, at);
                    if (!vis[at]) {
                        vis[at] = 1;
                        mp[at] = {i, pos};
                        fila.push(at);
                    }
                    change(i, pos, at);
                }
            }
        }
        if (!find) cout << "-1\n";
        else {
            while (at != v) {
                pii ch = mp[at];
                ans.push_back(at);
                change(ch.first, ch.second, at);
            }
            reverse(ans.begin(), ans.end());
            cout << ans.size() << '\n';
            for (auto y : ans) {
                for (auto x : y) cout << x;
                cout << '\n';
            }
        }
    }
    else {
 
        // primeiro colocar espaco no final
        int pos = findPos(v), pre;
        if (pos == 2 * n - 3) {
            change(0, pos, v);
            ans.push_back(v);
            change(0, pos + 1, v);
            ans.push_back(v);
        }
        else if (pos < 2 * n - 3) {
            change(pos, 2 * n - 2, v);
            ans.push_back(v);
        }
        while (!ok(v)) {
            pre = findPre(v);
            if (pre == n - 2 && v[n - 1] == 'A') {
                // AA ... AABABB ... BB..
                change(n - 1, 2 * n - 2, v);
                ans.push_back(v);
                change(2 * n - 3, n - 1, v);
                ans.push_back(v);
                change(n - 2, 2 * n - 3, v);
                ans.push_back(v);
            }
            else if (pre == n - 3 && v[n - 2] == 'A' && v[2 * n - 3] == 'A') {
                // AA ... AABABB ... BA..
                change(n - 2, 2 * n - 2, v);
                ans.push_back(v);
                change(2 * n - 4, n - 2, v);
                ans.push_back(v);
                change(n - 3, 2 * n - 4, v);
                ans.push_back(v);
                change(2 * n - 2, n - 3, v);
                ans.push_back(v);
            }
            else {
                change(pre, 2 * n - 2, v);
                ans.push_back(v);
                int mudei;
                for (int i = pre + 2; i < 2 * n - 1; i++) {
                    if (v[i] == 'A') {
                        change(i, pre, v);
                        ans.push_back(v);
                        mudei = i;
                        break;
                    }
                }
                if (ok(v)) break;
                change(2 * n - 2, mudei, v);
                ans.push_back(v);
            }
        }
        cout << ans.size() << '\n';
        for (auto y : ans) {
            for (auto x : y) cout << x;
            cout << '\n';
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{List of Sums}
\begin{lstlisting}
// Problem name: List of Sums
// Problem Link: https://cses.fi/problemset/task/2414
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// List A consists of n positive integers, and list B contains the sum of each element pair of list A.
// For example, if A=[1,2,3], then B=[3,4,5], and if A=[1,3,3,3], then B=[4,4,4,6,6,6].
// Given list B, your task is to reconstruct list A.


#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 10;
const ll INF = 2e18;
 
vector<int> v;
int n;
 
bool check(int a0) {
    multiset<int> st;
    for (int x : v) st.insert(x);
    vector<int> ans(1, a0);
    for (int i = 1; i < n; i++) {
        int bg = *st.begin();
        ans.push_back(bg - a0);
        st.erase(st.begin());
        for (int j = 1; j < (int)ans.size() - 1; j++) {
            if (st.find(ans.back() + ans[j]) == st.end())
                return false;
            else st.erase(st.find(ans.back() + ans[j]));
        }
    }
    for (int x : ans) cout << x << ' ';
    cout << '\n';
    return true;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n;
    int tam = n * (n - 1) / 2;
    v.resize(tam);
    for (int &x : v) cin >> x;
    sort(v.begin(), v.end());
    for (int i = 2; i < tam; i++) {
        // brute a1 + a2 = v[i]
        int a2 = (v[1] - v[0] + v[i]) / 2;
        int a1 = v[i] - a2, a0 = v[0] - a1;
        if (check(a0)) return 0;
    }
    return 0;
}
\end{lstlisting}

\subsection{Maximum Building I}
\begin{lstlisting}
// Problem name: Maximum Building I
// Problem Link: https://cses.fi/problemset/task/1147
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a map of a forest where some squares are empty and some squares have trees.
// What is the maximum area of a rectangular building that can be placed in the forest so that no trees must be cut down?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
char mat[1010][1010];
int maxi[1010][1010];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	memset(maxi, -1, sizeof(maxi));
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> mat[i][j];
			maxi[i][j] = (mat[i][j] == '.');
			if (maxi[i][j] && i > 1) maxi[i][j] += maxi[i-1][j];
		}
	}
	//for (int i = n; i > 1; i--) {
	//	for (int j = 1; j <= m; j++) {
	//		if (maxi[i-1][j]) maxi[i-1][j] = max(maxi[i][j], maxi[i-1][j]);
	//	}
	//}
	ll ans = 0;
	vector<int> besq(m+1), bdir(m+1);
	for (int i = 1; i <= m; i++) {
		besq[i] = i-1;
		bdir[i] = i+1;
	}
	for (int i = 1; i <= n; i++) {
		vector<int> esq, dir;
		esq = besq, dir = bdir;
		for (int j = 1; j <= m; j++) {
			while (maxi[i][esq[j]] >= maxi[i][j]) {
				esq[j] = esq[esq[j]];
			}
		}
		for (int j = m; j >= 1; j--) {
			while (maxi[i][dir[j]] >= maxi[i][j]) {
				dir[j] = dir[dir[j]];
			}
		}
		for (int j = 1; j <= m; j++) {
			ans = max(ans, 1ll * (dir[j] - esq[j] - 1) * maxi[i][j]);
		}
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Maximum Building II}
\begin{lstlisting}
// Problem name: Maximum Building II
// Problem Link: https://cses.fi/problemset/task/1148
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a map of a forest where some squares are empty and some squares have trees.
// You want to place a rectangular building in the forest so that no trees need to be cut down. 
// For each building size, your task is to calculate the number of ways you can do this.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e3 + 5;
const ll INF = 2e18;
 
int mat[MAXN][MAXN], v[MAXN][MAXN], w[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
    cin >> n >> m;
    char c;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> c;
            if (c == '*') v[i][j] = 0;
            else v[i][j] = 1;
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (v[i][j]) w[j]++;
            else w[j] = 0;
        }
        vector<pii> sk;
        if (w[1]) 
            sk.emplace_back(w[1], 1);
        for (int j = 2; j <= m + 1; j++) {
            int st = 1;
            while (!sk.empty() && sk.back().first > w[j]) {
                int alt = sk.back().first, tam = sk.back().second;
                mat[alt][tam]++;
                sk.pop_back();
                if (!sk.empty() && sk.back().first > w[j]) {
                    mat[sk.back().first][tam]--;
                    sk.back().second += tam;
                }
                else {
                    st += tam;
                    mat[w[j]][tam]--;
                }
            }
            if (!sk.empty() && sk.back().first == w[j]) {
                sk.back().second += st;
            }
            else if (w[j]) {
                sk.emplace_back(w[j], st);
            }
        }
    }
    for (int j = 1; j <= m; j++) {
        for (int i = n - 1; i >= 1; i--) mat[i][j] += mat[i + 1][j];
    }
    for (int go = 0; go < 2; go++) {
        for (int i = 1; i <= n; i++) {
            for (int j = m - 1; j >= 1; j--) mat[i][j] += mat[i][j + 1];
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) cout << mat[i][j] << ' ';
        cout << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{Maximum Xor Subarray}
\begin{lstlisting}
// Problem name: Maximum Xor Subarray
// Problem Link: https://cses.fi/problemset/task/1655
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given an array of n integers, your task is to find the maximum xor sum in a subarray.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int trie[6000100][2], quant[6000100], cnt = 0;
 
void insert(int x) {
	int no = 0;
	for (int i = 30; i >= 0; i--) {
		quant[no]++;
		if (quant[no] == 1) {
			trie[no][0] = ++cnt;
			trie[no][1] = ++cnt;
		}
		no = trie[no][(x & (1<<i) ? 1 : 0)];
	}
	quant[no]++;
}
 
int query(int x) {
	int no = 0, resp = 0;
	for (int i = 30; i >= 0; i--) {
		if (quant[trie[no][(x & (1<<i) ? 0 : 1)]]) {
			resp += (x & (1<<i) ? 0 : 1) * (1<<i);
			no = trie[no][(x & (1<<i) ? 0 : 1)];
		}
		else {
			resp += (x & (1<<i) ? 1 : 0) * (1<<i);
			no = trie[no][(x & (1<<i) ? 1 : 0)];
		}
	}
	return resp;
}
 
int main () { _
	int n;
	cin >> n;
	int ans = 0, atual = 0, aux;
	insert(0);
	for (int i = 0; i < n; i++) {
		cin >> aux;
		atual ^= aux;
		ans = max(ans, query(atual) ^ atual);
		insert(atual);
	}	
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Missing Coin Sum Queries}
\begin{lstlisting}
// Problem name: Missing Coin Sum Queries
// Problem Link: https://cses.fi/problemset/task/2184
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You have n coins with positive integer values. The coins are numbered 1,2,...,n.
// Your task is to process q queries of the form: "if you can use coins a…b, what is the smallest sum you cannot produce?"

#include <bits/stdc++.h>
using namespace std; 
 
#define ll long long
#define FOR(i, x, y) for (int i = x; i < y; i++)
#define arr array<int, 30>
 
const int mx = 2e5 + 5;
 
int n, q, A[mx]; ll sm[mx][30]; arr seg[mx * 2];
 
arr comb(arr &A, arr &B){
	arr ret;
    FOR(i, 0, 30) ret[i] = min(A[i], B[i]);
    return ret;
}
arr qry(int l, int r){
    arr ret; fill(ret.begin(), ret.end(), 2e9);
    for (l += mx, r += mx; l <= r; r /= 2, l /= 2){
        if (l % 2 == 1) ret = comb(ret, seg[l++]);
        if (r % 2 == 0) ret = comb(seg[r--], ret);
    }
    return ret;
}
 
int main(){
	ios_base::sync_with_stdio(0); cin.tie(0);
    cin >> n >> q; memset(seg, 0x3f, sizeof(seg));
    FOR(i, 1, n + 1){
        int x; cin >> x;
        int g = log2(x);
        seg[i + mx][g] = x; sm[i][g] = x;
    }
    FOR(i, 1, n + 1) FOR(j, 0, 30) sm[i][j] += sm[i - 1][j];
    
    for (int i = mx - 1; i; i--) seg[i] = comb(seg[i * 2], seg[i * 2 + 1]);
    
    while (q--){
        int l, r; cin >> l >> r;
 
        arr bst = qry(l, r); ll tot = 0, ans = -1;
        FOR(i, 0, 30){
            if (tot + 1 < (1 << (i + 1)) and bst[i] > tot + 1){ 
                ans = tot + 1;
                break;
            }
            tot += sm[r][i] - sm[l - 1][i];
        }
        cout<<(ans == -1 ? tot + 1 : ans)<<"\n";
    }
}
\end{lstlisting}

\subsection{Monotone Subsequences}
\begin{lstlisting}
// Problem name: Monotone Subsequences
// Problem Link: https://cses.fi/problemset/task/2215
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to create a permutation of numbers 1,2,…,n whose longest monotone subsequence has exactly k elements.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 4e5 + 5;
const ll INF = 2e18;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        if (k < ceil(sqrt(n))) {
            cout << "IMPOSSIBLE\n";
        }
        else {
            vector<int> ans(n);
            int a = ceil(sqrt(n));
            for (int i = k; i > 0; i--) cout << i << ' ';
            int temos = n - k, grupos = a - 1;
            if (grupos == 0) {
                cout << '\n';
                continue;
            }
            for (int i = 0; i < temos % grupos; i++) {
                for (int j = 0; j < temos / grupos + 1; j++) {
                    cout << k + (temos / grupos + 1) * (i + 1) - j << ' ';
                }
            }
            int lst = k + (temos / grupos + 1) * (temos % grupos);
            for (int i = 0; i < grupos - temos % grupos; i++) {
                for (int j = 0; j < temos / grupos; j++) {
                    cout << lst + (temos / grupos) * (i + 1) - j << ' ';
                }
            }
            cout << '\n';
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{Movie Festival Queries}
\begin{lstlisting}
// Problem name: Movie Festival Queries
// Problem Link: https://cses.fi/problemset/task/1664
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// In a movie festival, n movies will be shown. You know the starting and ending time of each movie.
// Your task is to process q queries of the form: if you arrive and leave the festival at specific times, 
// what is the maximum number of movies you can watch?
// You can watch two movies if the first movie ends before or exactly when the second movie starts. 
// You can start the first movie exactly when you arrive and leave exactly when the last movie ends.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
int st[(int) 1e6 + 5], to[20][MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, q;
    cin >> n >> q;
    vector<pii> v(n + 1);
    for (int i = 0; i < n; i++) {
        cin >> v[i].second >> v[i].first;
    }
    v[n] = {1e6 + 1, 1e6 + 1};
    sort(v.begin(), v.end());
    int at = 0;
    for (int i = 0; i <= n; i++) {
        if (v[i].second >= at) {
            for (int j = at; j <= v[i].second; j++) st[j] = i;
            at = v[i].second + 1;
        }
    }
    for (int i = 0; i <= n; i++) {
        to[0][i] = st[v[i].first];
    }
    for (int i = 1; i < 20; i++) {
        for (int j = 0; j <= n; j++) to[i][j] = to[i - 1][to[i - 1][j]];
    }
    int a, b;
    for (int i = 0; i < q; i++) {
        cin >> a >> b;
        at = st[a];
        int ans = (v[at].first <= b);
        for (int j = 19; j >= 0; j--) {
            if (v[to[j][at]].first <= b) {
                ans += (1 << j);
                at = to[j][at];
            }
        }
        
        cout << ans << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{Multiplication Table}
\begin{lstlisting}
// Problem name: Multiplication Table
// Problem Link: https://cses.fi/problemset/task/2422
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	ll n;
	cin >> n;
	ll l = 0, r = n * n;
	while (r > l + 1) {
		ll m = (r + l) / 2;
		ll sum = 0;
		for (int i = 1; i <= n; i++) {
			sum += min(m/i, n);
		}
		if (sum >= (n * n) / 2 + 1) r = m;
		else l = m;
	}
	cout << r << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Network Breakdown}
\begin{lstlisting}
// Problem name: Network Breakdown
// Problem Link: https://cses.fi/problemset/task/1677
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
vector<int> v[MAXN];
int pai[MAXN], peso[MAXN], vis[MAXN];
set<pii> inv;
vector<pii> edg;
 
int find(int x) {
	if (pai[x] == x) return x;
	else return pai[x] = find(pai[x]);
}
 
void join(int a, int b) {
	a = find(a), b = find(b);
	if (a == b) return;
	if (peso[a] > peso[b]) 
		pai[b] = a;
	else if (peso[b] > peso[a])
		pai[a] = b;
	else {
		peso[a]++;
		pai[b] = a;
	}
}
 
void dfs(int node, int pai) {
	vis[node] = 1;
	for (int x : v[node]) {
		if (!inv.count({x, node}) && !inv.count({node, x}) && !vis[x]) {
			dfs(x, node);
			join(node, x);
		}
	}
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m, k;
	cin >> n >> m >> k;
	for (int i = 1; i <= n; i++) pai[i] = i; 
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	for (int i = 0; i < k; i++) {
		int a, b;
		cin >> a >> b;
		inv.insert({a, b});
		edg.emplace_back(a, b);
	}
	vector<int> resp;
	int comps = 0;
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			dfs(i, 0);
			comps++;
		}
	}
	resp.push_back(comps);
	for (int i = (int)edg.size()-1; i > 0; i--) {
		if (find(edg[i].first) != find(edg[i].second)) {
			comps--;
			join(edg[i].first, edg[i].second);
		}
		resp.push_back(comps);
	}
	reverse(resp.begin(), resp.end());
	for (int x : resp) cout << x << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Network Renovation}
\begin{lstlisting}
// Problem name: Network Renovation
// Problem Link: https://cses.fi/problemset/task/1704
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Syrjala's network consists of n computers and n - 1 connections between them. 
// It is possible to send data between any two computers.
// However, if any connection breaks down, it will no longer be possible to send data between some computers. 
// Your task is to add the minimum number of new connections in such a way that 
// you can still send data between any two computers even if any single connection breaks down.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
vector<int> v[MAXN], fol;
 
void dfs(int node, int pai) {
	for (int x : v[node]) {
		if (x != pai) dfs(x, node);
	}
	if ((int)v[node].size() == 1) fol.push_back(node);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n;
	cin >> n;
	for (int i = 0; i < n-1; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	dfs(1, 0);
	// cnt eh o numero de filhos da raiz
	int tam = (int)fol.size();
	if (tam&1) fol.push_back(fol[0]), tam++;
	cout << tam/2 << '\n';
	for (int i = 0; i < tam/2; i++) {
		cout << fol[i] << ' ' << fol[i+tam/2] << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{New Flight Routes}
\begin{lstlisting}
// Problem name: New Flight Routes
// Problem Link: https://cses.fi/problemset/task/1685
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n cities and m flight connections between them. 
// Your task is to add new flights so that it will be possible to travel from any city to any other city.
// What is the minimum number of new flights required?
// Print any optimal solution (hard part)

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
int rep[MAXN], vis[MAXN], cmp[MAXN], cnt;
vector<int> v[MAXN], w[MAXN], nv[MAXN], nw[MAXN], src, snk, ord;
 
void dfs1(int node) {
    vis[node] = 1;
    for (int x : v[node]) {
        if (!vis[x]) dfs1(x);
    }
    ord.push_back(node);
}
 
void dfs2(int node) {
    vis[node] = 1;
    cmp[node] = cnt;
    rep[cnt] = node;
    for (int x : w[node]) {
        if (!vis[x]) dfs2(x);
    }
}
 
void dfs3(int node) {
    vis[node] = 1;
    if (nv[node].empty()) snk.push_back(node);
    if (nw[node].empty()) src.push_back(node);
    for (int x : nv[node]) {
        if (!vis[x]) dfs3(x);
    }
    for (int x : nw[node]) {
        if (!vis[x]) dfs3(x);
    }
}
 
int dfs4(int node) {
    int ans = -1;
    vis[node] = 1;
    if (nv[node].empty()) return node;
    for (int x : nv[node]) {
        if (!vis[x]) {
            ans = dfs4(x);
            if (ans != -1) return ans;
        }
    }
    return ans;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, a, b;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        v[a].push_back(b);
        w[b].push_back(a);
    }
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) dfs1(i);
    }
    memset(vis, 0, sizeof(vis));
    reverse(ord.begin(), ord.end());
    for (int x : ord) {
        if (!vis[x]) {
            dfs2(x);
            cnt++;
        }
    }
    if (cnt == 1) {
        cout << "0\n";
        return 0;
    }
    for (int i = 1; i <= n; i++) {
        for (int x : v[i]) {
            if (cmp[i] != cmp[x]) {
                nv[cmp[i]].push_back(cmp[x]);
                nw[cmp[x]].push_back(cmp[i]);
            }
        }
    }
    memset(vis, 0, sizeof(vis));
    for (int i = 0; i < cnt; i++) {
        if (!vis[i]) {
            dfs3(i);
        }
    }
    memset(vis, 0, sizeof(vis));
    vector<pii> par, ans;
    set<int> source, sink;
    for (int x : src) source.insert(x);
    for (int x : snk) sink.insert(x);
    for (int x : src) {
        int match = dfs4(x);
        if (match != -1) {
            par.emplace_back(match, x);
            sink.erase(match);
            source.erase(x);
        }
    }
    int at = par.size();
    for (int i = 0; i < at; i++) ans.emplace_back(rep[par[i].first], rep[par[(i + 1) % at].second]);
    while (!source.empty() && !sink.empty()) {
        a = *sink.begin(), b = *source.begin();
        sink.erase(a), source.erase(b);
        ans.emplace_back(rep[a], rep[b]);
    }
    while (!source.empty()) {
        a = *source.begin();
        source.erase(a);
        ans.emplace_back(ans[0].first, rep[a]);
    }
    while (!sink.empty()) {
        a = *sink.begin();
        sink.erase(a);
        ans.emplace_back(rep[a], ans[0].second);
    }
    cout << ans.size() << '\n';
    for (auto x : ans) cout << x.first << ' ' << x.second << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Number Grid}
\begin{lstlisting}
// Problem name: Number Grid
// Problem Link: https://cses.fi/problemset/task/1157
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Consider a two-dimensional grid whose rows and columns are 1-indexed. 
// Each square contains the smallest nonnegative integer 
// that does not appear to the left on the same row or above on the same column.
// Your task is to calculate the value at square (y,x).
// reduz pra nim com duas pilhas

#include <bits/stdc++.h>
 
int main() {
    int x, y;
    scanf("%d %d", &x, &y);
    printf("%d", (x-1) ^ (y-1));
    return 0;
}
\end{lstlisting}

\subsection{Permutation Inversions}
\begin{lstlisting}
// Problem name: Permutation Inversions
// Problem Link: https://cses.fi/problemset/task/2229
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to count the number of permutations of 1,2 ...,n that have exactly k inversions 
// (i.e., pairs of elements in the wrong order).
// For example, when n=4 and k=3, there are 6 such permutations

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
int dp[126000], pre[126000];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, k;
    cin >> n >> k;
    dp[0] = 1;
    pre[0] = pre[1] = 1;
    for (int i = 2; i <= n; i++) {
        int lim = (i * (i-1)) / 2;
        for (int j = 0; j <= lim; j++) {
            dp[j] = pre[j] - (j-i >= 0 ? pre[j-i] : 0);
            if (dp[j] < 0) dp[j] += MOD;
            if (dp[j] >= MOD) dp[j] -= MOD;
        }
        lim = (i * (i+1)) / 2;
        for (int j = 0; j <= lim; j++) {
            pre[j] = dp[j] + (!j ? 0 : pre[j-1]);
            if (pre[j] >= MOD) pre[j] -= MOD;
        }
    }
    cout << dp[k] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Permutations II}
\begin{lstlisting}
// Problem name: Permutations II
// Problem Link: https://cses.fi/problemset/task/1075
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A permutation of integers 1,2,...,n is called beautiful if there are no adjacent elements whose difference is 1.
// Given n, your task is to count the number of beautiful permutations.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 4e5 + 5;
const ll INF = 2e18;

int dp[1005][1005][2];
 
void add(int &a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
}
 
int mul(int a, int b) {
    return (1ll * a * b) % MOD;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    dp[1][0][0] = 1;
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            add(dp[i + 1][j + 1][1], mul(2, dp[i][j][0]));
            if (j)
                add(dp[i + 1][j - 1][0], mul(j, dp[i][j][0]));
            add(dp[i + 1][j][0], mul(i - j - 1, dp[i][j][0]));
            add(dp[i + 1][j + 1][1], dp[i][j][1]);
            if (j)
                add(dp[i + 1][j - 1][0], mul(j - 1, dp[i][j][1]));
            add(dp[i + 1][j][0], mul(i - j, dp[i][j][1]));
            add(dp[i + 1][j][1], dp[i][j][1]);
        }
    }
    cout << dp[n][0][0] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Programmers and Artists}
\begin{lstlisting}
// Problem name: Programmers and Artists
// Problem Link: https://cses.fi/problemset/task/2426
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A company wants to hire a programmers and b artists.
// There are a total of n applicants, and each applicant can become either a programmer or an artist. 
// You know each applicant's programming and artistic skills.
// Your task is to select the new employees so that the sum of their skills is maximum.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 10;
const ll INF = 2e18;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int p, a, n;
    cin >> p >> a >> n;
    vector<pii> v(n);
    for (auto &x : v) cin >> x.first >> x.second;
    sort(v.rbegin(), v.rend());
    if (!p) {
        priority_queue<int> fila;
        for (auto x : v) fila.push(x.second);
        ll ans = 0;
        for (int i = 0; i < a; i++) {
            ans += fila.top();
            fila.pop();
        }
        cout << ans << '\n';
        return 0;
    }
    vector<ll> pre(n + 1), suf(n + 1);
    
    // pegar 0 dos p primeiros, 1 dos p + 1...
    priority_queue<ll> fila;
    ll tot = 0;
    for (int i = 0; i < p; i++) {
        tot += v[i].first;
        fila.push(v[i].second - v[i].first);
        pre[i] = tot;
    } 
    for (int i = p; i < p + a; i++) {
        ll mx = fila.top();
        fila.pop();
        tot += mx + v[i].first;
        pre[i] = tot;
        fila.push(v[i].second - v[i].first);
    }
 
    while (!fila.empty()) fila.pop();
    for (int i = n - 1; i >= p + a; i--) {
        fila.push(v[i].second);
    }
    tot = 0;
    for (int i = p + a - 1; i >= p; i--) {
        fila.push(v[i].second);
        ll mx = fila.top();
        fila.pop();
        tot += mx;
        suf[i] = tot;
    }
    ll ans = 0;
    for (int i = max(0, p - 1); i < p + a; i++) {
        ans = max(ans, pre[i] + suf[i + 1]);
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Prufer Code}
\begin{lstlisting}
// Problem name: Prufer Code
// Problem Link: https://cses.fi/problemset/task/1134
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A Prüfer code of a tree of n nodes is a sequence of n - 2 integers that uniquely specifies the structure of the tree.
// The code is constructed as follows: As long as there are at least three nodes left, find a leaf with the smallest label, 
// add the label of its only neighbor to the code, and remove the leaf from the tree.
// Given a Prüfer code of a tree, your task is to construct the original tree.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int c[MAXN], v[MAXN];
 
int main () { _
	int n;
	cin >> n;
	for (int i = 0; i < n-2; i++) {
		cin >> v[i];
		c[v[i]]++;
	}
	priority_queue<int, vector<int>, greater<int>> fila;
	for (int i = 1; i <= n; i++) {
		if (!c[i]) fila.push(i);
	}
	for (int i = 0; i < n-2; i++) {
		cout << fila.top() << ' ' << v[i] << '\n';
		fila.pop();
		c[v[i]]--;
		if (!c[v[i]]) fila.push(v[i]);
	}
	cout << fila.top() << ' ';
	fila.pop();
	cout << fila.top() << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Pyramid Array}
\begin{lstlisting}
// Problem name: Pyramid Array
// Problem Link: https://cses.fi/problemset/task/1747
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an array consisting of n distinct integers. 
// On each move, you can swap any two adjacent values.
// You want to transform the array into a pyramid array. 
//This means that the final array has to be first increasing and then decreasing. 
// It is also allowed that the final array is only increasing or decreasing.
// What is the minimum number of moves needed?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
int a[MAXN];
 
void add(int pos, int val) {
    for (; pos < MAXN; pos += (pos & -pos)) a[pos] += val;
}
 
int sum(int pos) {
    int ans = 0;
    for (; pos; pos -= (pos & -pos)) ans += a[pos];
    return ans;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    vector<pii> v(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i].first;
        v[i].second = i + 1;
        add(i + 1, 1);
    }
    sort(v.begin(), v.end());
    ll ans = 0;
    for (int i = 0; i < n; i++) {
        ans += min(sum(n) - sum(v[i].second), sum(v[i].second - 1));
        add(v[i].second, -1);
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Removing Digits II}
\begin{lstlisting}
// Problem name: Removing Digits II
// Problem Link: https://cses.fi/problemset/task/2174
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an integer n. On each step, you may substract from it any one-digit number that appears in it.
// How many steps are required to make the number equal to 0?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
// Quantidade de 9s, Maior digito do prefixo, Ultimo digito
ll dp[20][10][10];
int to[20][10][10];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
 
	// precalc
	for (int j = 0; j < 10; j++) {
		for (int k = 0; k < 10; k++) {
			if (j > k) {
				dp[0][j][k] = 1;
				to[0][j][k] = 10 + k - j; 
			}
			else {
				dp[0][j][k] = 2;
				to[0][j][k] = 10 - j;
			}
		}
	}
    for (int i = 1; i <= 17; i++) {
		for (int j = 0; j < 10; j++) {
			for (int k = 0; k < 10; k++) {
				int lst = k;
				for (int l = 9; l >= 0; l--) {
					dp[i][j][k] += dp[i - 1][max(j, l)][lst];
					lst = to[i - 1][max(j, l)][lst];
				}
				to[i][j][k] = lst;
			}
		}
	}
	
	ll n, ans = 0;
	cin >> n;
	int lst = n % 10, cnt = 0;
	n /= 10;
	while (n % 10 == 9) {
		cnt++;
		n /= 10;
	}
	while (n > 0 || lst > 0 || cnt > 0) {
		int dig = 0;
		ll pre = n;
		while (pre > 0) {
			dig = max(dig, (int)(pre % 10));
			pre /= 10;
		}
		ans += dp[cnt][dig][lst];
		lst = to[cnt][dig][lst];
		if (n == 0) break;
		n--;
		while (n % 10 == 9) {
			cnt++;
			n /= 10;
		}
	}
	cout << ans - 1 << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Reversal Sorting}
\begin{lstlisting}
// Problem name: Reversal Sorting
// Problem Link: https://cses.fi/problemset/task/2075
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You have an array that contains a permutation of integers 1,2,…,n. 
// Your task is to sort the array in increasing order by reversing subarrays. 
// You can construct any solution that has at most n reversals.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
struct node {
    node *L, *R;
    int prio, sz, val, mn;
    bool rev;
    node (int _val = MAXN) {
        L = 0, R = 0, prio = rng(), sz = 1, val = mn = _val, rev = false;
    }
};
 
int size(node *treap) {
    if (!treap) return 0;
    return treap->sz;
}
 
int mini(node *treap) {
    if (!treap) return MAXN;
    return treap->mn;
}
 
void push(node *treap) {
    if (treap && treap->rev) {
        treap->rev = false;
        swap(treap->L, treap->R);
        if (treap->L) treap->L->rev ^= true;
        if (treap->R) treap->R->rev ^= true;
    }
}
 
void recalc(node *&treap) {
    if (!treap) return;
    treap->sz = size(treap->L) + size(treap->R) + 1;
    treap->mn = min({treap->val, mini(treap->L), mini(treap->R)});
}
 
void split(node *treap, node *&L, node *&R, int k) {
    if (!treap) {
        L = R = 0;
    }
    else {
        push(treap);
        if (size(treap->L) >= k) {
            split(treap->L, L, treap->L, k);
            R = treap;
        }
        else {
            split(treap->R, treap->R, R, k - size(treap->L) - 1);
            L = treap;
        }
        recalc(treap);
    }
}
 
void merge(node *&treap, node *L, node *R) {
    if (!L) treap = R;
    else if (!R) treap = L;
    else {
        push(L), push(R);
        if (L->prio > R->prio) {
            merge(L->R, L->R, R);
            treap = L;
        }
        else {
            merge(R->L, L, R->L);
            treap = R;
        }
        recalc(treap);
    }
}
 
int query(node *treap) {
    push(treap);
    int a = mini(treap->L), b = treap->val, c = mini(treap->R), d = min({a, b, c});
    if (a == d) return query(treap->L);
    else if (b == d) return size(treap->L) + 1;
    else return size(treap->L) + 1 + query(treap->R);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, x;
    cin >> n;
    node *root = 0;
    for (int i = 1; i <= n; i++) {
        cin >> x;
        merge(root, root, new node(x));
    }
    cout << n << endl;
    for (int i = 1; i <= n; i++) {
        //put i in its place
        
        node *a, *b, *c;
        split(root, a, b, i - 1);
        int pos = query(b);
        split(b, b, c, pos);
        b->rev ^= true;
        merge(b, b, c);
        merge(root, a, b);
        cout << i << ' ' << pos + i - 1 << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{Robot Path}
\begin{lstlisting}
// Problem name: Robot Path
// Problem Link: https://cses.fi/problemset/task/1742
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a description of a robot's path. 
// The robot begins at point (0,0) and performs n commands. 
// Each command moves the robot some distance up, down, left or right.
// The robot will stop when it has performed all commands, 
// or immediately when it returns to a point that it has already visited. 
// Your task is to calculate the total distance the robot moves.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
struct line {
	int x1, x2, y1, y2, take;
    line(int _x1 = 0, int _y1 = 0, int _x2 = 0, int _y2 = 0, int _take = 0) {
        x1 = _x1, y1 = _y1, x2 = _x2, y2 = _y2, take = _take;
    }
};
 
ll bit[MAXN];
 
void upd(int pos, int val) {pos += 2; for (; pos < MAXN; pos += (pos & -pos)) bit[pos] += val; }
 
ll sum(int pos) {
    pos += 2;
	ll ans = 0;
	for (; pos; pos -= (pos & -pos)) ans += bit[pos];
	return ans;
}
 
vector<line> hor[MAXN], vert[MAXN], chor[MAXN];
 
bool opp(char a, char b) {
    return (a == 'L' && b == 'R') || (a == 'R' && b == 'L') || (a == 'U' && b == 'D') || (a == 'D' && b == 'U');
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    vector<pair<char, ll>> v;
    pair<char, ll> aux;
    ll l = 0, r = 0;
    bool stop = false;
    for (int i = 0; i < n; i++) {
        cin >> aux.first >> aux.second;
        if (i) {
            if (opp(aux.first, v.back().first)) stop = true;
            if (!stop) {
                if (aux.first == v.back().first) v.back().second += aux.second;
                else v.push_back(aux);
            }
        }
        else v.push_back(aux);
        if (!stop) r += aux.second;
    }
    n = v.size();
    while (r > l + 1) {
        ll m = (l + r) / 2, andei = 0, at, linhas = 0;
        vector<ll> x, y;
        pll a = {0, 0};
        x.push_back(0), y.push_back(0);
        for (int i = 0; i < n; i++) {
            linhas++;
            if (m - andei <= v[i].second) {
                at = m - andei;
            }
            else {
                at = v[i].second;
            }
            if (v[i].first == 'L') {
                x.push_back(a.first - at);
                a.first -= at;
            }
            if (v[i].first == 'R') {
                x.push_back(a.first + at);
                a.first += at;
            }
            if (v[i].first == 'U') {
                y.push_back(a.second + at);
                a.second += at;
            }
            if (v[i].first == 'D') {
                y.push_back(a.second - at);
                a.second -= at;
            }
            if (at == m - andei) break;
            andei += at;
        }
        sort(x.begin(), x.end());
        x.erase(unique(x.begin(), x.end()), x.end());
        sort(y.begin(), y.end());
        y.erase(unique(y.begin(), y.end()), y.end());
 
        // x1 < x2, y1 < y2
        int x1, x2, y1, y2;
        andei = 0;
        a = {0, 0};
        for (int i = 0; i < n; i++) {
            if (m - andei <= v[i].second) {
                at = m - andei;
            }
            else {
                at = v[i].second;
            }
            if (v[i].first == 'L') {
                x1 = lower_bound(x.begin(), x.end(), a.first - at) - x.begin();
                x2 = lower_bound(x.begin(), x.end(), a.first) - x.begin();
                y1 = y2 = lower_bound(y.begin(), y.end(), a.second) - y.begin();
                hor[x1].emplace_back(x1, y1, x2, y2, 1);
                chor[y1].emplace_back(x1, y1, x2, y2, 1);
                a.first -= at;
            }
            if (v[i].first == 'R') {
                x1 = lower_bound(x.begin(), x.end(), a.first) - x.begin();
                x2 = lower_bound(x.begin(), x.end(), a.first + at) - x.begin();
                y1 = y2 = lower_bound(y.begin(), y.end(), a.second) - y.begin();
                hor[x1].emplace_back(x1, y1, x2, y2, 1);
                chor[y1].emplace_back(x1, y1, x2, y2, 1);
                a.first += at;
            }
            if (v[i].first == 'U') {
                y1 = lower_bound(y.begin(), y.end(), a.second) - y.begin();
                y2 = lower_bound(y.begin(), y.end(), a.second + at) - y.begin();
                x1 = x2 = lower_bound(x.begin(), x.end(), a.first) - x.begin();
                vert[x1].emplace_back(x1, y1, x2, y2, 1);
                a.second += at;
            }
            if (v[i].first == 'D') {
                y1 = lower_bound(y.begin(), y.end(), a.second - at) - y.begin();
                y2 = lower_bound(y.begin(), y.end(), a.second) - y.begin();
                x1 = x2 = lower_bound(x.begin(), x.end(), a.first) - x.begin();
                vert[x1].emplace_back(x1, y1, x2, y2, 1);
                a.second -= at;
            }
            if (at == m - andei) break;
            andei += at;
        }
        bool ok = true;
 
        // checar se tem intersecao entre segmento paralelo
        for (int i = 0; i <= n; i++) {
            sort(chor[i].begin(), chor[i].end(), [&] (line a, line b) {
                return a.x1 < b.x1;
            });
            sort(vert[i].begin(), vert[i].end(), [&] (line a, line b) {
                return a.y1 < b.y1;
            });
            ll mn = -1e9;
            for (auto ber : chor[i]) {
                ok &= ber.x1 > mn;
                mn = ber.x2;
            }
            mn = -1e9;
            for (auto ber : vert[i]) {
                ok &= ber.y1 > mn;
                mn = ber.y2;
            }
        }
 
        // contar intersecao entre segmento geral
        ll ans = 0;
        for (int i = 0; i < MAXN; i++) {
            for (line &x : hor[i]) {
                if (x.take == 1) {
                    // cout << "SOMA " << x.x1 << ' ' << x.y1 << ' ' << x.x2 << ' ' << x.y2 << '\n'; 
                    upd(x.y1, x.take);  
                    x.take = -1;
                    hor[x.x2].push_back(x);
                    x.take = 1;
                }
            }
            for (line &x : vert[i]) {
                ans += sum(x.y2) - sum(x.y1-1);
            }
            for (line &x : hor[i]) {
                if (x.take == -1) {
                    upd(x.y1, x.take);  
                }
            }
        }
        ok &= (ans == linhas - 1);
 
        for (int i = 0; i < MAXN; i++) {
            bit[i] = 0;
            vert[i].clear();
            hor[i].clear();
            chor[i].clear();
        }
 
        if (ok) l = m;
        else r = m;
    }
    cout << l + 1 << '\n';
    return 0;
}
\end{lstlisting}

\subsection{School Excursion}
\begin{lstlisting}
// Problem name: School Excursion
// Problem Link: https://cses.fi/problemset/task/1706
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A group of n children are coming to Helsinki. 
// There are two possible attractions: a child can visit either Korkeasaari (zoo) or Linnanmaki (amusement park).
// There are m pairs of children who want to visit the same attraction. 
// Your task is to find all possible alternatives for the number of children that will visit Korkeasaari. 
// The children's wishes have to be taken into account.
// Knapsack em Nsqrt(n)/32

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
const ll base = 1e12;
 
vector<int> v[MAXN], vals;
int vis[MAXN], cnt, dp[MAXN], used[MAXN], have[MAXN];
 
void dfs(int node) {
	cnt++;
	vis[node] = 1;
	for (int x : v[node]) 
		if (!vis[x]) dfs(x);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, a, b;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			cnt = 0;
			dfs(i);
			vals.push_back(cnt);
		}
	}
	for (int x : vals) have[x]++;
    bitset<200010> dp;
    dp[0] = 1;
    for (int i = 1; i < 100005; i++) {
        while (have[i] > 2) {
            have[i] -= 2;
            have[2 * i]++;
        }
        while (have[i]--) {
            dp |= (dp << i);
        }
    }
    
    for (int i = 1; i <= n; i++) cout << dp[i];
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Shortest Subsequence}
\begin{lstlisting}
// Problem name: Shortest Subsequence
// Problem Link: https://cses.fi/problemset/task/1087
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a DNA sequence consisting of characters A, C, G, and T.
// Your task is to find the shortest DNA sequence that is not a subsequence of the original sequence.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int main () { _
	string s, resp;
	cin >> s;
	int tam = s.size();
	set<char> st;
	int ans = 0;
	for (int i = 0; i < tam; i++) {
		st.insert(s[i]);
		if ((int)st.size() == 4) {
			resp += s[i];
			ans++;
			st.clear();
		}
	}
	if (!st.count('A')) resp += 'A';
	else if (!st.count('C')) resp += 'C';
	else if (!st.count('G')) resp += 'G';
	else resp += 'T';
	cout << resp << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{Sorting Methods}
\begin{lstlisting}
// Problem name: Sorting Methods
// Problem Link: https://cses.fi/problemset/task/1162
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Here are some possible methods using which we can sort the elements of an array in increasing order:
//     At each step, choose two adjacent elements and swap them.
//     At each step, choose any two elements and swap them.
//     At each step, choose any element and move it to another position.
//     At each step, choose any element and move it to the front of the array.
// Given a permutation of numbers 1,2,…,n, calculate the minimum number of steps to sort the array using the above methods.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
int v[MAXN], a[MAXN], inv[MAXN], vis[MAXN];
vector<int> adj[MAXN];
 
int sum(int pos) {
    int ans = 0;
    for (; pos; pos -= (pos & -pos)) ans += a[pos];
    return ans;
}
 
void upd(int pos, int val) { for (; pos < MAXN; pos += (pos & -pos)) a[pos] += val; }
 
void dfs(int node) {
    vis[node] = 1;
    for (int x : adj[node]) 
        if (!vis[x]) dfs(x);
}
 
int lis(int n) {
    vector<int> pilha;
    for (int i = 0; i < n; i++) {
        auto pos = lower_bound(pilha.begin(), pilha.end(), v[i]);
        if (pos == pilha.end())
            pilha.push_back(v[i]);
        else *pos = v[i];
    }
    return pilha.size();
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) cin >> v[i];
    ll ans1 = 0;
    int ans2 = n, ans3 = n, ans4 = n;
    int atual = n;
    for (int i = n-1; i >= 0; i--) {
        ans1 += sum(v[i]);
        upd(v[i], 1);
        if (v[i] == atual) {
            atual--;
            ans4--;
        }
        adj[v[i]].push_back(i+1);
        adj[i+1].push_back(v[i]);
    }
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) {
            dfs(i);
            ans2--;
        }
    }
    ans3 -= lis(n);
    cout << ans1 << ' ' << ans2 << ' ' << ans3 << ' ' << ans4 << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Special Substrings}
\begin{lstlisting}
// Problem name: Special Substrings
// Problem Link: https://cses.fi/problemset/task/2186
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A substring is called special if every character that appears in the string 
// appears the same number of times in the substring.
// Your task is to count the number of special substrings in a given string.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 4e5 + 5;
const ll INF = 2e18;
 
map<vector<int>, int> mp;
map<char, int> mapao;
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    int n = s.size();
    set<char> st;
    for (auto x : s) st.insert(x);
    int tam = st.size();
    vector<int> v(tam);
    mp[v] = 1;
    ll ans = 0;
    int cnt = 0;
    for (auto x : st) {
        mapao[x] = cnt;
        cnt++;
    }
    for (int i = 0; i < n; i++) {
        v[mapao[s[i]]]++;
        vector<int> nv = v;
        int mn = *min_element(v.begin(), v.end());
        for (int j = 0; j < tam; j++) nv[j] -= mn;
        ans += mp[nv];
        mp[nv]++;
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Stack Weights}
\begin{lstlisting}
// Problem name: Stack Weights
// Problem Link: https://cses.fi/problemset/task/2425
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You have n coins, each of which has a distinct weight.
// There are two stacks which are initially empty. 
// On each step you move one coin to a stack. You never remove a coin from a stack.
// After each move, your task is to determine which stack is heavier 
// (if we can be sure that either stack is heavier).

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
ll lz[4 * MAXN], a[2][4 * MAXN];
 
void push(int node, int i, int j) {
	a[0][node] += lz[node];
	a[1][node] += lz[node];
	if (i != j) {
		lz[2 * node] += lz[node];
		lz[2 * node + 1] += lz[node];
	}
	lz[node] = 0;
}
 
void upd(int node, int i, int j, int ini, int fim, int val) {
	push(node, i, j);
	if (ini <= i && j <= fim) {
		lz[node] += val;
		push(node, i, j);
	}
	else if (j < ini || i > fim) return;
	else {
		int m = (i + j) / 2;
		upd(2 * node, i, m, ini, fim, val);
		upd(2 * node + 1, m + 1, j, ini, fim, val);
		a[0][node] = min(a[0][2 * node], a[0][2 * node + 1]);
		a[1][node] = max(a[1][2 * node], a[1][2 * node + 1]);
	}
}
 
 
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
	cin >> n;
	int pos, st;
	for (int i = 0; i < n; i++) {
		cin >> pos >> st;
		upd(1, 1, n, 1, pos, (st == 1 ? -1 : 1));
		int mn = a[0][1];
		int mx = a[1][1];
		if (mn >= 0 && mx >= 0) cout << "<\n";
		else if (mn <= 0 && mx <= 0) cout << ">\n";
		else cout << "?\n";
	}
    return 0;
}
\end{lstlisting}

\subsection{Stick Divisions}
\begin{lstlisting}
// Problem name: Stick Divisions
// Problem Link: https://cses.fi/problemset/task/1161
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You have a stick of length x and you want to divide it into n sticks,
// with given lengths, whose total length is x.
// On each move you can take any stick and divide it into two sticks. 
// The cost of such an operation is the length of the original stick.
// What is the minimum cost needed to create the sticks?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	int x, n;
	cin >> x >> n;
	vector<int> v(n);
	priority_queue<int, vector<int>, greater<int>> fila;
	for (int &x : v) {
		cin >> x;
		fila.push(x);
	}
	ll ans = 0;
	int a, b;
	while (fila.size() > 1) {
		a = fila.top();
		fila.pop();
		b = fila.top();
		fila.pop();
		ans += a + b;
		fila.push(a+b);
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{String Removals}
\begin{lstlisting}
// Problem name: String Removals
// Problem Link: https://cses.fi/problemset/task/1149
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a string. You can remove any number of characters from it, 
// but you cannot change the order of the remaining characters.
// How many different strings can you generate?


#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 5e5 + 5;
const ll INF = 1e18;
 
int dp[MAXN], last[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    int n = s.size();
    vector<int> v(26, -1);
    dp[0] = 1;
    for (int i = 1; i <= n; i++) {
        last[i] = (v[s[i-1]-'a'] < 0 ? -1 : v[s[i-1]-'a']);
        v[s[i-1] - 'a'] = i-1;
        dp[i] = dp[i-1] - (last[i] >= 0 ? dp[last[i]] : 0);
        if (dp[i] < 0) dp[i] += MOD;
        if (dp[i] >= MOD) dp[i] -= MOD;
        dp[i] += dp[i-1];
        if (dp[i] >= MOD) dp[i] -= MOD;
    }
    cout << (dp[n]-1+MOD) % MOD << '\n';
    return 0;
}
\end{lstlisting}

\subsection{String Reorder}
\begin{lstlisting}
// Problem name: String Reorder
// Problem Link: https://cses.fi/problemset/task/1743
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a string, you want to reorder its characters so that no two adjacent 
// characters are the same. What is the lexicographically minimal such string?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
vector<int> v(26);
string s;
 
bool valid(int n) {
    int maxi = 0;
    for (int i = 0; i < 26; i++) maxi = max(maxi, v[i]);
    if (maxi > n - maxi + 1) return false;
    return true;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> s;
    int maxi = 0, n = s.size();
    for (auto x : s) {
        v[x-'A']++;
        maxi = max(maxi, v[x-'A']);
    }
    if (maxi > n - maxi + 1) cout << "-1\n";
    else {
        string ans;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < 26; j++) {
                if (v[j] && (!i ? true : (ans[i-1] != (('A' + j))))) {
                    v[j]--;
                    ans += ('A'+j);
                    if (valid(n - i - 1)) break;
                    else {
                        v[j]++;
                        ans.pop_back();
                    }
                }
            }
        }
        cout << ans << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{String Transform}
\begin{lstlisting}
// Problem name: String Transform
// Problem Link: https://cses.fi/problemset/task/1113
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Consider the following string transformation:
//     append the character # to the string ('#' < 'a')
//     generate all rotations of the string
//     sort the rotations in increasing order
//     based on this order, construct a new string that contains the last character of each rotation
// For example, the string babc becomes babc#. 
// Then, the sorted list of rotations is #babc, abc#b, babc#, bc#ba, and c#bab. 
// This yields a string cb#ab.
// Given the transformation, reconstruct the original string

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e6 + 5;
const ll INF = 2e18;
 
vector<int> pos[27];
int id[27], shift[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string ini, fim, ans;
    cin >> fim;
    int n = fim.size();
    ini = fim;
    sort(ini.begin(), ini.end());
    for (int i = 0; i < n; i++) {
        if (fim[i] == '#') pos[26].push_back(i);
        else pos[fim[i] - 'a'].push_back(i);
    }
    for (int i = 0; i < n; i++) {
        if (ini[i] == '#') shift[i] = pos[26].back();
        else shift[i] = pos[ini[i] - 'a'][id[ini[i] - 'a']++];
    }
    int at = shift[shift[0]];
    for (int i = 0; i < n - 1; i++) {
        ans += fim[at];
        at = shift[at];
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Strongly Connected Edges}
\begin{lstlisting}
// Problem name: Strongly Connected Edges
// Problem Link: https://cses.fi/problemset/task/2177
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given an undirected graph, your task is to choose a direction 
// for each edge so that the resulting directed graph is strongly connected.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
vector<int> v[MAXN];
vector<pii> edges;
int low[MAXN], cnt = 0, vis[MAXN], dep[MAXN];
 
void dfs(int node, int pai) {
	vis[node] = ++cnt;
	low[node] = cnt;
	dep[node] = dep[pai] + 1;
	for (int x : v[node]) {
		if (x == pai) continue;
		if (!vis[x]) {
			dfs(x, node);
			low[node] = min(low[node], low[x]);
		}
		else low[node] = min(low[node], vis[x]);
	}
	if (low[node] == vis[node] && pai > 0) edges.emplace_back(node, pai);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
		edges.emplace_back(a, b);
	}
	int compo = 0;
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			dfs(i, 0);
			compo++;
		}
	}
	if ((int)edges.size() > m || compo > 1) cout << "IMPOSSIBLE\n";
	else {
		for (auto x : edges) {
			if (dep[x.second] > dep[x.first]) swap(x.first, x.second);
			if (dep[x.first] - dep[x.second] == 1) 
				cout << x.second << ' ' << x.first << '\n';
			else 
				cout << x.first << ' ' << x.second << '\n';
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{Swap Game}
\begin{lstlisting}
// Problem name: Swap Game
// Problem Link: https://cses.fi/problemset/task/1670
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a 3 x 3 grid containing the numbers 1,2 ...,9. 
// Your task is to perform a sequence of moves so that the grid will look like this:
// 1 2 3
// 4 5 6
// 7 8 9
// On each move, you can swap the numbers in any two adjacent squares (horizontally or vertically). 
// What is the minimum number of moves required?

// Se a gnt so pudesse fazer os swaps com o numero 1, seria equivalente ao jogo de deslizar
// No jogo de deslizar, soh eh possivel resolver um tabuleiro de tamanho impar sse o numero de inversoes for par
// para um tabuleiro de tamanho par, soh eh possivel sse o numero de inversoes + linha do quadrado vazio
// (0-indexado) for par

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
const int N = 381367045;
 
bitset<N> vis;
int pwr[10];
 
int h(int atual, int pos) {
	if (pos == 2 || pos == 5) return 0;
	int ini = atual;
	int p0, p1, cnt = 0;
	while (cnt <= pos) {
		if (cnt == pos) p0 = atual % 9;
		atual /= 9;
		cnt++;
	}
	p1 = atual % 9;
	return ini - pwr[pos] * p0 - pwr[pos+1] * p1 + pwr[pos] * p1 + pwr[pos+1] * p0;
}
 
int v(int atual, int pos) {
	if (pos >= 6) return 0;
	int ini = atual;
	int p0, p1, cnt = 0;
	while (cnt <= pos+2) {
		if (cnt == pos) p0 = atual % 9;
		atual /= 9;
		cnt++;
	}
	p1 = atual % 9;
	return ini - pwr[pos] * p0 - pwr[pos+3] * p1 + pwr[pos] * p1 + pwr[pos+3] * p0;
}
 
int main () { _
	pwr[0] = 1;
	for (int i = 1; i < 10; i++) pwr[i] = 9 * pwr[i-1];
	int start = 0, aux, meta = 0;
	for (int i = 0; i < 9; i++) {
		cin >> aux;
		start += pwr[i] * (aux % 9);
		meta += pwr[i] * ((i+1) % 9);
	}
	v(start, 5);
	queue<pii> fila;
	fila.push({start, 0});
	vis[0] = 1;
	vis[start] = 1;
	int ans = -1, hor, ver;
	while (!fila.empty()) {
		pii atual = fila.front();
		fila.pop();
		if (atual.F == meta) {
			ans = atual.S;
			break;
		}
		for (int i = 0; i < 8; i++) {
			hor = h(atual.F, i), ver = v(atual.F, i);
			if (!vis[hor]) {
				vis[hor] = 1;
				fila.push({hor, atual.S+1});
			}
			if (!vis[ver]) {
				vis[ver] = 1;
				fila.push({ver, atual.S+1});
			}
		}
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Swap Round Sorting}
\begin{lstlisting}
// Problem name: Swap Round Sorting
// Problem Link: https://cses.fi/problemset/task/1698
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an array containing a permutation of numbers 1,2,...n, 
// and your task is to sort the array using swap rounds. On each swap round, 
// you can choose any number of distinct pairs of elements and swap each pair.
// Your task is to find the minimum number of rounds and show how you can choose the pairs in each round.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
int v[MAXN], vis[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	vector<vector<int>> cic;
	vector<int> sz;
	int mx = 0;
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			vector<int> nv;
			vis[i] = 1;
			nv.push_back(i);
			int bg = i, at = v[i];
			while (at != bg) {
				vis[at] = 1;
				nv.push_back(at);
				at = v[at];
			}
			cic.push_back(nv);
			sz.push_back(nv.size());
			mx = max(mx, (int)nv.size());
		}
	}
	memset(vis, 0, sizeof(vis));
	int ans = min(2, (int)ceil(log2(mx)));
	cout << ans << '\n';
	int qtd = 0;
	for (int j = 0; j < (int)cic.size(); j++) {
		qtd += sz[j] / 2;
	}
	cout << qtd << '\n';
	for (int j = 0; j < (int)cic.size(); j++) {
		int tam = cic[j].size();
		if (sz[j] > 1) {
			for (int k = 0; k < tam / 2; k++) {
				cout << cic[j][k] << ' ' << cic[j][tam - k - 1] << '\n'; 
				swap(v[cic[j][k]], v[cic[j][tam - k - 1]]);
			}
		}
	}
	if (ans == 2) {
		qtd = 0;
		for (int i = 1; i <= n; i++) {
			if (v[i] != i) qtd++;
		}
		cout << qtd / 2 << '\n';
		for (int i = 1; i <= n; i++) {
			if (v[i] != i && !vis[i]) {
				cout << i << ' ' << v[i] << '\n';
				vis[i] = vis[v[i]] = 1;
			}
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{Tree Isomorphism I}
\begin{lstlisting}
// Problem name: Tree Isomorphism I
// Problem Link: https://cses.fi/problemset/task/1700
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given two rooted trees, your task is to find out if they are isomorphic, 
// i.e., it is possible to draw them so that they look the same.

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
vector<int> v[2][MAXN];
int id = 0;
map<vector<int>, int> mp;
 
int dfs(int node, int p, bool at) {
    vector<int> val;
    for (int x : v[at][node]) {
        if (x != p) {
            val.push_back(dfs(x, node, at));
        }
    }
    sort(val.begin(), val.end());
    if (!mp[val]) mp[val] = ++id;
    return mp[val];
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        mp.clear();
        id = 0;
        int n, a, b;
        cin >> n;
        for (int i = 0; i < 2; i++) {
            for (int j = 1; j <= n; j++) {
                v[i][j].clear();
            }
            for (int j = 0; j < n - 1; j++) {
                cin >> a >> b;
                v[i][a].push_back(b);
                v[i][b].push_back(a);
            }
        }
        int s0 = dfs(1, -1, 0);
        int s1 = dfs(1, -1, 1);
        cout << (s0 == s1 ? "YES\n" : "NO\n");
    }
    return 0;
}
\end{lstlisting}

\subsection{Tree Isomorphism II}
\begin{lstlisting}
// Problem name: Tree Isomorphism II
// Problem Link: https://cses.fi/problemset/task/1701
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given two (not rooted) trees, your task is to find out if they are isomorphic, 
// i.e., it is possible to draw them so that they look the same.

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
vector<int> v[2][MAXN];
int id = 0, dp[2][MAXN], n;
map<vector<int>, int> mp;
 
int dfs(int node, int p, bool at) {
    dp[at][node] = 1;
    vector<int> val;
    for (int x : v[at][node]) {
        if (x != p) {
            val.push_back(dfs(x, node, at));
            dp[at][node] += dp[at][x];
        }
    }
    sort(val.begin(), val.end());
    if (!mp[val]) mp[val] = ++id;
    return mp[val];
}
 
void dfs2(int node, int p, int at) {
    dp[at][node] = 1;
    for (int x : v[at][node]) {
        if (x != p) {
            dfs2(x, node, at);
            dp[at][node] += dp[at][x];
        }
    }
}
 
vector<int> ctd(int node, int p, bool at) {
    vector<int> ans;
    bool ok = true;
    for (int x : v[at][node]) {
        if (x != p) {
            vector<int> a = ctd(x, node, at);
            for (int x : a) ans.push_back(x);
            ok &= (dp[at][x] <= (n / 2));
        }
    }
    ok &= (n - dp[at][node] <= (n/2));
    if (ok) ans.push_back(node);
    return ans;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        mp.clear();
        id = 0;
        int a, b;
        cin >> n;
        for (int i = 0; i < 2; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = 0;
                v[i][j].clear();
            }
            for (int j = 0; j < n - 1; j++) {
                cin >> a >> b;
                v[i][a].push_back(b);
                v[i][b].push_back(a);
            }
        }
        dfs2(1, -1, 0), dfs2(1, -1, 1);
        vector<int> c0 = ctd(1, -1, 0), c1 = ctd(1, -1, 1);
        int s0 = dfs(c0[0], -1, 0);
        bool ok = false;
        for (int x : c1) {
            if (dfs(x, -1, 1) == s0) ok = true;
        }
        cout << (ok ? "YES\n" : "NO\n");
    }
    return 0;
}
\end{lstlisting}

\subsection{Tree Traversals}
\begin{lstlisting}
// Problem name: Tree Traversals
// Problem Link: https://cses.fi/problemset/task/1702
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are three common ways to traverse the nodes of a binary tree:
//     Preorder: First process the root, then the left subtree, and finally the right subtree.
//     Inorder: First process the left subtree, then the root, and finally the right subtree.
//     Postorder: First process the left subtree, then the right subtree, and finally the root.
// There is a binary tree of n nodes with distinct labels. 
// You are given the preorder and inorder traversals of the tree, and your task is to determine its postorder traversal.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
int pre[MAXN], in[MAXN], mapa[MAXN];
 
void build(int i1, int f1, int i2, int f2) {
    if (i1 > f1) return;
    int root = mapa[pre[i2]], tam = (root-i1);
    build(i1, root-1, i2+1, i2+tam);
    build(root+1, f1, i2+tam+1, f2);
    cout << in[root] << ' ';
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) cin >> pre[i];
    for (int i = 0; i < n; i++) {
        cin >> in[i];
        mapa[in[i]] = i;
    }
    build(0, n-1, 0, n-1);
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Two Stacks Sorting}
\begin{lstlisting}
// Problem name: Two Stacks Sorting
// Problem Link: https://cses.fi/problemset/task/2402
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an input list that consists of n numbers. Each integer between 1 and n appears exactly once in the list.
// Your task is to create a sorted output list using two stacks. On each move you can do one of the following:
//     Move the first number from the input list to a stack
//     Move a number from a stack to the end of the output list

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
struct no {
    int mn, mx;
    no(int _mn = MAXN, int _mx = 0) {
        mn = _mn, mx = _mx;
    }
    no operator + (const no &x) const {
        no aux;
        aux.mn = min(mn, x.mn);
        aux.mx = max(mx, x.mx);
        return aux;
    }
} a[4 * MAXN];
 
pii tree[MAXN];
 
void build(int node, int i, int j) {
    if (i == j) {
        a[node] = no(tree[i].first, tree[i].second);
    }
    else {
        int m = (i + j) / 2;
        build(2 * node, i, m);
        build(2 * node + 1, m + 1, j);
        a[node] = a[2 * node] + a[2 * node + 1];
    }
}
 
void update(int node, int i, int j, int pos) {
    if (i == j) {
        a[node] = no(tree[i].first, tree[i].second);
    }
    else {
        int m = (i + j) / 2;
        if (pos <= m)
            update(2 * node, i, m, pos);
        else
            update(2 * node + 1, m + 1, j, pos);
        a[node] = a[2 * node] + a[2 * node + 1];
    }
}
 
no query(int node, int i, int j, int ini, int fim) {
    if (ini > j || fim < i) return no(MAXN, 0);
    else if (ini <= i && j <= fim) return a[node];
    else {
        int m = (i + j) / 2;
        return query(2 * node, i, m, ini, fim) + query(2 * node + 1, m + 1, j, ini, fim);
    }
}
 
int v[MAXN], cor[MAXN], great[MAXN], vis[MAXN], pos[MAXN];
vector<int> g[MAXN];
 
void dfs(int node, int c) {
    cor[node] = c;
    vis[node] = 1;
    for (int x : g[node]) {
        if (!vis[x]) {
            dfs(x, c ^ 1);
        }
    }
}
 
bool check(int n) {
    stack<int> s[2];
    int at = 1;
    for (int i = 1; i <= n; i++) {
        s[cor[i]].push(v[i]);
        while (!s[0].empty() && s[0].top() == at) {
            s[0].pop();
            at++;
            while (!s[1].empty() && s[1].top() == at) {
                s[1].pop();
                at++;
            }
        }
        while (!s[1].empty() && s[1].top() == at) {
            s[1].pop();
            at++;
            while (!s[0].empty() && s[0].top() == at) {
                s[0].pop();
                at++;
            }
        }
    }
    return s[0].empty() && s[1].empty();
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> v[i];
    v[n + 1] = n + 1;
    for (int i = 1; i <= n; i++) {
        tree[i] = {v[i], 0};
        pos[v[i]] = i;
    }
    for (int i = 1; i <= n; i++) great[i] = i + 1;
    for (int i = n; i >= 1; i--) {
        while (v[great[i]] < v[i]) {
            great[i] = great[great[i]];
        }
    }
    build(1, 1, n);
    no aux, giuli;
    for (int i = 1; i < n; i++) {
        if (great[i] < n) {
            aux = query(1, 1, n, great[i] + 1, n);
            if (aux.mn < v[i]) {
                g[i].push_back(great[i]);
                g[great[i]].push_back(i);
            }
        }
        if (v[i] > 1) {
            aux = query(1, 1, n, 1, v[i] - 1);
            if (aux.mx) {
                giuli = query(1, 1, n, i + 1, n);
                if (giuli.mn < aux.mx) {
                    g[pos[aux.mx]].push_back(i);
                    g[i].push_back(pos[aux.mx]);
                }
            }
        }
        tree[v[i]].second = v[i];
        update(1, 1, n, v[i]);
    }
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) dfs(i, 0);
    }
    if (check(n)) {
        for (int i = 1; i <= n; i++) cout << cor[i] + 1 << ' ';
        cout << '\n';
    }
    else cout << "IMPOSSIBLE\n";
    return 0;
}
\end{lstlisting}

\subsection{Visiting Cities}
\begin{lstlisting}
// Problem name: Visiting Cities
// Problem Link: https://cses.fi/problemset/task/1203
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You want to travel from Syrjälä to Lehmälä by plane using a minimum-price route. 
// Which cities will you certainly visit?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
vector<pii> v[MAXN];
vector<int> w[MAXN], sla[MAXN];
ll dist[MAXN];
int low[MAXN], nec[MAXN], cnt = 0, vis[MAXN], ja[MAXN], vis15[MAXN], vis2[MAXN];
 
void dfs(int node, int pai) {
	vis[node] = ++cnt;
	low[node] = cnt;
	int filhos = 0;
	for (int x : w[node]) {
		if (!vis[x]) {
			filhos++;
			dfs(x, node);
			low[node] = min(low[node], low[x]);
		}
		else if (x != pai) low[node] = min(low[node], vis[x]);
	}
	if (node == 1) nec[node] = (filhos > 1);
	else if (low[node] >= vis[pai] && pai > 1) nec[pai] = 1;
}
 
void dfs15(int node) {
    vis15[node] = 1;
    for (int x : sla[node]) {
        if (!vis15[x]) dfs15(x);
    }
}
 
void dfs2(int node) {
    vis2[node] = 1;
    for (auto x : v[node]) {
        if (dist[node] + x.second == dist[x.first]) {
            sla[x.first].push_back(node);
        }
        if (!vis2[x.first]) dfs2(x.first);
    }
}
 
void dijkstra(int n) {
    for (int i = 1; i <= n; i++) dist[i] = INF;
    dist[1] = 0;
    priority_queue<pll, vector<pll>, greater<pll>> fila;
    fila.push({dist[1], 1});
    while (!fila.empty()) {
        pll at = fila.top();
        fila.pop();
        if (dist[at.second] < at.first) continue;
        for (auto x : v[at.second]) {
            if (dist[x.first] > at.first + x.second) {
                dist[x.first] = at.first + x.second;
                fila.push({dist[x.first], x.first});
            }
        }
    }
}
 
void dag(int node) {
    ja[node] = 1;
    for (auto x : v[node]) {
        if (dist[node] + x.second == dist[x.first] && vis15[x.first]) {
            w[x.first].push_back(node);
            w[node].push_back(x.first);
            sla[x.first].push_back(node);
        }
        if (!ja[x.first] && vis15[x.first]) dag(x.first);
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, a, b, c;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> a >> b >> c;
        v[a].emplace_back(b, c);
    }
    dijkstra(n);
    dfs2(1);
    dfs15(n);
    dag(1);
    dfs(1, -1);
    nec[1] = nec[n] = 1;
    int qtd = 0;
    for (int i = 1; i <= n; i++) qtd += nec[i];
    cout << qtd << '\n';
    for (int i = 1; i <= n; i++) {
        if (nec[i]) cout << i << ' ';
    }    
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Writing Numbers}
\begin{lstlisting}
// Problem name: Writing Numbers
// Problem Link: https://cses.fi/problemset/task/1086
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You would like to write a list of positive integers 1,2,3 ... using your computer. 
// However, you can press each key 0–9 at most n times during the process.
// What is the last number you can write?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	ll n;
	cin >> n;
	ll ans = 524638270000000001;
	for (int i = 0; i < 10; i++) {
		ll l = 0, r = 524638270000000001;
		while (r > l+1) {
			ll m = (r+l) >> 1, test = m, cnt = 0, pot = 1;
			for (int j = 0; j <= 18; j++) {
				if (!test) break;
				cnt += pot * (test/10 + (test%10 > i));
				if (test%10 == i) cnt += m - test*pot + 1;
				if (!i) cnt -= pot;
				pot *= 10;
				test /= 10;
			}
			if (cnt <= n) l = m;
			else r = m;
		}
		ans = min(ans, l);
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Xor Pyramid}
\begin{lstlisting}
// Problem name: Xor Pyramid
// Problem Link: https://cses.fi/problemset/task/2419
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Consider a xor pyramid where each number is the xor of lower-left and lower-right numbers.
// Given the bottom row of the pyramid, your task is to find the topmost number.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int main () { _
	int n;
	cin >> n;
	vector<int> v(n), par(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	// par[i] = 1 if i submask de n
	for (int i = 0; i < n; i++) {
		par[i] = ((i & (n-1)) == i);
	}
	int ans = 0;
	for (int i = 0; i < n; i++) {
		ans ^= par[i] * v[i];
	}
	cout << ans << '\n';
	return 0;	
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% CSES - Advanced Techniques
%
%%%%%%%%%%%%%%%%%%%%

\section{CSES - Advanced Techniques}

\subsection{Apples and Bananas}
\begin{lstlisting}
// Problem name: Apples and Bananas
// Problem Link: https://cses.fi/problemset/task/2111
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are apples and bananas and each of them has an integer weight between 1...k. 
// Your task is to calculate for each weight w between 2...2k the number of ways we 
// can choose an apple and a banana whose combined weight is w.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
using cd = complex<double>;
const double PI = acos(-1);
 
void fft(vector<cd> & a, bool invert) {
    int n = a.size();
 
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;
 
        if (i < j)
            swap(a[i], a[j]);
    }
 
    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            cd w(1);
            for (int j = 0; j < len / 2; j++) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
 
    if (invert) {
        for (cd & x : a)
            x /= n;
    }
}
 
vector<ll> multiply(vector<int> const& a, vector<int> const& b) {
    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n < (int)(a.size() + b.size())) 
        n <<= 1;
    fa.resize(n);
    fb.resize(n);
 
    fft(fa, false);
    fft(fb, false);
    for (int i = 0; i < n; i++)
        fa[i] *= fb[i];
    fft(fa, true);
 
    vector<ll> result(n);
    for (int i = 0; i < n; i++)
        result[i] = round(fa[i].real());
    return result;
}
 
int main() { _
	int k, n, m, aux;
	cin >> k >> n >> m;
	vector<int> ban(k), ap(k);
	for (int i = 0; i < n; i++) {
		cin >> aux;
		ban[aux-1]++;
	}
	for (int i = 0; i < m; i++) {
		cin >> aux;
		ap[aux-1]++;
	}
	vector<ll> ans = multiply(ban, ap);
	for (int i = 0; i < 2*k-1; i++) cout << ans[i] << ' ';
	cout << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Beautiful Subgrids}
\begin{lstlisting}
// Problem name: Beautiful Subgrids
// Problem Link: https://cses.fi/problemset/task/2137
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an n x n grid whose each square is either black or white.
// A subgrid is called beautiful if its height and width is at least two 
// and all of its corners are black. How many beautiful subgrids are there within the given grid?

#pragma GCC target("popcnt")
#include <iostream>
#include <bitset>
using namespace std;
const int N = 3000;
bitset<N> v[N];
string s;
int main () {
	int n;
	string s;
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> s;
		v[i] = bitset<N>(s);
	}
	long long int ans = 0;
	for (int i = 0; i < n; i++) {
		for (int j = i+1; j < n; j++) {
			int tot = (v[i] & v[j]).count();
			ans += (tot * (tot-1))/2;
		}
	}
	cout << ans << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Cut and Paste}
\begin{lstlisting}
// Problem name: Cut and Paste
// Problem Link: https://cses.fi/problemset/task/2072
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a string, your task is to process operations 
// where you cut a substring and paste it to the end of the string. 
// What is the final string after all the operations?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const ll INF = 2e18;
 
struct node {
    node *L, *R;
    int prio, sz;
    char c;
    node (char _c) {
        L = NULL, R = NULL, prio = rng(), sz = 1, c = _c;
    }
};
 
int size(node *treap) {
    if (treap == NULL) return 0;
    return treap->sz;
}
 
void recalc(node *&treap) {
    if (treap == NULL) return;
    treap->sz = size(treap->L) + size(treap->R) + 1;
}
 
void split(node *treap, node *&L, node *&R, int k) {
    if (treap == NULL) {
        L = R = NULL;
    }
    else {
        if (size(treap->L) >= k) {
            split(treap->L, L, treap->L, k);
            R = treap;
        }
        else {
            split(treap->R, treap->R, R, k - size(treap->L) - 1);
            L = treap;
        }
        recalc(treap);
    }
}
 
void merge(node *&treap, node *L, node *R) {
    if (L == NULL) treap = R;
    else if (R == NULL) treap = L;
    else {
        if (L->prio > R->prio) {
            merge(L->R, L->R, R);
            treap = L;
        }
        else {
            merge(R->L, L, R->L);
            treap = R;
        }
        recalc(treap);
    }
}
 
void print(node *treap) {
    if (treap == NULL) return;
    print(treap->L);
    cout << treap->c;
    print(treap->R);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, l, r;
    string s;
    cin >> n >> m >> s;
    node *root = 0;
    for (int i = 0; i < n; i++) {
        merge(root, root, new node(s[i]));
    }
    for (int i = 0; i < m; i++) {
        cin >> l >> r;
        node *a, *b, *c, *d;
        split(root, a, b, l - 1);
        split(b, c, d, r - l + 1);
        merge(root, a, d);
        merge(root, root, c);
    }
    print(root);
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Distinct Routes II}
\begin{lstlisting}
// Problem name: Distinct Routes II
// Problem Link: https://cses.fi/problemset/task/2130
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A game consists of n rooms and m teleporters. 
// At the beginning of each day, you start in room 1 and you have to reach room n.
// You can use each teleporter at most once during the game. You want to play the game for exactly k days. 
// Every time you use any teleporter you have to pay one coin. 
// What is the minimum number of coins you have to pay during k days if you play optimally?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
// MinCostMaxFlow
//
// min_cost_flow(s, t, f) computa o par (fluxo, custo)
// com max(fluxo) <= f que tenha min(custo)
// min_cost_flow(s, t) -> Fluxo maximo de custo minimo de s pra t
// Se for um dag, da pra substituir o SPFA por uma DP pra nao
// para O(nm) no comeco
// Se nao tiver aresta com custo negativo, nao precisa do SPFA
//
// O(nm + f * m log n)
// 697b4c
 
template<typename T = int> struct mcmf {
	struct edge {
		int to, rev, flow, cap; // para, id da reversa, fluxo, capacidade
		bool res; // se eh reversa
		T cost; // custo da unidade de fluxo
		edge() : to(0), rev(0), flow(0), cap(0), cost(0), res(false) {}
		edge(int to_, int rev_, int flow_, int cap_, T cost_, bool res_)
			: to(to_), rev(rev_), flow(flow_), cap(cap_), res(res_), cost(cost_) {}
	};
 
	vector<vector<edge>> g;
	vector<int> par_idx, par;
	T inf;
	vector<T> dist;
 
	mcmf(int n) : g(n), par_idx(n), par(n), inf(numeric_limits<T>::max()/3) {}
 
	void add(int u, int v, int w, T cost) { // de u pra v com cap w e custo cost
		edge a = edge(v, g[v].size(), 0, w, cost, false);
		edge b = edge(u, g[u].size(), 0, 0, -cost, true);
 
		g[u].push_back(a);
		g[v].push_back(b);
	}
 
	vector<T> spfa(int s) { // nao precisa se nao tiver custo negativo
		deque<int> q;
		vector<bool> is_inside(g.size(), 0);
		dist = vector<T>(g.size(), inf);
 
		dist[s] = 0;
		q.push_back(s);
		is_inside[s] = true;
 
		while (!q.empty()) {
			int v = q.front();
			q.pop_front();
			is_inside[v] = false;
 
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
 
					if (is_inside[to]) continue;
					if (!q.empty() and dist[to] > dist[q.front()]) q.push_back(to);
					else q.push_front(to);
					is_inside[to] = true;
				}
			}
		}
		return dist;
	}
	bool dijkstra(int s, int t, vector<T>& pot) {
		priority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> q;
		dist = vector<T>(g.size(), inf);
		dist[s] = 0;
		q.emplace(0, s);
		while (q.size()) {
			auto [d, v] = q.top();
			q.pop();
			if (dist[v] < d) continue;
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				cost += pot[v] - pot[to];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
					q.emplace(dist[to], to);
					par_idx[to] = i, par[to] = v;
				}
			}
		}
		return dist[t] < inf;
	}
 
	pair<int, T> min_cost_flow(int s, int t, int flow) {
		vector<T> pot(g.size(), 0);
		pot = spfa(s); // mudar algoritmo de caminho minimo aqui
 
		int f = 0;
		T ret = 0;
		while (f < flow and dijkstra(s, t, pot)) {
			for (int i = 0; i < g.size(); i++)
				if (dist[i] < inf) pot[i] += dist[i];
 
			int mn_flow = flow - f, u = t;
			while (u != s){
				mn_flow = min(mn_flow,
					g[par[u]][par_idx[u]].cap - g[par[u]][par_idx[u]].flow);
				u = par[u];
			}
 
			ret += pot[t] * mn_flow;
 
			u = t;
			while (u != s) {
				g[par[u]][par_idx[u]].flow += mn_flow;
				g[u][g[par[u]][par_idx[u]].rev].flow -= mn_flow;
				u = par[u];
			}
 
			f += mn_flow;
		}
 
		return make_pair(f, ret);
	}
 
	// Opcional: retorna as arestas originais por onde passa flow = cap
	vector<pair<int,int>> recover() {
		vector<pair<int,int>> used;
		for (int i = 0; i < g.size(); i++) for (edge e : g[i])
			if(e.flow == e.cap && !e.res) used.push_back({i, e.to});
		return used;
	}
};
 
int n;
vector<pii> v[505], path;
 
void dfs(int node) {
    for (auto &x : v[node]) {
        if (!x.second && x.first != n + 1) {
            x.second = 1;
            path.emplace_back(node, x.first);
            dfs(x.first);
            break;
        }
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int m, k, a, b, c, d;
    cin >> n >> m >> k;
    mcmf ber(n + 2);
    ber.add(0, 1, k, 0);
    ber.add(n, n + 1, k, 0);
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        ber.add(a, b, 1, 1);
    }
    pii ans = ber.min_cost_flow(0, n + 1, ber.inf);
    if (ans.first < k) cout << "-1\n";
    else {
        cout << ans.second << '\n';
        vector<pii> ed = ber.recover();
        for (auto x : ed) {
            v[x.first].emplace_back(x.second, 0);
        }
        for (int i = 0; i < ans.first; i++) {
            dfs(1);
            cout << path.size() + 1 << '\n';
            cout << path[0].first << ' ';
            for (auto x : path) cout << x.second << ' ';
            cout << '\n';
            path.clear();
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{Dynamic Connectivity}
\begin{lstlisting}
// Problem name: Dynamic Connectivity
// Problem Link: https://cses.fi/problemset/task/2133
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Consider an undirected graph that consists of n nodes and m edges. There are two types of events that can happen:
//     A new edge is created between nodes a and b
//     An existing edge between nodes a and b is removed.
// Your task is to report the number of components after every event.

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const int INF = 2e9;
 
// Seg
 
struct no {
    vector<pii> v;
    no() {
        v = vector<pii> ();
    }
} a[4 * MAXN];
 
void update(int node, int i, int j, int ini, int fim, pii val) {
    if (j < ini || i > fim) return;
    else if (ini <= i && j <= fim) {
        a[node].v.push_back(val);
    }
    else {
        int m = (i + j) / 2;
        update(2 * node, i, m, ini, fim, val);
        update(2 * node + 1, m + 1, j, ini, fim, val);
    }
}
 
int ans[MAXN], pai[MAXN], sz[MAXN], resp;
map<pii, int> mp;
stack<int> st;
 
// DSU
 
int find(int x) {
    if (x == pai[x]) return x;
    return find(pai[x]);
}
 
void join(int a, int b) {
    a = find(a), b = find(b);
    if (sz[a] < sz[b]) {
        swap(a, b);
    }
    pai[b] = a;
    sz[a] += sz[b];
    st.push(b);
    resp--;
}
 
void rollback() {
    int at = st.top();
    st.pop();
    sz[pai[at]] -= sz[at];
    pai[at] = at;
    resp++;
}
 
//
 
void dfs(int node, int i, int j) {
    int cnt = 0;
    for (auto x : a[node].v) {
        if (find(x.first) != find(x.second)) {
            join(x.first, x.second);
            cnt++;
        }
    }
    if (i == j) {
        ans[i] = resp;
    }
    else {
        int m = (i + j) / 2;
        dfs(2 * node, i, m);
        dfs(2 * node + 1, m + 1, j);
    }
    for (int i = 0; i < cnt; i++) {
        rollback();
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, k, tipo, a, b;
    cin >> n >> m >> k;
    resp = n;
    for (int i = 1; i <= n; i++) pai[i] = i, sz[i] = 1;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        if (a > b) swap(a, b);
        mp[{a, b}] = 0;
    }
    for (int i = 1; i <= k; i++) {
        // tempo i
 
        cin >> tipo >> a >> b;
        if (a > b) swap(a, b);
        if (tipo == 1) {
            mp[{a, b}] = i;
        }
        else {
            update(1, 0, k + 1, mp[{a, b}], i - 1, {a, b});
            mp[{a, b}] = -1;
        }
    }
    for (auto x : mp) {
        if (x.second == -1) continue;
        update(1, 0, k + 1, x.second, k + 1, x.first);
    }
    dfs(1, 0, k + 1);
    for (int i = 0; i <= k; i++) cout << ans[i] << ' ';
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Eulerian Subgraphs}
\begin{lstlisting}
// Problem name: Eulerian Subgraphs
// Problem Link: https://cses.fi/problemset/task/2078
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an undirected graph that has n nodes and m edges.
// We consider subgraphs that have all nodes of the original graph and some of its edges. 
// A subgraph is called Eulerian if each node has even degree.
// Your task is to count the number of Eulerian subgraphs modulo 10 ^9+7.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int fexp(ll b, int e) {
	if (e < 0) return 1;
	ll resp = 1;
	while (e) {
		if (e&1) resp = (resp * b) % M;
		b = (b * b) % M;
		e >>= 1;
	}
	return resp;
}
 
vector<int> v[MAXN];
int vis[MAXN];
 
void dfs(int node) {
	vis[node] = 1;
	for (int x : v[node]) {
		if (!vis[x]) dfs(x);
	}
}
 
int main() { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	int cnt = 0;
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			cnt++;
			dfs(i);
		}
	}
	cout << fexp(2, m - n + cnt) << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Hamming Distance}
\begin{lstlisting}
// Problem name: Hamming Distance
// Problem Link: https://cses.fi/problemset/task/2136
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// The Hamming distance between two strings a and b of equal length is the number of positions where the strings differ.
// You are given n bit strings, each of length k and your task is to calculate the minimum Hamming distance between two strings. 

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n, k;
	cin >> n >> k;
	vector<pii> v(n);
	string s;
	for (int i = 0; i < n; i++) {
		cin >> s;
		v[i].F = stoi(s, nullptr, 2);
	}	
	int resp = k+1;
	v[0].S = resp;
	for (int i = 1; i < n; i++) {
		v[i].S = __builtin_popcount(v[0].F ^ v[i].F);
		resp = min(resp, v[i].S);
	}
	sort(v.begin(), v.end(), [&](pii a, pii b) { return a.S < b.S; } );
	for (int i = 1; i < n; i++) {
		for (int j = i+1; j < n; j++) {
			if (v[j].S < v[i].S + resp) {
				resp = min(resp, __builtin_popcount(v[j].F ^ v[i].F));
			}
			else break;
		}
	}
	cout << resp << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Houses and Schools}
\begin{lstlisting}
// Problem name: Houses and Schools
// Problem Link: https://cses.fi/problemset/task/2087
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n houses on a street, numbered 1,2,…,n. The distance of houses a and b is |a−b|. 
// You know the number of children in each house.
// Your task is to establish k schools in such a way that each school is in some house. 
// Then, each child goes to the nearest school. 
// What is the minimum total walking distance of the children if you act optimally?

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 3e3 + 5;
const int INF = 2e9;
 
ll c[MAXN][MAXN], dp[MAXN][MAXN], v[MAXN], pre[MAXN];
 
void solve(int l, int r, int ini, int fim, int k) {
    int m = (l + r) / 2;
    ll dude = 0, mn = 1e18;
    for (int i = ini; i <= min(m - 1, fim); i++) {
        if (dp[k - 1][i] + c[i][m] < mn) {
            dude = i;
            mn = dp[k - 1][i] + c[i][m];
        }
    }
    dp[k][m] = mn;
    if (m - 1 >= l)
        solve(l, m - 1, ini, dude, k);
    if (r >= m + 1)
        solve(m + 1, r, dude, fim, k);
}
 
int main () {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
        pre[i] = v[i] + pre[i - 1];
    }
 
    // calc custo normal
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            c[i][j] = c[i][j - 1] + pre[j - 1] - pre[(i + j - 1) / 2];
        }
    }
 
    // calc custo das bordas
    for (int i = 2; i <= n; i++) {
        c[0][i] = c[0][i - 1] + pre[i - 1];
    }
    for (int i = n - 1; i >= 1; i--) {
        c[i][n + 1] = c[i + 1][n + 1] + pre[n] - pre[i];
    }
    for (int i = 0; i <= n + 1; i++) {
        for (int j = 0; j <= n + 1; j++) dp[i][j] = 1e18;
    }
    dp[0][0] = 0;
    for (int i = 1; i <= k + 1; i++) 
        solve(1, n + 1, 0, n, i);
    cout << dp[k + 1][n + 1] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Knuth Division}
\begin{lstlisting}
// Problem name: Knuth Division
// Problem Link: https://cses.fi/problemset/task/2088
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given an array of n numbers, your task is to divide it into n subarrays, each of which has a single element.
// On each move, you may choose any subarray and split it into two subarrays. 
// The cost of such a move is the sum of values in the chosen subarray.
// What is the minimum total cost if you act optimally?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int v[5050], pos[5050][5050];
ll dp[5050][5050], pre[5050];
 
int main () { _
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		pre[i] = pre[i-1] + v[i];
		pos[i][i] = i;
	}
	for (int tam = 1; tam < n; tam++) {
		for (int i = 1; i+tam <= n; i++) {
			int j = i+tam;
			dp[i][j] = dp[i][pos[i][j-1]] + dp[pos[i][j-1]+1][j] + pre[j] - pre[i-1];
			pos[i][j] = pos[i][j-1];
			for (int k = pos[i][j]+1; k <= pos[i+1][j]; k++) {
				if (dp[i][k] + dp[k+1][j] + pre[j] - pre[i-1] < dp[i][j]) {
					dp[i][j] = dp[i][k] + dp[k+1][j] + pre[j] - pre[i-1];
					pos[i][j] = k;
				}
			}
		} 
	}
	cout << dp[1][n] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Meet in the Middle}
\begin{lstlisting}
// Problem name: Meet in the Middle
// Problem Link: https://cses.fi/problemset/task/1628
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an array of n numbers. In how many ways can you choose a subset of the numbers with sum x?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1010
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int main () { _
	int n, x, aux;
	cin >> n >> x;
	vector<int> v1, v2;
	for (int i = 0; i < n/2; i++) {
		cin >> aux;
		v1.pb(aux);
	} 
	for (int i = n/2; i < n; i++) {
		cin >> aux;
		v2.pb(aux);
	}
	int tam1 = n/2, tam2 = (n+1)/2, tam;
	vector<ll> resp1(1), resp2(1);
	for (int i = 0; i < tam1; i++) {
		tam = (int)resp1.size();
		for (int j = 0; j < tam; j++) resp1.pb(resp1[j] + v1[i]);
	}
	for (int i = 0; i < tam2; i++) {
		tam = (int)resp2.size();
		for (int j = 0; j < tam; j++) resp2.pb(resp2[j] + v2[i]);
	}
	sort(resp1.begin(), resp1.end());
	sort(resp2.begin(), resp2.end());
	ll ans = 0;
	for (ll a : resp1) {
		if (a > x) break;
		ll look = x-a;
		ans -= lower_bound(resp2.begin(), resp2.end(), look) - upper_bound(resp2.begin(), resp2.end(), look);
	}
	cout << ans << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Monster Game I}
\begin{lstlisting}
// Problem name: Monster Game I
// Problem Link: https://cses.fi/problemset/task/2084
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are playing a game that consists of n levels. Each level has a monster. 
// On levels 1,2,...,n−1, you can either kill or escape the monster. 
// However, on level n you must kill the final monster to win the game.
// Killing a monster takes s * f time where s is the monster's strength 
// and f is your skill factor (lower skill factor is better). After killing a monster, 
// you get a new skill factor. What is the minimum total time in which you can win the game?
// The first input line has two integers n and x: the number of levels and your initial skill factor.
// The second line has n integers s1 <= s2 <= ...,sn: each monster's strength.
// The third line has n integers f1 >= f2 >= ...,fn: your new skill factor after killing a monster.

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll LINF = 1e18;
 
// Li-Chao Tree
//
// Adiciona retas (ax+b), e computa o minimo entre as retas
// em um dado 'x'
// Cuidado com overflow!
// Se tiver overflow, tenta comprimir o 'x' ou usar
// convex hull trick
//
// O(log(MA-MI)), O(n) de memoria
// 59ba68
 
template<ll MI = ll(-1e9), ll MA = ll(1e9)> struct lichao {
	struct line {
		ll a, b;
		array<int, 2> ch;
		line(ll a_ = 0, ll b_ = LINF) :
			a(a_), b(b_), ch({-1, -1}) {}
		ll operator ()(ll x) { return a*x + b; }
	};
	vector<line> ln;
 
	int ch(int p, int d) {
		if (ln[p].ch[d] == -1) {
			ln[p].ch[d] = ln.size();
			ln.emplace_back();
		}
		return ln[p].ch[d];
	}
	lichao() { ln.emplace_back(); }
 
	void add(line s, ll l=MI, ll r=MA, int p=0) {
		ll m = (l+r)/2;
		bool L = s(l) < ln[p](l);
		bool M = s(m) < ln[p](m);
		bool R = s(r) < ln[p](r);
		if (M) swap(ln[p], s), swap(ln[p].ch, s.ch);
		if (s.b == LINF) return;
		if (L != M) add(s, l, m-1, ch(p, 0));
		else if (R != M) add(s, m+1, r, ch(p, 1));
	}
	ll query(int x, ll l=MI, ll r=MA, int p=0) {
		ll m = (l+r)/2, ret = ln[p](x);
		if (ret == LINF) return ret;
		if (x < m) return min(ret, query(x, l, m-1, ch(p, 0)));
		return min(ret, query(x, m+1, r, ch(p, 1)));
	}
};
 
int s[MAXN], f[MAXN];
ll dp[MAXN];
 
int main () {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, x;
    cin >> n >> x;
    for (int i = 1; i <= n; i++) cin >> s[i];
    for (int i = 1; i <= n; i++) cin >> f[i];
    lichao<> ber;
    ber.add(lichao<>::line(x, 0));
    for (int i = 1; i <= n; i++) {
        dp[i] = ber.query(s[i]);
        ber.add(lichao<>::line(f[i], dp[i]));
    }
    cout << dp[n] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Monster Game II}
\begin{lstlisting}
// Problem name: Monster Game II
// Problem Link: https://cses.fi/problemset/task/2085
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are playing a game that consists of n levels. Each level has a monster. 
// On levels 1,2,...,n−1, you can either kill or escape the monster. 
// However, on level n you must kill the final monster to win the game.
// Killing a monster takes s * f time where s is the monster's strength 
// and f is your skill factor (lower skill factor is better). After killing a monster, 
// you get a new skill factor. What is the minimum total time in which you can win the game?
// The first input line has two integers n and x: the number of levels and your initial skill factor.
// The second line has n integers s1, s2,...,sn: each monster's strength.
// The third line has n integers f1, f2, ...,fn: your new skill factor after killing a monster.

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll LINF = 1e18;
 
// Li-Chao Tree
//
// Adiciona retas (ax+b), e computa o minimo entre as retas
// em um dado 'x'
// Cuidado com overflow!
// Se tiver overflow, tenta comprimir o 'x' ou usar
// convex hull trick
//
// O(log(MA-MI)), O(n) de memoria
// 59ba68
 
template<ll MI = ll(-1e9), ll MA = ll(1e9)> struct lichao {
	struct line {
		ll a, b;
		array<int, 2> ch;
		line(ll a_ = 0, ll b_ = LINF) :
			a(a_), b(b_), ch({-1, -1}) {}
		ll operator ()(ll x) { return a*x + b; }
	};
	vector<line> ln;
 
	int ch(int p, int d) {
		if (ln[p].ch[d] == -1) {
			ln[p].ch[d] = ln.size();
			ln.emplace_back();
		}
		return ln[p].ch[d];
	}
	lichao() { ln.emplace_back(); }
 
	void add(line s, ll l=MI, ll r=MA, int p=0) {
		ll m = (l+r)/2;
		bool L = s(l) < ln[p](l);
		bool M = s(m) < ln[p](m);
		bool R = s(r) < ln[p](r);
		if (M) swap(ln[p], s), swap(ln[p].ch, s.ch);
		if (s.b == LINF) return;
		if (L != M) add(s, l, m-1, ch(p, 0));
		else if (R != M) add(s, m+1, r, ch(p, 1));
	}
	ll query(int x, ll l=MI, ll r=MA, int p=0) {
		ll m = (l+r)/2, ret = ln[p](x);
		if (ret == LINF) return ret;
		if (x < m) return min(ret, query(x, l, m-1, ch(p, 0)));
		return min(ret, query(x, m+1, r, ch(p, 1)));
	}
};
 
int s[MAXN], f[MAXN];
ll dp[MAXN];
 
int main () {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, x;
    cin >> n >> x;
    for (int i = 1; i <= n; i++) cin >> s[i];
    for (int i = 1; i <= n; i++) cin >> f[i];
    lichao<> ber;
    ber.add(lichao<>::line(x, 0));
    for (int i = 1; i <= n; i++) {
        dp[i] = ber.query(s[i]);
        ber.add(lichao<>::line(f[i], dp[i]));
    }
    cout << dp[n] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Necessary Cities}
\begin{lstlisting}
// Problem name: Necessary Cities
// Problem Link: https://cses.fi/problemset/task/2077
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n cities and m roads between them. There is a route between any two cities.
// A city is called necessary if there is no route between some other two cities after removing 
// that city (and adjacent roads). Your task is to find all necessary cities.


#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 1e18;
 
vector<int> v[MAXN];
int low[MAXN], nec[MAXN], cnt = 0, vis[MAXN];
 
void dfs(int node, int pai) {
	vis[node] = ++cnt;
	low[node] = cnt;
	int filhos = 0;
	for (int x : v[node]) {
		if (!vis[x]) {
			filhos++;
			dfs(x, node);
			low[node] = min(low[node], low[x]);
		}
		else if (x != pai) low[node] = min(low[node], vis[x]);
	}
	if (node == 1) nec[node] = (filhos > 1);
	else if (low[node] >= vis[pai] && pai > 1) nec[pai] = 1;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	dfs(1, -1);
	vector<int> ans;
	for (int i = 1; i <= n; i++) 
		if (nec[i]) ans.push_back(i);
	cout << ans.size() << '\n';
	for (auto x : ans) cout << x << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Necessary Roads}
\begin{lstlisting}
// Problem name: Necessary Roads
// Problem Link: https://cses.fi/problemset/task/2076
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n cities and m roads between them. There is a route between any two cities.
// A road is called necessary if there is no route between some two cities after removing that road. 
// Your task is to find all necessary roads.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 1e18;
 
vector<int> v[MAXN];
vector<pii> edges;
int vis[MAXN], dp[MAXN], dep[MAXN];
 
void dfs(int node, int pai) {
	dep[node] = dep[pai] + 1;
	vis[node] = 1;
	for (int x : v[node]) {
		if (x == pai) continue;
		if (vis[x]) {
			if (dep[node] > dep[x]) dp[node]--;
			else dp[node]++;
		}
		else {
			dfs(x, node);
			dp[node] += dp[x];
		}
	}
	if (!dp[node] && node > 1) edges.emplace_back(node, pai);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].push_back(b);
		v[b].push_back(a);
	}
	dfs(1, -1);
	cout << edges.size() << '\n';
	for (auto x : edges) cout << x.first << ' ' << x.second << '\n';
    return 0;
}
\end{lstlisting}

\subsection{New Roads Queries}
\begin{lstlisting}
// Problem name: New Roads Queries
// Problem Link: https://cses.fi/problemset/task/2101
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n cities in Byteland but no roads between them. However, each day, 
// a new road will be built. There will be a total of m roads.
// Your task is to process q queries of the form: "after how many days 
// can we travel from city a to city b for the first time?"

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
int sz[MAXN], pai[MAXN], te[MAXN];
 
int find(int x) {
    if (x == pai[x]) return x;
    return find(pai[x]);
}
 
void join(int a, int b, int t) {
    a = find(a), b = find(b);
    if (a == b) return;
    if (sz[a] < sz[b]) swap(a, b);
    pai[b] = a;
    if (sz[a] == sz[b]) sz[a]++;
    te[b] = t;
}
 
int query(int a, int b) {
    int ans = 0;
    if (find(a) != find(b)) return -1;
    while (a != b) {
        if (te[a] > te[b]) {
            ans = te[b];
            b = pai[b];
        }
        else {
            ans = te[a];
            a = pai[a];
        }
    }
    return ans;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, q, a, b;
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++) pai[i] = i, sz[i] = 1, te[i] = m + 1;
    for (int i = 1; i <= m; i++) {
        cin >> a >> b;
        join(a, b, i);
    }
    for (int i = 0; i < q; i++) {
        cin >> a >> b;
        cout << query(a, b) << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{One Bit Positions}
\begin{lstlisting}
// Problem name: One Bit Positions
// Problem Link: https://cses.fi/problemset/task/2112
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a binary string of length n and your task is to calculate for every k
//  between 1...n−1 the number of ways we can choose two positions i and j such that i−j=k 
// and there is a one-bit at both positions.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
using cd = complex<double>;
const double PI = acos(-1);
 
void fft(vector<cd> & a, bool invert) {
    int n = a.size();
 
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;
 
        if (i < j)
            swap(a[i], a[j]);
    }
 
    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            cd w(1);
            for (int j = 0; j < len / 2; j++) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
 
    if (invert) {
        for (cd & x : a)
            x /= n;
    }
}
 
vector<ll> multiply(vector<int> const& a, vector<int> const& b) {
    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n < (int)(a.size() + b.size())) 
        n <<= 1;
    fa.resize(n);
    fb.resize(n);
 
    fft(fa, false);
    fft(fb, false);
    for (int i = 0; i < n; i++)
        fa[i] *= fb[i];
    fft(fa, true);
 
    vector<ll> result(n);
    for (int i = 0; i < n; i++)
        result[i] = round(fa[i].real());
    return result;
}
 
int main() { _
	string s;
	cin >> s;
	int n = (int)s.size();
	vector<int> v(n), w(n);
	for (int i = 0; i < n; i++) {
		if (s[i] == '1') {
			v[i] = 1;
			w[n-i-1] = 1;
		}
	}
	vector<ll> ans = multiply(v, w);
	for (int i = n; i < 2*n-1; i++) cout << ans[i] << ' ';
	cout << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Parcel Delivery}
\begin{lstlisting}
// Problem name: Parcel Delivery
// Problem Link: https://cses.fi/problemset/task/2121
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n cities and m routes through which parcels can be carried from one city to another city. ]
// For each route, you know the maximum number of parcels and the cost of a single parcel.
// You want to send k parcels from Syrjälä to Lehmälä. What is the cheapest way to do that?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
// MinCostMaxFlow
//
// min_cost_flow(s, t, f) computa o par (fluxo, custo)
// com max(fluxo) <= f que tenha min(custo)
// min_cost_flow(s, t) -> Fluxo maximo de custo minimo de s pra t
// Se for um dag, da pra substituir o SPFA por uma DP pra nao
// para O(nm) no comeco
// Se nao tiver aresta com custo negativo, nao precisa do SPFA
//
// O(nm + f * m log n)
// 697b4c
 
template<typename T = int> struct mcmf {
	struct edge {
		int to, rev, flow, cap; // para, id da reversa, fluxo, capacidade
		bool res; // se eh reversa
		T cost; // custo da unidade de fluxo
		edge() : to(0), rev(0), flow(0), cap(0), cost(0), res(false) {}
		edge(int to_, int rev_, int flow_, int cap_, T cost_, bool res_)
			: to(to_), rev(rev_), flow(flow_), cap(cap_), res(res_), cost(cost_) {}
	};
 
	vector<vector<edge>> g;
	vector<int> par_idx, par;
	T inf;
	vector<T> dist;
 
	mcmf(int n) : g(n), par_idx(n), par(n), inf(numeric_limits<T>::max()/3) {}
 
	void add(int u, int v, int w, T cost) { // de u pra v com cap w e custo cost
		edge a = edge(v, g[v].size(), 0, w, cost, false);
		edge b = edge(u, g[u].size(), 0, 0, -cost, true);
 
		g[u].push_back(a);
		g[v].push_back(b);
	}
 
	vector<T> spfa(int s) { // nao precisa se nao tiver custo negativo
		deque<int> q;
		vector<bool> is_inside(g.size(), 0);
		dist = vector<T>(g.size(), inf);
 
		dist[s] = 0;
		q.push_back(s);
		is_inside[s] = true;
 
		while (!q.empty()) {
			int v = q.front();
			q.pop_front();
			is_inside[v] = false;
 
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
 
					if (is_inside[to]) continue;
					if (!q.empty() and dist[to] > dist[q.front()]) q.push_back(to);
					else q.push_front(to);
					is_inside[to] = true;
				}
			}
		}
		return dist;
	}
	bool dijkstra(int s, int t, vector<T>& pot) {
		priority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> q;
		dist = vector<T>(g.size(), inf);
		dist[s] = 0;
		q.emplace(0, s);
		while (q.size()) {
			auto [d, v] = q.top();
			q.pop();
			if (dist[v] < d) continue;
			for (int i = 0; i < g[v].size(); i++) {
				auto [to, rev, flow, cap, res, cost] = g[v][i];
				cost += pot[v] - pot[to];
				if (flow < cap and dist[v] + cost < dist[to]) {
					dist[to] = dist[v] + cost;
					q.emplace(dist[to], to);
					par_idx[to] = i, par[to] = v;
				}
			}
		}
		return dist[t] < inf;
	}
 
	pair<int, T> min_cost_flow(int s, int t, int flow) {
		vector<T> pot(g.size(), 0);
		pot = spfa(s); // mudar algoritmo de caminho minimo aqui
 
		int f = 0;
		T ret = 0;
		while (f < flow and dijkstra(s, t, pot)) {
			for (int i = 0; i < g.size(); i++)
				if (dist[i] < inf) pot[i] += dist[i];
 
			int mn_flow = flow - f, u = t;
			while (u != s){
				mn_flow = min(mn_flow,
					g[par[u]][par_idx[u]].cap - g[par[u]][par_idx[u]].flow);
				u = par[u];
			}
 
			ret += pot[t] * mn_flow;
 
			u = t;
			while (u != s) {
				g[par[u]][par_idx[u]].flow += mn_flow;
				g[u][g[par[u]][par_idx[u]].rev].flow -= mn_flow;
				u = par[u];
			}
 
			f += mn_flow;
		}
 
		return make_pair(f, ret);
	}
 
	// Opcional: retorna as arestas originais por onde passa flow = cap
	vector<pair<int,int>> recover() {
		vector<pair<int,int>> used;
		for (int i = 0; i < g.size(); i++) for (edge e : g[i])
			if(e.flow == e.cap && !e.res) used.push_back({i, e.to});
		return used;
	}
};
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, k, a, b, c, d;
    cin >> n >> m >> k;
    mcmf ber(n + 2);
    ber.add(0, 1, k, 0);
    ber.add(n, n + 1, k, 0);
    for (int i = 0; i < m; i++) {
        cin >> a >> b >> c >> d;
        ber.add(a, b, c, d);
    }
    pii ans = ber.min_cost_flow(0, n + 1, ber.inf);
    if (ans.first < k) cout << "-1\n";
    else cout << ans.second << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Reachability Queries}
\begin{lstlisting}
// Problem name: Reachability Queries
// Problem Link: https://cses.fi/problemset/task/2143
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 50005
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
bitset<MAXN> bit[MAXN];
vector<int> v[MAXN], w[MAXN], nv[MAXN], ord;
int vis[MAXN], comp[MAXN], cnt = 0;
 
void dfs1(int node) {
	vis[node] = 1;
	for (int x : v[node])
		if (!vis[x]) dfs1(x);
	ord.pb(node);
}
 
void dfs2(int node) {
	vis[node] = 1;
	comp[node] = cnt;
	for (int x : w[node])
		if (!vis[x]) dfs2(x);
}
 
void dfs3(int node) {
	vis[node] = 1;
	for (int x : nv[node]) {
		if (!vis[x]) dfs3(x);
		bit[node] |= bit[x];
	}
}
 
int main () { _
	int n, m, q, a, b;
	cin >> n >> m >> q;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].pb(b);
		w[b].pb(a);
	}
	for (int i = 1; i <= n; i++) {
		bit[i][i] = 1;
		if (!vis[i]) dfs1(i);
	}
	memset(vis, 0, sizeof(vis));
	reverse(ord.begin(), ord.end());
	for (int x : ord) {
		if (!vis[x]) {
			cnt++;
			dfs2(x);
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int x : v[i]) if (comp[i] != comp[x]) nv[comp[i]].pb(comp[x]);
	}
	memset(vis, 0, sizeof(vis));
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) dfs3(i);
	}
	for (int i = 0; i < q; i++) {
		cin >> a >> b;
		if (bit[comp[a]][comp[b]]) cout << "YES\n";
		else cout << "NO\n";
	}
    return 0;
}
\end{lstlisting}

\subsection{Reachable Nodes}
\begin{lstlisting}
// Problem name: Reachable Nodes
// Problem Link: https://cses.fi/problemset/task/2138
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A directed acyclic graph consists of n nodes and m edges. The nodes are numbered 1,2,...n.
// Calculate for each node the number of nodes you can reach from that node (including the node itself).

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 50100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
vector<int> v[MAXN], ord;
int check[MAXN];
bitset<MAXN> bits[MAXN];
 
void dfs(int node) {
	check[node] = 1;
	for (int x : v[node]) 
		if (!check[x]) dfs(x);
	ord.pb(node);
}
 
void dfs2(int node) {
	for (int x : v[node]) bits[node] |= bits[x];
}
 
int main() { _
	int n, m, a, b;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].pb(b);
	}
	for (int i = 1; i <= n; i++) {
		if (!check[i]) dfs(i);
		bits[i].set(i);
	}
	for (int x : ord) dfs2(x);
	for (int i = 1; i <= n; i++) cout << bits[i].count() << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Reversals and Sums}
\begin{lstlisting}
// Problem name: Reversals and Sums
// Problem Link: https://cses.fi/problemset/task/2074
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given an array of n integers, you have to process following operations:
//     reverse a subarray
//     calculate the sum of values in a subarray

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const ll INF = 2e18;
 
struct node {
    node *L, *R;
    int prio, sz, val; 
    ll sum;
    bool rev;
    node (int _val = 0) {
        L = 0, R = 0, prio = rng(), sz = 1, val = sum = _val, rev = false;
    }
};
 
int size(node *treap) {
    if (!treap) return 0;
    return treap->sz;
}
 
ll sum(node *treap) {
    if (!treap) return 0ll;
    return treap->sum;
}
 
void push(node *treap) {
    if (treap && treap->rev) {
        treap->rev = false;
        swap(treap->L, treap->R);
        if (treap->L) treap->L->rev ^= true;
        if (treap->R) treap->R->rev ^= true;
    }
}
 
void recalc(node *&treap) {
    if (!treap) return;
    treap->sz = size(treap->L) + size(treap->R) + 1;
    treap->sum = sum(treap->L) + sum(treap->R) + treap->val;
}
 
void split(node *treap, node *&L, node *&R, int k) {
    if (!treap) {
        L = R = 0;
    }
    else {
        push(treap);
        if (size(treap->L) >= k) {
            split(treap->L, L, treap->L, k);
            R = treap;
        }
        else {
            split(treap->R, treap->R, R, k - size(treap->L) - 1);
            L = treap;
        }
        recalc(treap);
    }
}
 
void merge(node *&treap, node *L, node *R) {
    if (!L) treap = R;
    else if (!R) treap = L;
    else {
        push(L), push(R);
        if (L->prio > R->prio) {
            merge(L->R, L->R, R);
            treap = L;
        }
        else {
            merge(R->L, L, R->L);
            treap = R;
        }
        recalc(treap);
    }
}
 
ll query(node *treap, int k) {
    if (!treap) return 0;
    else {
        push(treap);
        if (size(treap->L) >= k) {
            return query(treap->L, k);
        }
        else {
            return sum(treap->L) + query(treap->R, k - size(treap->L) - 1) + treap->val;
        }
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, tipo, l, r;
    cin >> n >> m;
    node *root = 0;
    for (int i = 0; i < n; i++) {
        cin >> tipo;
        merge(root, root, new node(tipo));
    }
    for (int i = 0; i < m; i++) {
        node *a, *b, *c;
        cin >> tipo >> l >> r;
        if (tipo == 1) {
            split(root, a, b, l - 1);
            split(b, b, c, r - l + 1);
            b->rev ^= true;
            merge(root, a, b);
            merge(root, root, c);
        }
        else {
            cout << query(root, r) - query(root, l - 1) << '\n';
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{Signal Processing}
\begin{lstlisting}
// Problem name: Signal Processing
// Problem Link: https://cses.fi/problemset/task/2113
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given two integer sequences: a signal and a mask. 
// Your task is to process the signal by moving the mask through the signal from left to right. 
// At each mask position calculate the sum of products of aligned signal and mask values in the part 
// where the signal and the mask overlap.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
using cd = complex<double>;
const double PI = acos(-1);
 
void fft(vector<cd> & a, bool invert) {
    int n = a.size();
 
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1)
            j ^= bit;
        j ^= bit;
 
        if (i < j)
            swap(a[i], a[j]);
    }
 
    for (int len = 2; len <= n; len <<= 1) {
        double ang = 2 * PI / len * (invert ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            cd w(1);
            for (int j = 0; j < len / 2; j++) {
                cd u = a[i+j], v = a[i+j+len/2] * w;
                a[i+j] = u + v;
                a[i+j+len/2] = u - v;
                w *= wlen;
            }
        }
    }
 
    if (invert) {
        for (cd & x : a)
            x /= n;
    }
}
 
vector<ll> multiply(vector<int> const& a, vector<int> const& b) {
    vector<cd> fa(a.begin(), a.end()), fb(b.begin(), b.end());
    int n = 1;
    while (n < (int)(a.size() + b.size())) 
        n <<= 1;
    fa.resize(n);
    fb.resize(n);
 
    fft(fa, false);
    fft(fb, false);
    for (int i = 0; i < n; i++)
        fa[i] *= fb[i];
    fft(fa, true);
 
    vector<ll> result(n);
    for (int i = 0; i < n; i++)
        result[i] = round(fa[i].real());
    return result;
}
 
int main() { _
	int n, m;
	cin >> n >> m;
	vector<int> v(n+m), w(n+m);
	for (int i = m-1; i < n+m-1; i++) 
		cin >> v[i];
	for (int i = n+m-1; i > n-1; i--) 
		cin >> w[i];
	vector<ll> ans = multiply(v, w);
	for (int i = n+m-1; i < 2* (n+m-1); i++) cout << ans[i] << ' ';
	cout << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Subarray Squares}
\begin{lstlisting}
// Problem name: Subarray Squares
// Problem Link: https://cses.fi/problemset/task/2086
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given an array of n elements, your task is to divide into k subarrays. 
// The cost of each subarray is the square of the sum of the values in the subarray. 
// What is the minimum total cost if you act optimally?

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 3e3 + 5;
const int INF = 2e9;
 
ll dp[MAXN][MAXN], v[MAXN];
 
ll c(int a, int b) { return (v[b] - v[a - 1]) * (v[b] - v[a - 1]);}
 
void solve(int l, int r, int ini, int fim, int k) {
    int m = (l + r) / 2;
    ll dude = -1, mn = 1e18;
    for (int i = ini; i <= min(m - 1, fim); i++) {
        if (dp[k - 1][i] + c(i + 1, m) < mn) {
            dude = i;
            mn = dp[k - 1][i] + c(i + 1, m);
        }
    }
    dp[k][m] = mn;
    if (m - 1 >= l)
        solve(l, m - 1, ini, dude, k);
    if (r >= m + 1)
        solve(m + 1, r, dude, fim, k);
}
 
int main () {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
        v[i] += v[i - 1];
    }
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n; j++) dp[i][j] = 1e18;
    }
    dp[0][0] = 0;
    for (int i = 1; i <= k; i++) 
        solve(1, n, 0, n, i);
    cout << dp[k][n] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Substring Reversals}
\begin{lstlisting}
// Problem name: Substring Reversals
// Problem Link: https://cses.fi/problemset/task/2073
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a string, your task is to process operations where you reverse a substring of the string. 
// What is the final string after all the operations?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const ll INF = 2e18;
 
struct node {
    node *L, *R;
    int prio, sz;
    char c;
    bool rev;
    node (char _c) {
        L = 0, R = 0, prio = rng(), sz = 1, c = _c, rev = false;
    }
};
 
int size(node *treap) {
    if (!treap) return 0;
    return treap->sz;
}
 
void push(node *treap) {
    if (treap && treap->rev) {
        treap->rev = false;
        swap(treap->L, treap->R);
        if (treap->L) treap->L->rev ^= true;
        if (treap->R) treap->R->rev ^= true;
    }
}
 
void recalc(node *&treap) {
    if (!treap) return;
    treap->sz = size(treap->L) + size(treap->R) + 1;
}
 
void split(node *treap, node *&L, node *&R, int k) {
    if (!treap) {
        L = R = 0;
    }
    else {
        push(treap);
        if (size(treap->L) >= k) {
            split(treap->L, L, treap->L, k);
            R = treap;
        }
        else {
            split(treap->R, treap->R, R, k - size(treap->L) - 1);
            L = treap;
        }
        recalc(treap);
    }
}
 
void merge(node *&treap, node *L, node *R) {
    if (!L) treap = R;
    else if (!R) treap = L;
    else {
        push(L), push(R);
        if (L->prio > R->prio) {
            merge(L->R, L->R, R);
            treap = L;
        }
        else {
            merge(R->L, L, R->L);
            treap = R;
        }
        recalc(treap);
    }
}
 
void print(node *treap) {
    if (!treap) return;
    push(treap);
    print(treap->L);
    cout << treap->c;
    print(treap->R);
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, l, r;
    string s;
    cin >> n >> m >> s;
    node *root = 0;
    for (int i = 0; i < n; i++) {
        merge(root, root, new node(s[i]));
    }
    for (int i = 0; i < m; i++) {
        cin >> l >> r;
        node *a, *b, *c;
        split(root, a, b, l - 1);
        split(b, b, c, r - l + 1);
        b->rev ^= true;
        merge(root, a, b);
        merge(root, root, c);
    }
    print(root);
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Task Assignment}
\begin{lstlisting}
// Problem name: Task Assignment
// Problem Link: https://cses.fi/problemset/task/2129
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A company has n employees and there are n tasks that need to be done. 
// We know for each employee the cost of carrying out each task. Every employee should be assigned to exactly one task. 
// What is the minimum total cost if we assign the tasks optimally and how could they be assigned?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e4 + 5;
const ll INF = 2e18;
 
template<typename T = int> struct hungarian {
	int n;
	vector<vector<T>> a;
	vector<T> u, v;
	vector<int> p, way;
	T inf;
 
	hungarian(int n_) : n(n_), u(n+1), v(n+1), p(n+1), way(n+1) {
		a = vector<vector<T>>(n, vector<T>(n));
		inf = numeric_limits<T>::max();
	}
	pair<T, vector<int>> assignment() {
		for (int i = 1; i <= n; i++) {
			p[0] = i;
			int j0 = 0;
			vector<T> minv(n+1, inf);
			vector<int> used(n+1, 0);
			do {
				used[j0] = true;
				int i0 = p[j0], j1 = -1;
				T delta = inf;
				for (int j = 1; j <= n; j++) if (!used[j]) {
					T cur = a[i0-1][j-1] - u[i0] - v[j];
					if (cur < minv[j]) minv[j] = cur, way[j] = j0;
					if (minv[j] < delta) delta = minv[j], j1 = j;
				}
				for (int j = 0; j <= n; j++)
					if (used[j]) u[p[j]] += delta, v[j] -= delta;
					else minv[j] -= delta;
				j0 = j1;
			} while (p[j0] != 0);
			do {
				int j1 = way[j0];
				p[j0] = p[j1];
				j0 = j1;
			} while (j0);
		}
		vector<int> ans(n);
		for (int j = 1; j <= n; j++) ans[p[j]-1] = j-1;
		return make_pair(-v[0], ans);
	}
};
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n;
    cin >> n;
    hungarian ber(n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) cin >> ber.a[i][j];
    }
    pair<int, vector<int>> ans = ber.assignment();
    cout << ans.first << '\n';
    for (int i = 0; i < n; i++) {
        cout << i + 1 << ' ' << ans.second[i] + 1 << '\n';
    }
    return 0;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% CSES - Dynamic Programming
%
%%%%%%%%%%%%%%%%%%%%

\section{CSES - Dynamic Programming}

\subsection{Array Description}
\begin{lstlisting}
// Problem name: Array Description
// Problem Link: https://cses.fi/problemset/task/1746
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, m;
    cin >> n >> m;
    vector<int> v(n);
    for (int i = 0; i < n; i++) cin >> v[i];
    vector<vector<ll>> dp(n+1, vector<ll> (m+2, 0));
    for (int i = 1; i <= m; i++) {
        if (!v[0] || v[0] == i) dp[0][i] = 1;
    }    
    for (int i = 1; i < n; i++) {
        for (int j = 1; j <= m; j++) {
            if (!v[i] || v[i] == j) {
                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1]) % M;
            }
        }
    }
    int ans = 0;
    for (int i = 1; i <= m; i++) {
        if (v[n-1] == i || !v[n-1]) {
            ans += dp[n-1][i];
            if (ans >= M) ans -= M;
        }
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Book Shop}
\begin{lstlisting}
// Problem name: Book Shop
// Problem Link: https://cses.fi/problemset/task/1158
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, x;
    cin >> n >> x;
    vector<int> h(n), v(n);
    for (int i = 0; i < n; i++) cin >> h[i];
    for (int i = 0; i < n; i++) cin >> v[i];
    vector<vector<int>> dp(n+1, vector<int> (x+1, -1));
    dp[0][x] = 0;
    for (int i = 0; i < n; i++) {
        for (int j = x; j >= 0; j--) {
            if (dp[i][j] >= 0) {
                dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
                if (j >= h[i]) dp[i+1][j-h[i]] = max(dp[i+1][j-h[i]], dp[i][j] + v[i]);
            }
        }
    }
    int ans = 0;
    for (int i = x; i >= 0; i--) ans = max(ans, dp[n][i]);
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Coin Combinations I}
\begin{lstlisting}
// Problem name: Coin Combinations I
// Problem Link: https://cses.fi/problemset/task/1635
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
 
const int mod = 1e9 + 7;
int dp[MAXN], n, x, v[105];
 
int coin(int soma) {
    if (dp[soma] >= 0) return dp[soma];
    int resp = 0;
    for (int i = 1; i <= n; i++) {
        if (soma - v[i] >= 0) {
            resp += coin(soma-v[i]);
            resp %= mod;
        }
        else break;
    }
    return dp[soma] = resp;
}
 
int main () { _
    memset(dp, -1, sizeof(dp));
    cin >> n >> x;
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
    }
    sort(v+1, v+n+1);
    dp[0] = 1;
    cout << coin(x) << endl;
    return 0;
}
\end{lstlisting}

\subsection{Coin Combinations II}
\begin{lstlisting}
// Problem name: Coin Combinations II
// Problem Link: https://cses.fi/problemset/task/1636
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, x;
    cin >> n >> x;
    vector<int> coin(n), dp(x+1);
    for (int i = 0; i < n; i++) {
        cin >> coin[i];
    }
    sort(coin.begin(), coin.end());
    dp[0] = 1;
    for (int i = 0; i < n; i++) {
        int atual = coin[i];
        for (int j = atual; j <= x; j++) {
            dp[j] = dp[j] + dp[j-atual];
            if (dp[j] >= M) dp[j] -= M;
        }
    }
    cout << dp[x] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Counting Numbers}
\begin{lstlisting}
// Problem name: Counting Numbers
// Problem Link: https://cses.fi/problemset/task/2220
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to count the number of integers between a and b where no two adjacent digits are the same.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
char cnum[10] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
string a, b;
ll dp[20][11][2][2][2];
// pos na string, ultimo digito, flag de ultrapassar, flag pra qual string estamos vendo, flag pra se ja teve num > 0
 
ll count(int pos, int ult, bool flag, bool pri, bool ja) {
    ll &resp = dp[pos][ult][flag][pri][ja];
    if (resp >= 0) return resp;
    if ((pri ? pos == (int)a.size() : pos == (int)b.size())) return 1ll;
    ll ans = 0;
    if (pri) {
        for (int i = 0; i < 10; i++) {
            if (cnum[i] > a[pos] && flag) break;
            if (cnum[i] == a[pos] && i != ult) {
                ans += count(pos+1, (!i && !ja ? 10 : i), flag, pri, (!i ? ja : true));
            }
            else if ((cnum[i] < a[pos] || !flag) && i != ult) {
                ans += count(pos+1, (!i && !ja ? 10 : i), false, pri, (!i ? ja : true));
            }
        }
    }
    else {
        for (int i = 0; i < 10; i++) {
            if (cnum[i] > b[pos] && flag) break;
            if (cnum[i] == b[pos] && i != ult) {
                ans += count(pos+1, (!i && !ja ? 10 : i), flag, pri, (!i ? ja : true));
            }
            else if ((cnum[i] < b[pos] || !flag) && i != ult) {
                ans += count(pos+1, (!i && !ja ? 10 : i), false, pri, (!i ? ja : true));
            }
        }
    }
    return resp = ans;
}
 
int main () { _
    ll c;
    memset(dp, -1, sizeof(dp));
    cin >> c >> b;
    c--;
    a = to_string(c);
    ll ans = count(0, 10, true, false, false) - (c >= 0 ? count(0, 10, true, true, false) : 0ll);
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Counting Tilings}
\begin{lstlisting}
// Problem name: Counting Tilings
// Problem Link: https://cses.fi/problemset/task/2181
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to count the number of ways you can fill an n×m grid using 1×2 and 2×1 tiles

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, m;
    cin >> n >> m;
    vector<vector<int>> v((1<<n)+2);
    vector<vector<int>> dp(1010, vector<int> (1<<(n+1)));
    for (int i = 0; i < (1<<n); i++) {
        for (int j = 0; j < (1<<n); j++) {
            int count = 0;
            bool valid = true;
            for (int k = 0; k < n; k++) {
                if ((i & (1<<k))) {
                    if ((j & (1<<k))) valid = false;
                    valid &= !(count&1);
                    count = 0;
                }
                else if (j & (1<<k)) {
                    valid &= !(count&1);
                    count = 0;
                }
                else count++;
            }
            valid &= !(count&1);
            if (valid) v[i].pb(j);
        }
    }
    for (int i = 0; i < (int)v[0].size(); i++) {
        dp[1][v[0][i]] = 1;
    }
    for (int i = 2; i <= m; i++) {
        for (int j = 0; j < (1<<n); j++) {
            for (int k = 0; k < (int)v[j].size(); k++) {
                int l = v[j][k];
                dp[i][j] += dp[i-1][l];
                if (dp[i][j] >= M) dp[i][j] -= M;
            }
        }
    }
    cout << dp[m][0] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Counting Towers}
\begin{lstlisting}
// Problem name: Counting Towers
// Problem Link: https://cses.fi/problemset/task/2413
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int t;
    cin >> t;
    vector<vector<ll>> dp(1e6+5, vector<ll> (5));
    dp[1][0] = 2, dp[1][1] = dp[1][2] = dp[1][3] = dp[1][4] = 1;
    for (int i = 1; i <= 1e6; i++) {
        dp[i+1][0] = (2*dp[i][0] + dp[i][1] + dp[i][2] + dp[i][3] + dp[i][4]) % M;
        dp[i+1][1] = (dp[i][0] + dp[i][1] + dp[i][2] + dp[i][3]) % M;
        dp[i+1][2] = dp[i+1][1];
        dp[i+1][3] = (dp[i][0] + dp[i][1] + dp[i][2] + dp[i][3]) % M;
        dp[i+1][4] = (dp[i][0] + dp[i][4]) % M;
    }
    while (t--) {
        int n;
        cin >> n;
        cout << dp[n][0] << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{Dice Combinations}
\begin{lstlisting}
// Problem name: Dice Combinations
// Problem Link: https://cses.fi/problemset/task/1633
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
 
using namespace std;
 
const int mod = 1e9 + 7;
int dp[1000005];
 
int dice(int n) {
    int resp = 0;
 
    // caso base
    if (n == 0) return 1;
 
    // se ja calculamos a dp
    if (dp[n] > 0) {
        return dp[n];
    }
    for (int i = 1; i<= 6; i++) {
        if (n - i >= 0) {
            resp += dice(n-i);
 
            // lembrar de tirar o modulo
            resp %= mod;
        }
    }
    return dp[n] = resp;
}
 
int main () {
    int n;
    cin >> n;
    cout << dice(n) << endl;
    return 0;
}
\end{lstlisting}

\subsection{Edit Distance}
\begin{lstlisting}
// Problem name: Edit Distance
// Problem Link: https://cses.fi/problemset/task/1639
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// The edit distance between two strings is the minimum number of operations required to transform one string into the other.
// The allowed operations are:
//     Add one character to the string.
//     Remove one character from the string.
//     Replace one character in the string.
// For example, the edit distance between LOVE and MOVIE is 2, because you can first replace L with M, and then add I.
// Your task is to calculate the edit distance between two strings.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    string a, b;
    cin >> a >> b;
    int tama = (int)a.size(), tamb = (int)b.size();
    vector<vector<int>> dp(5050, vector<int> (5050, 10000));
    dp[tama][tamb] = 0;
    for (int i = tama; i >= 0; i--) {
        for (int j = tamb; j >= 0; j--) {
            dp[i][j] = min(dp[i][j], (a[i] != b[j]) + dp[i+1][j+1]);
            dp[i][j] = min(dp[i][j], 1 + dp[i+1][j]);
            dp[i][j] = min(dp[i][j], 1 + dp[i][j+1]);
        }
    }
    cout << dp[0][0] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Elevator Rides}
\begin{lstlisting}
// Problem name: Elevator Rides
// Problem Link: https://cses.fi/problemset/task/1653
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n people who want to get to the top of a building which has only one elevator. 
// You know the weight of each person and the maximum allowed weight in the elevator. 
// What is the minimum number of elevator rides?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, x;
    cin >> n >> x;
    vector<int> v(n);
    for (int i = 0; i < n; i++) cin >> v[i];
    vector<pii> dp((1<<21), {n+1, 0});
    dp[0] = {0, 0};
    for (int i = 1; i < (1 << n); i++) {
        for (int j = 0; j < n; j++) {
            if (i & (1<<j)) {
                pii next = dp[i ^(1<<j)];
                if (next.S + v[j] > x) {
                    next.F++;
                    next.S = v[j];
                }
                else next.S += v[j];
                dp[i] = min(dp[i], next);
            }
        }
    }
    cout << dp[(1<<n)-1].F + (dp[(1<<n)-1].S >= 0) << '\n'; 
    return 0;
}
\end{lstlisting}

\subsection{Grid Paths}
\begin{lstlisting}
// Problem name: Grid Paths
// Problem Link: https://cses.fi/problemset/task/1638
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
const int mod = 1e9+7;
 
int dp[1010][1010], n;
bool m[1010][1010];
 
int ways (int i, int j) {
    if (dp[i][j] >= 0) return dp[i][j];
    int resp = 0;
    if (i < n and m[i+1][j]) {
        resp += ways(i+1, j);
        resp %= mod;
    }
    if (j < n and m[i][j+1]) {
        resp += ways(i, j+1);
        resp %= mod;
    }
    return dp[i][j] = resp;
}
 
int main () { _
    char c;
    memset(dp, -1, sizeof(dp));
    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> c;
            if (c == '.') m[i][j] = true;
            else m[i][j] = false;
        }
    }
    dp[n-1][n-1] = 1;
    if (!m[0][0]) cout << "0" << endl;
    else cout << ways(0,0) << endl;
    return 0;
}
\end{lstlisting}

\subsection{Increasing Subsequence}
\begin{lstlisting}
// Problem name: Increasing Subsequence
// Problem Link: https://cses.fi/problemset/task/1145
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an array containing n integers. Your task is to determine the longest 
//increasing subsequence in the array, i.e., 
// the longest subsequence where every element is larger than the previous one.
// A subsequence is a sequence that can be derived from the array by deleting 
// some elements without changing the order of the remaining elements. 

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n;
    cin >> n;
    vector<int> v(n), pilha;
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        auto it = lower_bound(pilha.begin(), pilha.end(), v[i]);
        if (it == pilha.end()) {
            pilha.pb(v[i]);
        }
        else *it = v[i];
    }
    cout << (int)pilha.size() << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Minimizing Coins}
\begin{lstlisting}
// Problem name: Minimizing Coins
// Problem Link: https://cses.fi/problemset/task/1634
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
 
int dp[MAXN], n, x, v[105];
 
int coin(int soma) {
    if (dp[soma] > 0) return dp[soma];
    if (soma == 0) return 0;
    int resp = INF;
    for (int i = n; i > 0; i--) {
        if (soma-v[i] >= 0) resp = min(resp, 1+coin(soma-v[i]));
    }
    return dp[soma] = resp;
}
 
int main () {
    cin >> n >> x;
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
    }
    int ans = coin(x);
    if (ans > 1000000) cout << "-1" << endl;
    else cout << ans << endl;
    return 0;
}
\end{lstlisting}

\subsection{Money Sums}
\begin{lstlisting}
// Problem name: Money Sums
// Problem Link: https://cses.fi/problemset/task/1745
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n;
    cin >> n;
    vector<int> v(n);
    for (int i = 0; i < n; i++) cin >> v[i];
    vector<int> dp(1e5 + 5);
    dp[0] = 1;
    int c = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 1e5; j >= 0; j--) {
            if (dp[j] && j+v[i] <= 1e5) {
                c += (dp[j+v[i]] == 0);
                dp[j+v[i]] = 1;
            }
        }
    }
    cout << c << '\n';
    for (int i = 1; i <= 1e5; i++) 
        if (dp[i]) cout << i << ' ';
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Projects}
\begin{lstlisting}
// Problem name: Projects
// Problem Link: https://cses.fi/problemset/task/1140
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n;
    cin >> n;
    vector<pair<pii, int>> v(n);
    vector<int> c;
    for (int i = 0; i < n; i++) {
        cin >> v[i].F.F >> v[i].F.S >> v[i].S;
        c.pb(v[i].F.F), c.pb(v[i].F.S);
    }
    sort(c.begin(), c.end());
    map<int, int> mapa;
    int atual = 0;
    mapa[c[0]] = atual++;
    for (int i = 1; i < (int)c.size(); i++) {
        if (c[i] != c[i-1]) mapa[c[i]] = atual++;
    }
    for (int i = 0; i < n; i++) {
        v[i].F.F = mapa[v[i].F.F];
        v[i].F.S = mapa[v[i].F.S];
    }
    sort(v.begin(), v.end());
    vector<ll> dp(1e6);
    atual = n-1;
    for (int i = 5e5; i >= 0; i--) {
        dp[i] = max(dp[i], dp[i+1]);
        while (atual >= 0 && i == v[atual].F.F) {
            dp[i] = max(dp[i], v[atual].S + dp[v[atual].F.S + 1]);
            atual--;
        }
    }
    cout << dp[0] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Rectangle Cutting}
\begin{lstlisting}
// Problem name: Rectangle Cutting
// Problem Link: https://cses.fi/problemset/task/1744
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given an a×b rectangle, your task is to cut it into squares. 
// On each move you can select a rectangle and cut it into two rectangles 
// in such a way that all side lengths remain integers. What is the minimum possible number of moves?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int a, b;
    cin >> a >> b;
    vector<vector<int>> dp(505, vector<int> (505, INF));
    for (int i = 1; i <= a; i++) {
        dp[i][i] = 0;
        for (int j = 1; j <= b; j++) {
            for (int k = 1; k < j; k++) {
                dp[i][j] = min(dp[i][j], 1 + dp[i][j-k] + dp[i][k]);
            }
            for (int k = 1; k < i; k++) {
                dp[i][j] = min(dp[i][j], 1 + dp[i-k][j] + dp[k][j]);
            }
        }
    }
    cout << dp[a][b] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Removing Digits}
\begin{lstlisting}
// Problem name: Removing Digits
// Problem Link: https://cses.fi/problemset/task/1637
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
 
int dp[MAXN];
 
int digit(int x) {
    if (x == 0) return 0;
    if (dp[x] > 0) return dp[x];
    string s = to_string(x);
    int resp = INF;
    for (int i = 0; i < (int)s.size(); i++) {
        if (s.at(i) != '0') resp = min(resp, 1 + digit(x-(int)s.at(i)+48));
    }
    return dp[x] = resp;
}
 
int main () { _
    int n;
    cin >> n;
    cout << digit(n) << endl;
    return 0;
}
\end{lstlisting}

\subsection{Two Sets II}
\begin{lstlisting}
// Problem name: Two Sets II
// Problem Link: https://cses.fi/problemset/task/1093
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, int e) {
    ll resp = 1;
    while (e) {
        if (e&1) resp = (resp * b) % M;
        b = (b * b) % M;
        e = (e >> 1);
    }
    return resp;
}
 
int main () { _
    int n;
    cin >> n;
    if ((n%4) && ((n+1)%4)) cout << "0\n";
    else {
        int meta = n*(n+1)/4;
        vector<ll> dp(meta+1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = meta; j >= 0; j--) {
                if (j+i <= meta) {
                    dp[j+i] += dp[j];
                    if (dp[j+i] >= M) dp[j+i] -= M;
                }
            }
        }
        cout << (dp[meta] * fexp(2, M-2)) % M << '\n';
    }
    return 0;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% CSES - Geometry
%
%%%%%%%%%%%%%%%%%%%%

\section{CSES - Geometry}

\subsection{Convex Hull}
\begin{lstlisting}
// Problem name: Convex Hull
// Problem Link: https://cses.fi/problemset/task/2195
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a set of n points in the two-dimensional plane, your task is to determine the convex hull of the points.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
ll cross(pll a, pll b, pll c, pll d) {
	return (a.F - b.F) * (c.S - d.S) - (a.S - b.S) * (c.F - d.F);
}
 
void CH(vector<pll> &v) {
	 int n = (int) v.size(), k = 0;
	vector<pll> h(2 * n);
	sort(v.begin(), v.end());
	// lower hull
	for (int i = 0; i < n; i++) {
		while (k >= 2 && cross(h[k - 1], h[k - 2], v[i], h[k - 2]) < 0) k--;
		h[k++] = v[i];
	}
	// upper hull
	for (int i = n - 2, t = k + 1; i >= 0; i--) {
		while (k >= t && cross(h[k - 1], h[k - 2], v[i], h[k - 2]) < 0) {
			k--;
		}
		h[k++] = v[i];
	}
	reverse(h.begin(), h.begin() + k);
	h.resize(k - 1);
	v = h;
}
 
int main () { _
	int n;
	cin >> n;
	vector<pll> v(n);
	for (int i = 0; i < n; i++) cin >> v[i].F >> v[i].S;
	CH(v);
	cout << v.size() << '\n';
	for (auto a : v) cout << a.F << ' ' << a.S << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Line Segment Intersection}
\begin{lstlisting}
// Problem name: Line Segment Intersection
// Problem Link: https://cses.fi/problemset/task/2190
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are two line segments: the first goes through the points (x1,y1) and (x2,y2), 
// and the second goes through the points (x3,y3) and (x4,y4).
// Your task is to determine if the line segments intersect, i.e., they have at least one common point.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
ll cross(ll ax, ll ay, ll bx, ll by, ll cx, ll cy, ll dx, ll dy) {
	ll val = (ax - bx) * (cy - dy) - (ay - by) * (cx - dx);
	if (!val) return 0;
	if (val > 0) return 1;
	else return -1;
}
 
bool mid(ll ax, ll ay, ll bx, ll by, ll cx, ll cy) {
	return (min(ax, bx) <= cx && max(ax, bx) >= cx && min(ay, by) <= cy && max(ay, by) >= cy);
}
 
bool valid() {
	ll x1, x2, x3, x4, y1, y2, y3, y4;
	cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4;
	ll c1, c2, c3, c4;
	c1 = cross(x1, y1, x2, y2, x1, y1, x3, y3);
	c2 = cross(x1, y1, x2, y2, x1, y1, x4, y4);
	c3 = cross(x3, y3, x4, y4, x3, y3, x1, y1);
	c4 = cross(x3, y3, x4, y4, x4, y4, x2, y2);
	if (c1 != c2 && c3 != c4) return true;
	if (!c1 && mid(x1, y1, x2, y2, x3, y3)) return true;
	if (!c2 && mid(x1, y1, x2, y2, x4, y4)) return true;
	if (!c3 && mid(x3, y3, x4, y4, x1, y1)) return true;
	if (!c4 && mid(x3, y3, x4, y4, x2, y2)) return true;
	return false;
}
 
int main () { _
	int t;
	cin >> t;
	while (t--) {
		cout << (valid() ? "YES\n" : "NO\n");
	}
    return 0;
}
\end{lstlisting}

\subsection{Minimum Euclidean Distance}
\begin{lstlisting}
// Problem name: Minimum Euclidean Distance
// Problem Link: https://cses.fi/problemset/task/2194
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a set of points in the two-dimensional plane, your task is to find the 
// minimum Euclidean distance between two distinct points.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
ll dist(pll a, pll b) {
	return (a.F - b.F) * (a.F - b.F) + (a.S - b.S) * (a.S - b.S);
}
 
int main () { _
	int n;
	cin >> n;
	vector<pll> v(n);
	for (int i = 0; i < n; i++) cin >> v[i].S >> v[i].F;
	sort(v.begin(), v.end(), [&] (pll a, pll b) { return a.S < b.S; });
	ll ans = 9e18;
	ll d = 1e10;
	set<pll> s;
	s.insert(v[0]);
	for (int i = 1; i < n; i++) {
		while (!s.empty() && abs(v[i].S - s.begin()->S) > d)
			s.erase(*s.begin());
		auto it = s.lower_bound({v[i].F - d + 1, v[i].S});
		while (it != s.end() && it->F < v[i].F + d - 1) {
			if (dist(*it, v[i]) < ans) {
				ans = dist(*it, v[i]);
				d = ceil(sqrt(ans));
			}
			it++;
		}
		s.insert(v[i]);
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Point in Polygon}
\begin{lstlisting}
// Problem name: Point in Polygon
// Problem Link: https://cses.fi/problemset/task/2192
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a polygon of n vertices and a list of m points. 
// Your task is to determine for each point if it is inside, outside or on the boundary of the polygon.
// The polygon consists of n vertices (x1,y1),(x2,y2)...,(xn,yn). The vertices (xi,yi) and (xi+1,yi+1) 
// are adjacent for i=1,2...,n−1, and the vertices (x1,y1) and (xn,yn) are also adjacent.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
ll cross(pll a, pll b, pll c, pll d) {
	ll val = (a.F - b.F) * (c.S - d.S) - (a.S - b.S) * (c.F - d.F);
	if (!val) return 0;
	if (val > 0) return 1;
	else return -1;
}
 
bool mid(pll a, pll b, pll c) {
	return (min(a.F, b.F) <= c.F && max(a.F, b.F) >= c.F && min(a.S, b.S) <= c.S && max(a.S, b.S) >= c.S);
}
 
bool valid(pll a, pll b, pll c, pll d) {
	ll c1, c2, c3, c4;
	c1 = cross(a, b, a, c);
	c2 = cross(a, b, a, d);
	c3 = cross(c, d, c, a);
	c4 = cross(c, d, c, b);
	if (c1 != c2 && c3 != c4) return true;
	if (!c1 && mid(a, b, c)) return true;
	if (!c2 && mid(a, b, d)) return true;
	if (!c3 && mid(c, d, a)) return true;
	if (!c4 && mid(c, d, b)) return true;
	return false;
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	vector<pll> pol(n);
	for (int i = 0; i < n; i++) 
		cin >> pol[i].F >> pol[i].S;
	pll a, aux = {1e9+2, 1e9+1};
	for (int i = 0; i < m; i++) {
		cin >> a.F >> a.S;
		aux = {a.F+1, 1e9+7};
		bool bound = false;
		for (int j = 0; j < n; j++) {
			if (cross(pol[j], (!j ? pol[n-1] : pol[j-1]), pol[j], a) == 0) {
				if (mid(pol[j], (!j ? pol[n-1] : pol[j-1]), a)) bound = true;
			}
		}
		if (bound) cout << "BOUNDARY\n";
		else {
			int cnt = 0;
			for (int j = 0; j < n; j++) {
				cnt += valid(a, aux, pol[j], (!j ? pol[n-1] : pol[j-1]));
			}
			cout << (cnt&1 ? "INSIDE\n" : "OUTSIDE\n");
		}
 
	}
    return 0;
}
\end{lstlisting}

\subsection{Point Location Test}
\begin{lstlisting}
// Problem name: Point Location Test
// Problem Link: https://cses.fi/problemset/task/2189
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There is a line that goes through the points p1=(x1,y1) and p2=(x2,y2). There is also a point p3=(x3,y3).
// Your task is to determine whether p3 is located on the left or right side of the line or 
// if it touches the line when we are looking from p1 to p2.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	int t;
	cin >> t;
	while (t--) {
		int x1, x2, x3, y1, y2, y3;
		cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;
		ll val = 1ll * (x2-x1) * (y3-y1) - 1ll * (y2-y1) * (x3-x1);
		if (val == 0) cout << "TOUCH\n";
		if (val < 0) cout << "RIGHT\n";
		if (val > 0) cout << "LEFT\n";
	}
    return 0;
}
\end{lstlisting}

\subsection{Polygon Area}
\begin{lstlisting}
// Problem name: Polygon Area
// Problem Link: https://cses.fi/problemset/task/2191
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to calculate the area of a given polygon.
// The polygon consists of n vertices (x1,y1),(x2,y2)...,(xn,yn). 
// The vertices (xi,yi) and (xi+1,yi+1) are adjacent for i=1,2...,n−1, 
// and the vertices (x1,y1) and (xn,yn) are also adjacent.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	int n;
	cin >> n;
	vector<pii> v(n);
	for (int i = 0; i < n; i++) cin >> v[i].F >> v[i].S;
	ll ans = 0;
	for (int i = 0; i < n; i++) {
		pii last = (!i ? v[n-1] : v[i-1]);
		ans += 1ll * (last.F - v[i].F) * (last.S + v[i].S);
	}
	cout << abs(ans) << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Polygon Lattice Points}
\begin{lstlisting}
// Problem name: Polygon Lattice Points
// Problem Link: https://cses.fi/problemset/task/2193
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a polygon, your task is to calculate the number of lattice points inside 
// the polygon and on its boundary. A lattice point is a point whose coordinates are integers.
// The polygon consists of n vertices (x1,y1),(x2,y2)...,(xn,yn). The vertices (xi,yi) and (xi+1,yi+1)
// are adjacent for i=1,2...,n−1, and the vertices (x1,y1) and (xn,yn) are also adjacent.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int main () { _
	int n;
	cin >> n;
	vector<pll> v(n);
	for (int i = 0; i < n; i++) cin >> v[i].F >> v[i].S;
	ll area = 0, pts = 0;
	for (int i = 0; i < n; i++) {
		pll last = v[(i+1) % n];
		area += (last.F - v[i].F) * (last.S + v[i].S);
		pts += __gcd(abs(last.F - v[i].F), abs(last.S - v[i].S));
	}
	area = abs(area);
	ll ipts = area + 2 - pts;
	cout << ipts/2 << ' ' << pts << '\n';
    return 0;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% CSES - Graph Algorithms
%
%%%%%%%%%%%%%%%%%%%%

\section{CSES - Graph Algorithms}

\subsection{Building Roads}
\begin{lstlisting}
// Problem name: Building Roads
// Problem Link: https://cses.fi/problemset/task/1666
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int pai[MAXN], n, m;
bool check[MAXN];
vector<int> resp;
 
int find(int x) {
    if (pai[x] == x) return x;
    return pai[x] = find(pai[x]);
}
 
void join(int a, int b) {
    int pai1 = find(a);
    int pai2 = find(b);
 
    if (pai1 == pai2) return;
    if (pai1 == 1) {
        pai[pai2] = pai1;
    }
    else pai[pai1] = pai2;
}
 
int main() { _
    int resp = 0;
    queue<pii> ans;
    cin >> n >> m;
    int a, b;
    for (int i = 1; i <= n; i++) {
        pai[i] = i;
    }
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        join(a, b);
    }
    int conec = 1;
    for (int i = 2; i <= n; i++) {
        if (find(i) != conec) {
            resp++;
            ans.push({1, i});
            join(1, i);
        }
    }
    cout << resp << endl;
    while(!ans.empty()) {
        cout << ans.front().first << " " << ans.front().second << endl;
        ans.pop();
    }
    return 0;
}
\end{lstlisting}

\subsection{Building Teams}
\begin{lstlisting}
// Problem name: Building Teams
// Problem Link: https://cses.fi/problemset/task/1668
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000
#define PB push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int n, m, id, resp[MAXN];
vector<int> viz[MAXN];
bool check[MAXN], ber;
 
void DFS(int node, int z) {
    check[node] = true;
    resp[node] = z+1;
    for (int i = 0; i < (int)viz[node].size(); i++) {
        int atual = viz[node][i];
        if (!check[atual]) DFS(atual, 1-z);
        else if (resp[atual] == resp[node]) ber = true;
    }
}
 
int main() { _
    int a, b;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        viz[a].PB(b);
        viz[b].PB(a);
    }
    id = 0;
    for (int i = 1; i <= n; i++) {
        if (!check[i]) {
            DFS(i, 0);
        }
    }
    if (!ber) {
        for (int i = 1; i <= n; i++) {
            cout << resp[i] << " ";
        }
        cout << endl;
    }
    else cout << "IMPOSSIBLE" << endl;
    return 0;
}
\end{lstlisting}

\subsection{Coin Collector}
\begin{lstlisting}
// Problem name: Coin Collector
// Problem Link: https://cses.fi/problemset/task/1686
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int vis[MAXN], comp[MAXN], cnt = 0;
ll c1[MAXN], c2[MAXN], dp[MAXN], ans = 0;
vector<int> v[MAXN], w[MAXN], nv[MAXN], ord;
 
void dfs1(int node) {
	vis[node] = 1;
	for (int x : v[node]) 
		if (!vis[x]) dfs1(x);
	ord.pb(node);
}
 
void dfs2(int node) {
	vis[node] = 1;
	c2[cnt] += c1[node];
	comp[node] = cnt;
	for (int x : w[node])
		if (!vis[x]) dfs2(x);
}
 
void dfs3(int node) {
	vis[node] = 1;
	dp[node] = c2[node];
	for (int x : nv[node]) {
		if (!vis[x]) dfs3(x);
		dp[node] = max(dp[x] + c2[node], dp[node]);
	}
	ans = max(ans, dp[node]);
}
 
int main () { _
	int n, m, a, b;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> c1[i];
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].pb(b);
		w[b].pb(a);
	}
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) dfs1(i);
	}
	memset(vis, 0, sizeof(vis));
	reverse(ord.begin(), ord.end());
	for (int x : ord) {
		if (!vis[x]) {
			cnt++;
			dfs2(x);
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int x : v[i]) {
			if (comp[x] != comp[i]) nv[comp[i]].pb(comp[x]);
		}
	}
	memset(vis, 0, sizeof(vis));
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) dfs3(i);
	}
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Counting Rooms}
\begin{lstlisting}
// Problem name: Counting Rooms
// Problem Link: https://cses.fi/problemset/task/1192
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 10000000000
 
using namespace std;
typedef long long int lli;
const int mod = 1e9+7;
 
int n, m, matriz[1010][1010], resp = 0;
bool check[1010][1010];
 
void DFS (int i, int j) {
    check[i][j] = true;
    if (i+1 < n and !check[i+1][j] and !matriz[i+1][j]) DFS(i+1, j);
    if (i-1 >= 0 and !check[i-1][j] and !matriz[i-1][j]) DFS(i-1, j);
    if (j+1 < m and !check[i][j+1] and !matriz[i][j+1]) DFS(i, j+1);
    if (j-1 >= 0 and !check[i][j-1] and !matriz[i][j-1]) DFS(i, j-1);
}
 
int main() { _
    char c;
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> c;
            if (c == '.') matriz[i][j] = 0;
            else matriz[i][j] = 1;
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (!check[i][j] and !matriz[i][j]) {
                DFS(i, j);
                resp++;
            }
        }
    }
    cout << resp << endl;
    return 0;
}
\end{lstlisting}

\subsection{Course Schedule}
\begin{lstlisting}
// Problem name: Course Schedule
// Problem Link: https://cses.fi/problemset/task/1679
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You have to complete n courses. There are m requirements of the form "course a has to be completed before course b". 
// Your task is to find an order in which you can complete the courses.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN], ans;
bool valid = true;
int cor[MAXN];
 
void dfs(int node) {
	cor[node] = 1;
	for (int x : v[node]) {
		if (cor[x] == 1) {
			valid = false;
			return;
		}
		if (!cor[x]) dfs(x);
	}
	cor[node] = 2;
	ans.pb(node);
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
	}
	for (int i = 1; i <= n && valid; i++) {
		if (!cor[i]) {
			dfs(i);
		}
	}
	if (!valid) cout << "IMPOSSIBLE\n";
	else {
		reverse(ans.begin(), ans.end());
		for (int x : ans) cout << x << ' ';
		cout << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{Cycle Finding}
\begin{lstlisting}
// Problem name: Cycle Finding
// Problem Link: https://cses.fi/problemset/task/1197
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a directed graph, and your task is to find out 
// if it contains a negative cycle, and also give an example of such a cycle.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 2550
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
vector<array<int, 3>> v;
ll dist[MAXN];
int p[MAXN];
 
int main() { _
	int n, m;
	cin >> n >> m;
	array<int, 3> a;
	for (int i = 0; i < m; i++) {
		cin >> a[0] >> a[1] >> a[2];
		v.pb(a);
	}
	int x = -1;
	for (int i = 2; i <= n; i++) dist[i] = INF;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			if (dist[v[j][0]] + v[j][2] < dist[v[j][1]]) {
				dist[v[j][1]] = dist[v[j][0]] + v[j][2];
				p[v[j][1]] = v[j][0];
				if (i == n-1) x = v[j][1];
			}
		}
	}
	if (x == -1) cout << "NO\n";
	else {
		cout << "YES\n";
		for (int i = 0; i < n; i++) x = p[x];
		stack<int> ans;
		ans.push(x);
		for (int i = p[x]; i != x; i = p[i]) {
			ans.push(i);
		}
		ans.push(x);
		while (!ans.empty()) {
			cout << ans.top() << ' ';
			ans.pop();
		}
		cout << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{De Bruijn Sequence}
\begin{lstlisting}
// Problem name: De Bruijn Sequence
// Problem Link: https://cses.fi/problemset/task/1692
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to construct a minimum-length bit string that contains all possible substrings of length n. 
// For example, when n=2, the string 00110 is a valid solution, because its substrings of length 2 are 00, 01, 10 and 11.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 4000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN];
string ans;
int grau[MAXN], n, start = -1;
 
void euler(int node) {
	stack<pair<int, char>> path;
	path.push({node, ' '});
	while (!path.empty()) {
		pair<int, char> cur = path.top();
		if (!grau[cur.F]) {
			if (start == -1) start = cur.F;
			ans += cur.S;
			path.pop();
		}
		else {
			int next = v[cur.F].back();
			v[cur.F].pop_back();
			path.push({next, (next&1 ? '1' : '0')});
			grau[cur.F]--;
		}
	}
}
 
int main () { _
	cin >> n;
	for (int i = 0; i < (1<<(n-1)); i++) {
		int next = i<<1 & ((1<<(n-1)) - 1);
		v[i].pb(next);
		v[i].pb(next+1);
		grau[i] = 2;
	}
	euler(0);
	ans.pop_back();
	for (int i = 0; i < n-1; i++) {
		ans += (start & (1 << i) ? '1' : '0');
	}
	cout << ans << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{Distinct Routes}
\begin{lstlisting}
// Problem name: Distinct Routes
// Problem Link: https://cses.fi/problemset/task/1711
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A game consists of n rooms and m teleporters. 
// At the beginning of each day, you start in room 1 and you have to reach room n.
// You can use each teleporter at most once during the game. 
// How many days can you play if you choose your routes optimally?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const int INF = 1e9;
 
// Dinic
//
// O(min(m * max_flow, n^2 m))
// Grafo com capacidades 1 -> O(sqrt(n)*m)
struct dinic {
	const bool scaling = false;
	int lim;
	struct edge {
		int to, cap, rev, flow;
		bool res;
		edge(int to_, int cap_, int rev_, bool res_)
			: to(to_), cap(cap_), rev(rev_), flow(0), res(res_) {}
	};
 
	vector<vector<edge>> g;
	vector<int> lev, beg;
	ll F;
	dinic(int n) : g(n), F(0) {}
 
	void add(int a, int b, int c) {
		g[a].emplace_back(b, c, g[b].size(), false);
		g[b].emplace_back(a, 0, g[a].size()-1, true);
	}
	bool bfs(int s, int t) {
		lev = vector<int>(g.size(), -1); lev[s] = 0;
		beg = vector<int>(g.size(), 0);
		queue<int> q; q.push(s);
		while (q.size()) {
			int u = q.front(); q.pop();
			for (auto& i : g[u]) {
				if (lev[i.to] != -1 or (i.flow == i.cap)) continue;
				if (scaling and i.cap - i.flow < lim) continue;
				lev[i.to] = lev[u] + 1;
				q.push(i.to);
			}
		}
		return lev[t] != -1;
	}
	int dfs(int v, int s, int f = INF) {
		if (!f or v == s) return f;
		for (int& i = beg[v]; i < g[v].size(); i++) {
			auto& e = g[v][i];
			if (lev[e.to] != lev[v] + 1) continue;
			int foi = dfs(e.to, s, min(f, e.cap - e.flow));
			if (!foi) continue;
			e.flow += foi, g[e.to][e.rev].flow -= foi;
			return foi;
		}
		return 0;
	}
	ll max_flow(int s, int t) {
		for (lim = scaling ? (1<<30) : 1; lim; lim /= 2)
			while (bfs(s, t)) while (int ff = dfs(s, t)) F += ff;
		return F;
	}
 
	// arestas com fluxo
	vector<pii> flow_edges(int s, int t) {
		max_flow(s, t);
		vector<pii> ans;
		int n = g.size();
		for (int i = 0; i < n; i++) {
			for (auto edge : g[i]) {
				if (!edge.res && edge.flow) 
					ans.emplace_back(i, edge.to);
			}
		}
		return ans;
	}
 
	// arestas no min cut
	vector<pii> cut_edges(int s, int t) {
		max_flow(s, t);
		vector<pii> cut;
		vector<int> vis(g.size(), 0), st = {s};
		vis[s] = 1;
		while (st.size()) {
			int u = st.back(); st.pop_back();
			for (auto e : g[u]) if (!vis[e.to] and e.flow < e.cap)
				vis[e.to] = 1, st.push_back(e.to);
		}
		for (int i = 0; i < g.size(); i++) for (auto e : g[i])
			if (vis[i] and !vis[e.to] and !e.res) cut.emplace_back(i, e.to);
		return cut;
	}
};
 
vector<int> v[505], caminho;
int ma[505][505], n, m;
 
void dfs(int node) {
	caminho.push_back(node);
	for (int x : v[node]) {
		if (!ma[node][x]) {
			ma[node][x] = 1;
			dfs(x);
			break;
		}
	} 
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	cin >> n >> m;
	dinic ber(n);
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		a--, b--;
		ber.add(a, b, 1);
	}
	int tot = ber.max_flow(0, n - 1);
	cout << tot << '\n';
	vector<pii> ed = ber.flow_edges(0, n - 1);
	for (auto x : ed) {
		v[x.first].push_back(x.second);
	}
	while (tot--) {
		dfs(0);
		cout << caminho.size() << '\n';
		for (int x : caminho) cout << x + 1 << ' ';
		cout << '\n';
		caminho.clear();
	}
 
    return 0;
}
\end{lstlisting}

\subsection{Download Speed}
\begin{lstlisting}
// Problem name: Download Speed
// Problem Link: https://cses.fi/problemset/task/1694
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include<bits/stdc++.h>
using namespace std;
#define int long long
 
// A structure to represent a edge between
// two vertex
struct Edge
{
    int v ;  // Vertex v (or "to" vertex)
             // of a directed edge u-v. "From"
             // vertex u can be obtained using
             // index in adjacent array.
 
    int flow ; // flow of data in edge
 
    int C;    // capacity
 
    int rev ; // To store index of reverse
              // edge in adjacency list so that
              // we can quickly find it.
};
 
// Residual Graph
class Graph
{
    int V; // number of vertex
    int *level ; // stores level of a node
    vector< Edge > *adj;
public :
    Graph(int V)
    {
        adj = new vector<Edge>[V];
        this->V = V;
        level = new int[V];
    }
 
    // add edge to the graph
    void addEdge(int u, int v, int C)
    {
        // Forward edge : 0 flow and C capacity
        Edge a{v, 0, C, adj[v].size()};
 
        // Back edge : 0 flow and 0 capacity
        Edge b{u, 0, 0, adj[u].size()};
 
        adj[u].push_back(a);
        adj[v].push_back(b); // reverse edge
    }
 
    bool BFS(int s, int t);
    int sendFlow(int s, int flow, int t, int ptr[]);
    int DinicMaxflow(int s, int t);
};
 
// Finds if more flow can be sent from s to t.
// Also assigns levels to nodes.
bool Graph::BFS(int s, int t)
{
    for (int i = 0 ; i < V ; i++)
        level[i] = -1;
 
    level[s] = 0;  // Level of source vertex
 
    // Create a queue, enqueue source vertex
    // and mark source vertex as visited here
    // level[] array works as visited array also.
    list< int > q;
    q.push_back(s);
 
    vector<Edge>::iterator i ;
    while (!q.empty())
    {
        int u = q.front();
        q.pop_front();
        for (i = adj[u].begin(); i != adj[u].end(); i++)
        {
            Edge &e = *i;
            if (level[e.v] < 0  && e.flow < e.C)
            {
                // Level of current vertex is,
                // level of parent + 1
                level[e.v] = level[u] + 1;
 
                q.push_back(e.v);
            }
        }
    }
 
    // IF we can not reach to the sink we
    // return false else true
    return level[t] < 0 ? false : true ;
}
 
// A DFS based function to send flow after BFS has
// figured out that there is a possible flow and
// constructed levels. This function called multiple
// times for a single call of BFS.
// flow : Current flow send by parent function call
// start[] : To keep track of next edge to be explored.
//           start[i] stores  count of edges explored
//           from i.
//  u : Current vertex
//  t : Sink
int Graph::sendFlow(int u, int flow, int t, int start[])
{
    // Sink reached
    if (u == t)
        return flow;
 
    // Traverse all adjacent edges one -by - one.
    for (  ; start[u] < adj[u].size(); start[u]++)
    {
        // Pick next edge from adjacency list of u
        Edge &e = adj[u][start[u]];
                                     
        if (level[e.v] == level[u]+1 && e.flow < e.C)
        {
            // find minimum flow from u to t
            int curr_flow = min(flow, e.C - e.flow);
 
            int temp_flow = sendFlow(e.v, curr_flow, t, start);
 
            // flow is greater than zero
            if (temp_flow > 0)
            {
                // add flow  to current edge
                e.flow += temp_flow;
 
                // subtract flow from reverse edge
                // of current edge
                adj[e.v][e.rev].flow -= temp_flow;
                return temp_flow;
            }
        }
    }
 
    return 0;
}
 
// Returns maximum flow in graph
int Graph::DinicMaxflow(int s, int t)
{
    // Corner case
    if (s == t)
        return -1;
 
    int total = 0;  // Initialize result
 
    // Augment the flow while there is path
    // from source to sink
    while (BFS(s, t) == true)
    {
        // store how many edges are visited
        // from V { 0 to V }
        int *start = new int[V+1] {0};
 
        // while flow is not zero in graph from S to D
        while (int flow = sendFlow(s, INT_MAX, t, start))
 
            // Add path flow to overall flow
            total += flow;
    }
 
    // return maximum flow
    return total;
}
 
// Driver Code
int32_t main() {
	int n, m;
	cin >> n >> m;
    Graph g(n);
    for (int i = 0; i < m; i++) {
		int a, b, c;
		cin >> a >> b >> c;
		a--, b--;
		g.addEdge(a, b, c);
	}
    cout << g.DinicMaxflow(0, n-1) << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Flight Discount}
\begin{lstlisting}
// Problem name: Flight Discount
// Problem Link: https://cses.fi/problemset/task/1195
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<pii> v[MAXN];
ll dist[MAXN][10], n, m, coupons = 1;
 
struct d {
	int no;
	int sale;
	ll di;
 
	d(int _no = 0, ll _di = 0, int _sale = 0) {
		no = _no;
		di = _di;
		sale = _sale;
	}
 
	inline const bool operator<(const d& other) const {
		if (sale == other.sale) {
			return di > other.di;
		}
		return sale > other.sale;
	}
};
 
void dijkstra(int node) {
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < 10; j++) dist[i][j] = INF;
	}
	dist[node][0] = 0;
	d aux;
	aux.no = node, aux.di = 0, aux.sale = 0;
	priority_queue<d> fila;
	fila.push(aux);
	while (!fila.empty()) {
		aux = fila.top();
		fila.pop();
		if (dist[aux.no][aux.sale] < aux.di) continue;
		for (pii x : v[aux.no]) {
			if (dist[x.F][aux.sale] > aux.di + x.S) {
				dist[x.F][aux.sale] = aux.di + x.S;
				d next;
				next.no = x.F, next.di = dist[x.F][aux.sale], next.sale = aux.sale;
				fila.push(next);
			}
			if (aux.sale < coupons) {
				if (dist[x.F][aux.sale+1] > aux.di + x.S/2) {
					dist[x.F][aux.sale+1] = aux.di + x.S/2;
					d next;
					next.no = x.F, next.di = dist[x.F][aux.sale+1], next.sale = aux.sale+1;
					fila.push(next);
				}
			}
		}
	}
}
 
int main () { _
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b, c;
		cin >> a >> b >> c;
		v[a].pb({b, c});
	}
	dijkstra(1);
	cout << dist[n][coupons] << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{Flight Routes}
\begin{lstlisting}
// Problem name: Flight Routes
// Problem Link: https://cses.fi/problemset/task/1196
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to find the k shortest flight routes from Syrjälä to Metsälä. 
// A route can visit the same city several times.
// Note that there can be several routes with the same price 
// and each of them should be considered (see the example).

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
vector<pii> v[MAXN];
priority_queue<ll> dist[MAXN];
int n, m, k;
 
void dijkstra() {
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < k; j++) dist[i].push(INF);
	}
	dist[1].pop();
	dist[1].push(0);
	priority_queue<pll, vector<pll>, greater<pll>> fila;
	fila.push({0, 1});
	while (!fila.empty()) {
		pll atual = fila.top();
		fila.pop();
		if (atual.F > dist[atual.S].top()) continue;
		for (pii x : v[atual.S]) {
			if (dist[x.F].top() > atual.F + x.S) {
				dist[x.F].pop();
				dist[x.F].push(atual.F + x.S);
				fila.push({atual.F + x.S, x.F});
			}
		}
	}
}
 
int main() { _
	cin >> n >> m >> k;
	for (int i = 0; i < m; i++) {
		int a, b, c;
		cin >> a >> b >> c;
		v[a].pb({b, c});
	}
	dijkstra();
	vector<ll> ans;
	while (!dist[n].empty()) {
		ans.pb(dist[n].top());
		dist[n].pop();
	}
	reverse(ans.begin(), ans.end());
	for (ll x : ans) cout << x << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Flight Routes Check}
\begin{lstlisting}
// Problem name: Flight Routes Check
// Problem Link: https://cses.fi/problemset/task/1682
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n cities and m flight connections. Your task is to check if 
// you can travel from any city to any other city using the available flights.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int vis[MAXN], cnt = 0;
vector<int> v[MAXN], w[MAXN], ord, c[MAXN];
 
void dfs1(int node) {
	vis[node] = 1;
	for (int x : v[node]) 
		if (!vis[x]) dfs1(x);
	ord.pb(node);
}
 
void dfs2(int node) {
	vis[node] = 1;
	c[cnt].pb(node);
	for (int x : w[node])
		if (!vis[x]) dfs2(x);
}
 
int main () { _
	int n, m, a, b;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].pb(b);
		w[b].pb(a);
	}
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) dfs1(i);
	}
	memset(vis, 0, sizeof(vis));
	reverse(ord.begin(), ord.end());
	for (int x : ord) {
		if (!vis[x]) {
			cnt++;
			dfs2(x);
		}
	}
	if (cnt == 1) cout << "YES\n";
	else {
		cout << "NO\n";
		cout << c[2][0] << ' ' << c[1][0] << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{Game Routes}
\begin{lstlisting}
// Problem name: Game Routes
// Problem Link: https://cses.fi/problemset/task/1681
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int dp[MAXN], check[MAXN];
vector<int> v[MAXN];
 
void dfs(int node) {
    for (int x : v[node]) {
        if (!check[x]) dfs(x);
        check[x] = 1;
        dp[node] += dp[x];
        if (dp[node] >= M) dp[node] -= M;
    }
}
 
int main () { _
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        v[a].pb(b);
    }
    dp[n] = 1;
    dfs(1);
    cout << dp[1] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Giant Pizza}
\begin{lstlisting}
// Problem name: Giant Pizza
// Problem Link: https://cses.fi/problemset/task/1684
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Uolevi's family is going to order a large pizza and eat it together. 
// A total of n family members will join the order, and there are m possible toppings. 
// The pizza may have any number of toppings.
// Each family member gives two wishes concerning the toppings of the pizza. 
// The wishes are of the form "topping x is good/bad". Your task is to choose the toppings so that at least one wish from everybody becomes true (a good topping is included in the pizza or a bad topping is not included).

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
vector<int> v[MAXN], w[MAXN], ord, c[MAXN];
int vis[MAXN], cnt = 0, cmp[MAXN], ans[MAXN];
 
void dfs1(int node) {
	vis[node] = 1;
	for (int x : v[node])
		if (!vis[x]) dfs1(x);
	ord.pb(node);
}
 
void dfs2(int node) {
	cmp[node] = cnt;
	c[cnt].pb(node);
	vis[node] = 1;
	for (int x : w[node])
		if (!vis[x]) dfs2(x);
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		char a1, a2;
		int aux1, aux2;
		cin >> a1 >> aux1 >> a2 >> aux2;
		if (a1 == '+' && a2 == '+') {
			v[2*aux1+1].pb(2*aux2);
			v[2*aux2+1].pb(2*aux1);
			w[2*aux2].pb(2*aux1+1);
			w[2*aux1].pb(2*aux2+1);
		}
		else if (a1 == '+' && a2 == '-') {
			v[2*aux1+1].pb(2*aux2+1);
			v[2*aux2].pb(2*aux1);
			w[2*aux2+1].pb(2*aux1+1);
			w[2*aux1].pb(2*aux2);
		}
		else if (a1 == '-' && a2 == '+') {
			v[2*aux1].pb(2*aux2);
			v[2*aux2+1].pb(2*aux1+1);
			w[2*aux2].pb(2*aux1);
			w[2*aux1+1].pb(2*aux2+1);
		}
		else if (a1 == '-' && a2 == '-') {
			v[2*aux1].pb(2*aux2+1);
			v[2*aux2].pb(2*aux1+1);
			w[2*aux2+1].pb(2*aux1);
			w[2*aux1+1].pb(2*aux2);
		}
	}
	for (int i = 2; i <= 2*m+1; i++) 
		if (!vis[i]) dfs1(i);
	reverse(ord.begin(), ord.end());
	memset(vis, 0, sizeof(vis));
	for (int x : ord) {
		if (!vis[x]) {
			cnt++;
			dfs2(x);
		}
	}
	bool ok = true;
	for (int i = 2; i <= 2*m; i+=2) {
		if (cmp[i] == cmp[i+1]) ok = false;
		ans[i/2] = (cmp[i] > cmp[i+1]);
	}
	if (!ok) cout << "IMPOSSIBLE\n";
	else {
		for (int i = 1; i <= m; i++) cout << (ans[i] ? '+' : '-') << ' ';
		cout << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{Hamiltonian Flights}
\begin{lstlisting}
// Problem name: Hamiltonian Flights
// Problem Link: https://cses.fi/problemset/task/1690
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n cities and m flight connections between them. 
// You want to travel from Syrjälä to Lehmälä so that you visit each city exactly once. 
// How many possible routes are there?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 4000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int mat[25][25], dp[1100000][25];
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		mat[a][b]++;
	}
	dp[1][1] = 1;
	for (int i = 1; i < (1<<n); i++) {
		for (int j = 1; j <= n; j++) {
			if (dp[i][j]) {
				for (int k = 0; k < n; k++) {
					if (!(i & (1<<k)) && mat[j][k+1]) {
						dp[i ^ (1<<k)][k+1] += (1ll* dp[i][j] * mat[j][k+1]) % M;
						if (dp[i ^ (1<<k)][k+1] >= M) dp[i ^ (1<<k)][k+1] -= M;
					}
				}
			}
		}
	}
	cout << dp[(1<<n) - 1][n] << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{High Score}
\begin{lstlisting}
// Problem name: High Score
// Problem Link: https://cses.fi/problemset/task/1673
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 5050
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
vector<array<int, 3>> v;
vector<int> u[MAXN], w[MAXN];
ll dist[MAXN];
int inv[MAXN], vis1[MAXN], vis2[MAXN];
 
void dfs1(int node) {
	vis1[node] = 1;
	for (int x : u[node]) 	
		if (!vis1[x]) dfs1(x);
}
 
void dfs2(int node) {
	vis2[node] = 1;
	for (int x : w[node]) 	
		if (!vis2[x]) dfs2(x);
}
 
int main() { _
	int n, m;
	cin >> n >> m;
	array<int, 3> a;
	for (int i = 0; i < m; i++) {
		cin >> a[0] >> a[1] >> a[2];
		a[2] = -a[2];
		v.pb(a);
		u[a[0]].pb(a[1]);
		w[a[1]].pb(a[0]);
	}
	for (int i = 2; i <= n; i++) dist[i] = INF;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			dist[v[j][1]] = min(dist[v[j][1]], dist[v[j][0]] + v[j][2]);
		}
	}
	for (int j = 0; j < m; j++) {
		if (dist[v[j][0]] + v[j][2] < dist[v[j][1]]) inv[v[j][1]] = 1;
	}
	bool ok = true;
	dfs1(1);
	dfs2(n);
	ll ans = -dist[n];
	for (int i = 1; i <= n; i++) {
		if (inv[i] && vis1[i] && vis2[i]) ok = 0;
	}
	if (!ok) ans = -1;
	cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Investigation}
\begin{lstlisting}
// Problem name: Investigation
// Problem Link: https://cses.fi/problemset/task/1202
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are going to travel from Syrjälä to Lehmälä by plane. You would like to find answers to the following questions:
//     what is the minimum price of such a route?
//     how many minimum-price routes are there? (modulo 109+7)
// 	   what is the minimum number of flights in a minimum-price route?
//	   what is the maximum number of flights in a minimum-price route?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
vector<pii> v[MAXN], w[MAXN];
ll dist[MAXN], quant[MAXN], mn[MAXN], mx[MAXN];
int n, m, vis[MAXN];
 
void dijkstra(int node) {
	for (int i = 1; i <= n; i++) dist[i] = INF;
	dist[node] = 0;
	priority_queue<pll, vector<pll>, greater<pll>> fila;
	fila.push({0, node});
	while (!fila.empty()) {
		pll atual = fila.top();
		fila.pop();
		if (dist[atual.S] < atual.F) continue;
		for (pii x : v[atual.S]) {
			if (dist[x.F] > atual.F + x.S) {
				dist[x.F] = atual.F + x.S;
				fila.push({dist[x.F], x.F});
			}
		}
	}
}
 
void dag(int node) {
	vis[node] = 1;
	for (pii x : v[node]) {
		if (dist[node] + x.S == dist[x.F]) {
			w[node].pb(x);
			if (!vis[x.F]) dag(x.F);
		}
	}
}
 
void dfs(int node) {
	vis[node] = 1;
	for (pii x : w[node]) {
		if (!vis[x.F]) dfs(x.F);
		quant[node] += quant[x.F];
		if (quant[node] >= M) quant[node] -= M;
		mn[node] = min(mn[node], mn[x.F]+1);
		mx[node] = max(mx[node], mx[x.F]+1);
	}
}
 
int main () { _
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b, c;
		cin >> a >> b >> c;
		v[a].pb({b, c});
	}
	dijkstra(1);
	dag(1);
	memset(vis, 0, sizeof(vis));
	for (int i = 1; i <= n; i++) {
		mn[i] = INF;
		mx[i] = -INF;
	}
	mn[n] = mx[n] = 0;
	quant[n] = 1;
	// min price = dist[n]
	// how many routes
	// min number of edges in route
	// max number of edges in route
	dfs(1);
	cout << dist[n] << ' ' << quant[1] << ' ' << mn[1] << ' ' << mx[1] << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Knight's Tour}
\begin{lstlisting}
// Problem name: Knight's Tour
// Problem Link: https://cses.fi/problemset/task/1689
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a starting position of a knight on an 8×8 chessboard, 
// your task is to find a sequence of moves such that it visits every square exactly once.
// On each move, the knight may either move two steps horizontally and one step vertically, 
// or one step horizontally and two steps vertically.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 4000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int dx[8] = {2, 2, -2, -2, 1, -1, 1, -1}, dy[8] = {1, -1, 1, -1, 2, 2, -2, -2};
int mat[10][10];
 
bool valid(int x, int y) { return (x >= 0 && y >= 0 && x < 8 && y < 8 && !mat[x][y]); }
 
int count(int x, int y) {
	int resp = 0;
	for (int i = 0; i < 8; i++) {
		resp += valid(x+dx[i], y+dy[i]);
	}
	return resp;
}
 
bool dfs(int x, int y, int pos) {
	if (pos == 64) return true;
	vector<pair<int, pii>> v;
	for (int i = 0; i < 8; i++) {
		if (valid(x+dx[i], y+dy[i])) {
			v.pb({count(x+dx[i], y+dy[i]), {x+dx[i], y+dy[i]}});
		}
	}
	sort(v.begin(), v.end());
	for (int i = 0; i < (int)v.size(); i++) {
		mat[v[i].S.F][v[i].S.S] = pos+1;
		if (dfs(v[i].S.F, v[i].S.S, pos+1)) return true;
		mat[v[i].S.F][v[i].S.S] = 0;
	}
	return false;
}
 
int main () { _
	int x, y;
	cin >> x >> y;
	x--, y--;
	mat[y][x] = 1;
	dfs(y, x, 1);
	for (int i = 0; i < 8; i++) {
		for (int j = 0; j < 8; j++) {
			cout << mat[i][j] << ' ';
		}
		cout << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{Labyrinth}
\begin{lstlisting}
// Problem name: Labyrinth
// Problem Link: https://cses.fi/problemset/task/1193
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
using namespace std;
#define MAXN 1003
#define MAXS 1003
int n, m, inix, iniy, fimx, fimy;
int vis[MAXN][MAXS];
char path[MAXN][MAXS];
char mapa[MAXN][MAXS];
int varx[] = {1, -1, 0, 0};
int vary[] = {0, 0, 1, -1};
int BFS(int a, int b) {
    queue<pair<int,int>> q;
    q.push({a, b});
	mapa[a][b] = '#';
    while(!q.empty()) {
        int x = q.front().first;
        int y = q.front().second;
        q.pop();
        for (int i = 0; i < 4; i++) {
            int X = varx[i] + x;
            int Y = vary[i] + y;
            if (X <= 0 || X > n || Y <= 0 || Y > m || mapa[X][Y] == '#') continue;
            q.push({X, Y});
            vis[X][Y] = vis[x][y] + 1;
			bool fim = (mapa[X][Y] == 'B');
	        mapa[X][Y] = '#';
            if (i == 0) path[X][Y] = 'D';
            else if (i == 1) path[X][Y] = 'U';
            else if (i == 2) path[X][Y] = 'R';
            else path[X][Y] = 'L';
            if (fim) {
                fimx = X;
                fimy = Y;
                return vis[X][Y];
            }
        }
    }
    return 0;
}
 
int main() {
    memset(vis, 0, sizeof(vis));
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> mapa[i][j];
            if (mapa[i][j] == 'A') {
                inix = i;
                iniy = j;
            }
        }
    }
    int resposta = BFS(inix, iniy);
	if (!resposta) cout << "NO\n";
	else {
		cout << "YES\n";
		cout << resposta << endl;
		vector<char> caminho;
		int i = fimx, j = fimy;
		while (make_pair(i, j) != make_pair(inix, iniy)) {
			caminho.push_back(path[i][j]);
			if (path[i][j] == 'D') i--;
			else if (path[i][j] == 'U') i++;
			else if (path[i][j] == 'R') j--;
			else j++;
		}
		for (int i = caminho.size()-1; i >= 0; i--) {
			cout << caminho[i];
		}
		cout << '\n';
	}
}
\end{lstlisting}

\subsection{Longest Flight Route}
\begin{lstlisting}
// Problem name: Longest Flight Route
// Problem Link: https://cses.fi/problemset/task/1680
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int dp[MAXN], check[MAXN], go[MAXN], n;
vector<int> v[MAXN];
 
void dfs(int node) {
    dp[node] = (node == n ? 0 : -1e6);
    for (int x : v[node]) {
        if (!check[x]) dfs(x);
        check[x] = 1;
        if (dp[x] >= dp[node]) {
            dp[node] = 1 + dp[x];
            go[node] = x;
        }
    }
}
 
int main () { _
    int m;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        v[a].pb(b);
    }
    dfs(1);
    if (dp[1] < 0) cout << "IMPOSSIBLE\n";
    else {
        cout << dp[1] + 1 << '\n';
        cout << "1 ";
        int atual = go[1];
        while (atual != 0) {
            cout << atual << ' ';
            atual = go[atual];
        }
        cout << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{Mail Delivery}
\begin{lstlisting}
// Problem name: Mail Delivery
// Problem Link: https://cses.fi/problemset/task/1691
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to deliver mail to the inhabitants of a city. For this reason, 
// you want to find a route whose starting and ending point are the post office, 
// and that goes through every street exactly once.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 4000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
stack<int> ans;
vector<pii> v[MAXN];
int grau[MAXN], edge[MAXN];
 
void euler(int node) {
	stack<int> path;
	path.push(node);
	while (!path.empty()) {
		int cur = path.top();
		while (!v[cur].empty() && edge[v[cur].back().S]) {
			grau[cur]--;
			v[cur].pop_back();
		}
		if (!grau[cur]) {
			ans.push(cur);
			path.pop();
			continue;
		}
		pii next = v[cur].back();
		v[cur].pop_back();
		grau[cur]--;
		edge[next.S] = 1;
		path.push(next.F);
	}
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb({b, i});
		v[b].pb({a, i});
		grau[a]++, grau[b]++;
	}
	bool ok = true;
	for (int i = 1; i <= n; i++) {
		ok &= (grau[i] % 2 == 0);
	}
	if (!ok) cout << "IMPOSSIBLE\n";
	else {
		euler(1);
		for (int i = 0; i < m; i++) {
			ok &= edge[i];
		}
		if (!ok) cout << "IMPOSSIBLE\n";
		else {
			while (!ans.empty()) {
				cout << ans.top() << ' ';
				ans.pop();
			}
			cout << '\n';
		}
	}
	return 0;	
}
\end{lstlisting}

\subsection{Message Route}
\begin{lstlisting}
// Problem name: Message Route
// Problem Link: https://cses.fi/problemset/task/1667
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000
#define PB push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int n, m, dist[MAXN], go[MAXN];
vector<int> vizinhos[MAXN];
 
void dijkstra() {
    for (int i = 2; i <= n; i++) dist[i] = INF;
    priority_queue<pii, vector<pii>, greater<pii>> fila;
    dist[1] = 1;
    fila.push({dist[1], 1});
    while (!fila.empty()) {
        int atual = fila.top().S;
        int d = fila.top().F;
        fila.pop();
        if (d > dist[atual]) continue;
        for (int i = 0; i < (int)vizinhos[atual].size(); i++) {
            int prox = vizinhos[atual][i];
            if (dist[prox] > 1 + dist[atual]) {
                dist[prox] = 1 + dist[atual];
                fila.push({dist[prox], prox});
                go[prox] = atual;
            }
        }
    }
}
 
int main() { _
    int a, b;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        vizinhos[a].PB(b);
        vizinhos[b].PB(a);
    }
    dijkstra();
    if (dist[n] == INF) cout << "IMPOSSIBLE" << endl;
    else {
        cout << dist[n] << endl;
        int atual = n;
        stack<int> ans;
        ans.push(atual);
        while (atual != 1) {
            ans.push(go[atual]);
            atual = go[atual];
        }
        while (!ans.empty()) {
            cout << ans.top() << " ";
            ans.pop();
        }
        cout << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{Monsters}
\begin{lstlisting}
// Problem name: Monsters
// Problem Link: https://cses.fi/problemset/task/1194
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1010
#define INF 1000000
#define PB push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int n, m, dist[MAXN][MAXN];
pii go[MAXN][MAXN], a, A;
char v[MAXN][MAXN];
bool ber, check[MAXN][MAXN];
queue<pii> fila;
queue<pair<pii, int>> qu;
 
void BFS_multi() {
    while(!fila.empty()) {
        A = fila.front();
        fila.pop();
        check[A.F][A.S] = true;
        if (A.F + 1 < n && !check[A.F+1][A.S] && v[A.F+1][A.S] != '#') {
            dist[A.F+1][A.S] = min(dist[A.F+1][A.S], 1+dist[A.F][A.S]);
            fila.push({A.F+1, A.S});
            check[A.F+1][A.S] = true;
        }
        if (A.F - 1 >= 0 && !check[A.F-1][A.S] && v[A.F-1][A.S] != '#') {
            dist[A.F-1][A.S] = min(dist[A.F-1][A.S], 1+dist[A.F][A.S]);
            fila.push({A.F-1, A.S});
            check[A.F-1][A.S] = true;
        }
        if (A.S + 1 < m && !check[A.F][A.S+1] && v[A.F][A.S+1] != '#') {
            dist[A.F][A.S+1] = min(dist[A.F][A.S+1], 1+dist[A.F][A.S]);
            fila.push({A.F, A.S+1});
            check[A.F][A.S+1] = true;
        }
        if (A.S - 1 >= 0 && !check[A.F][A.S-1] && v[A.F][A.S-1] != '#') {
            dist[A.F][A.S-1] = min(dist[A.F][A.S-1], 1+dist[A.F][A.S]);
            fila.push({A.F, A.S-1});
            check[A.F][A.S-1] = true;
        }
    }
}
 
pii BFS() {
    while (!qu.empty()) {
        A = qu.front().F;
        if (A.F == 0 || A.F == n-1 || A.S == 0 || A.S == m-1) {
            return A;
        }
        int D = qu.front().S;
        qu.pop();
        check[A.F][A.S] = true;
        if (A.F + 1 < n && !check[A.F+1][A.S] && dist[A.F+1][A.S] > D+1 && v[A.F+1][A.S] != '#') {
            go[A.F+1][A.S] = A;
            qu.push(make_pair(make_pair(A.F+1, A.S), D+1));
            check[A.F+1][A.S] = true;
        }
        if (A.F - 1 >= 0 && !check[A.F-1][A.S] && dist[A.F-1][A.S] > D+1 && v[A.F-1][A.S] != '#') {
            go[A.F-1][A.S] = A;
            qu.push(make_pair(make_pair(A.F-1, A.S), D+1));
            check[A.F-1][A.S] = true;
        }
        if (A.S + 1 < m && !check[A.F][A.S+1] && dist[A.F][A.S+1] > D+1 && v[A.F][A.S+1] != '#') {
            go[A.F][A.S+1] = A;
            qu.push(make_pair(make_pair(A.F, A.S+1), D+1));
            check[A.F][A.S+1] = true;
        }
        if (A.S - 1 >= 0 && !check[A.F][A.S-1] && dist[A.F][A.S-1] > D+1 && v[A.F][A.S-1] != '#') {
            go[A.F][A.S-1] = A;
            qu.push(make_pair(make_pair(A.F, A.S-1), D+1));
            check[A.F][A.S-1] = true;
        }
    }
    return {-1, -1};
}
 
int main() { _
    memset(go, -1, sizeof(go));
    cin >> n >> m;
    int resp = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> v[i][j];
            if (v[i][j] == 'M') {
                dist[i][j] = 0;
                fila.push({i, j});
            }
            else dist[i][j] = INF;
            if (v[i][j] == 'A') a = {i, j};
        }
    }
    BFS_multi();
    memset(check, false, sizeof(check));
    qu.push({a, 0});
    pii fim = BFS();
    if (fim.F == -1) cout << "NO" << endl;
    else {
        cout << "YES" << endl;
        stack<char> ans;
        while(fim != a) {
            if (go[fim.F][fim.S] == make_pair(fim.F+1, fim.S)) ans.push('U');
            else if (go[fim.F][fim.S] == make_pair(fim.F-1, fim.S)) ans.push('D');
            else if (go[fim.F][fim.S] == make_pair(fim.F, fim.S+1)) ans.push('L');
            else ans.push('R');
            resp++;
            fim = go[fim.F][fim.S];
        }
        cout << (int)ans.size() << endl;
        while(!ans.empty()) {
            cout << ans.top();
            ans.pop();
        }
        cout << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{Planets and Kingdoms}
\begin{lstlisting}
// Problem name: Planets and Kingdoms
// Problem Link: https://cses.fi/problemset/task/1683
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A game has n planets, connected by m teleporters. 
// Two planets a and b belong to the same kingdom exactly 
// when there is a route both from a to b and from b to a. 
// Your task is to determine for each planet its kingdom.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int vis[MAXN], cnt = 0, c[MAXN];
vector<int> v[MAXN], w[MAXN], ord;
 
void dfs1(int node) {
	vis[node] = 1;
	for (int x : v[node]) 
		if (!vis[x]) dfs1(x);
	ord.pb(node);
}
 
void dfs2(int node) {
	vis[node] = 1;
	c[node] = cnt;
	for (int x : w[node])
		if (!vis[x]) dfs2(x);
}
 
int main () { _
	int n, m, a, b;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		v[a].pb(b);
		w[b].pb(a);
	}
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) dfs1(i);
	}
	memset(vis, 0, sizeof(vis));
	reverse(ord.begin(), ord.end());
	for (int x : ord) {
		if (!vis[x]) {
			cnt++;
			dfs2(x);
		}
	}
	cout << cnt << '\n';
	for (int i = 1; i <= n; i++) cout << c[i] << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Planets Cycles}
\begin{lstlisting}
// Problem name: Planets Cycles
// Problem Link: https://cses.fi/problemset/task/1751
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are playing a game consisting of n planets. Each planet has a teleporter to another planet (or the planet itself).
// You start on a planet and then travel through teleporters until you reach a planet that you have already visited before.
// Your task is to calculate for each planet the number of teleportations there would be if you started on that planet.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int dist[MAXN], v[MAXN], cor[MAXN];
 
void dfs(int node) {
	cor[node] = 1;
	if (cor[v[node]] == 0) {
		dfs(v[node]);
		if (!dist[node]) dist[node] = dist[v[node]]+1;
	}
	else if (cor[v[node]] == 1) {
		// ciclo
		int atual = node, p = 0;
		do {
			p++;
			atual = v[atual];
		} while (atual != node);
		do {
			dist[atual] = p;
			atual = v[atual];
		} while (atual != node);
	}
	else {
		dist[node] = dist[v[node]]+1;
	}
	cor[node] = 2;
}
 
int main() { _
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> v[i];
	for (int i = 1; i <= n; i++) {
		if (!cor[i]) dfs(i);
	}
	for (int i = 1; i <= n; i++) cout << dist[i] << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Planets Queries I}
\begin{lstlisting}
// Problem name: Planets Queries I
// Problem Link: https://cses.fi/problemset/task/1750
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int tab[31][MAXN];
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> tab[0][i];
	}
	for (int i = 1; i < 31; i++) {
		for (int j = 1; j <= n; j++) {
			tab[i][j] = tab[i-1][tab[i-1][j]];
		}
	}
	for (int i = 0; i < q; i++) {
		int a, b;
		cin >> a >> b;
		int atual = a;
		for (int j = 0; j < 31; j++) {
			if (b & (1<<j)) atual = tab[j][atual];
		}
		cout << atual << '\n';
	}
	return 0;
}
\end{lstlisting}

\subsection{Planets Queries II}
\begin{lstlisting}
// Problem name: Planets Queries II
// Problem Link: https://cses.fi/problemset/task/1160
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are playing a game consisting of n planets. 
// Each planet has a teleporter to another planet (or the planet itself).
// You have to process q queries of the form: You are now on planet a and want to reach planet b. 
// What is the minimum number of teleportations?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int tree[MAXN], ciclo[MAXN], id[MAXN], peso[MAXN], tab[MAXN][20], cor[MAXN], dep[MAXN], in[MAXN], x;
 
int sobe(int node, int k) {
	if (k < 0) return -1;
	for (int i = 19; i >= 0; i--) {
		if (k & (1<<i)) node = tab[node][i];
	}
	return node;
}
 
void dfs(int node) {
	cor[node] = 1;
	if (!cor[tab[node][0]]) dfs(tab[node][0]);
	else if (cor[tab[node][0]] == 1) {
		x++;
		int atual = node, p = 0;
		do {	
			p++;
			ciclo[atual] = x;
			tree[atual] = atual;
			id[atual] = p;
			atual = tab[atual][0];
		} while (atual != node);
		peso[x] = p;
	}
	cor[node] = 2;
}
 
void dfs2(int node) {
	cor[node] = 1;
	if (!cor[tab[node][0]] && !ciclo[tab[node][0]]) dfs2(tab[node][0]);
	tree[node] = tree[tab[node][0]];
	dep[node] = dep[tab[node][0]] + 1;
}
 
int main() { _
	x = 0;
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> tab[i][0];
		in[tab[i][0]]++;
	}
	for (int i = 1; i < 20; i++) {
		for (int j = 1; j <= n; j++) tab[j][i] = tab[tab[j][i-1]][i-1];
	}
	for (int i = 1; i <= n; i++) {
		if (!cor[i]) dfs(i);
	}
	memset(cor, 0, sizeof(cor));
	for (int i = 1; i <= n; i++) {
		if (!in[i]) dfs2(i);
	}
	int a, b;
	for (int i = 0; i < q; i++) {
		cin >> a >> b;
		if (ciclo[a]) {
			if (ciclo[b]) {
				if (ciclo[a] == ciclo[b]) {
					if (id[b] >= id[a]) cout << id[b] - id[a] << '\n';
					else cout << peso[ciclo[b]] + id[b] - id[a] << '\n';
				}
				else cout << "-1\n";
			}
			else if (!ciclo[b]) cout << "-1\n";
		}
		else if (!ciclo[a]) {
			if (!ciclo[b]) {
				if (sobe(a, dep[a] - dep[b]) == b) cout << dep[a] - dep[b] << '\n';
				else cout << "-1\n";
			}
			else if (ciclo[b]) {
				if (ciclo[tree[a]] == ciclo[b]) {
					if (id[b] >= id[tree[a]]) cout << id[b] - id[tree[a]] + dep[a] << '\n';
					else cout << peso[ciclo[b]] + id[b] - id[tree[a]] + dep[a] << '\n';
				}
				else cout << "-1\n";
			}
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{Police Chase}
\begin{lstlisting}
// Problem name: Police Chase
// Problem Link: https://cses.fi/problemset/task/1695
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Kaaleppi has just robbed a bank and is now heading to the harbor. 
// However, the police wants to stop him by closing some streets of the city.
// What is the minimum number of streets that should be closed so that 
// there is no route between the bank and the harbor?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const int INF = 1e9;
 
// Dinic
//
// O(min(m * max_flow, n^2 m))
// Grafo com capacidades 1 -> O(sqrt(n)*m)
struct dinic {
	const bool scaling = false;
	int lim;
	struct edge {
		int to, cap, rev, flow;
		bool res;
		edge(int to_, int cap_, int rev_, bool res_)
			: to(to_), cap(cap_), rev(rev_), flow(0), res(res_) {}
	};
 
	vector<vector<edge>> g;
	vector<int> lev, beg;
	ll F;
	dinic(int n) : g(n), F(0) {}
 
	void add(int a, int b, int c) {
		g[a].emplace_back(b, c, g[b].size(), false);
		g[b].emplace_back(a, 0, g[a].size()-1, true);
	}
	bool bfs(int s, int t) {
		lev = vector<int>(g.size(), -1); lev[s] = 0;
		beg = vector<int>(g.size(), 0);
		queue<int> q; q.push(s);
		while (q.size()) {
			int u = q.front(); q.pop();
			for (auto& i : g[u]) {
				if (lev[i.to] != -1 or (i.flow == i.cap)) continue;
				if (scaling and i.cap - i.flow < lim) continue;
				lev[i.to] = lev[u] + 1;
				q.push(i.to);
			}
		}
		return lev[t] != -1;
	}
	int dfs(int v, int s, int f = INF) {
		if (!f or v == s) return f;
		for (int& i = beg[v]; i < g[v].size(); i++) {
			auto& e = g[v][i];
			if (lev[e.to] != lev[v] + 1) continue;
			int foi = dfs(e.to, s, min(f, e.cap - e.flow));
			if (!foi) continue;
			e.flow += foi, g[e.to][e.rev].flow -= foi;
			return foi;
		}
		return 0;
	}
	ll max_flow(int s, int t) {
		for (lim = scaling ? (1<<30) : 1; lim; lim /= 2)
			while (bfs(s, t)) while (int ff = dfs(s, t)) F += ff;
		return F;
	}
 
	// arestas com fluxo
	vector<pii> flow_edges() {
		vector<pii> ans;
		int n = g.size();
		for (int i = 0; i < n; i++) {
			for (auto edge : g[i]) {
				if (!edge.res && edge.flow) 
					ans.emplace_back(i, edge.to);
			}
		}
		return ans;
	}
 
	// arestas no min cut
	vector<pii> cut_edges(int s, int t) {
		max_flow(s, t);
		vector<pii> cut;
		vector<int> vis(g.size(), 0), st = {s};
		vis[s] = 1;
		while (st.size()) {
			int u = st.back(); st.pop_back();
			for (auto e : g[u]) if (!vis[e.to] and e.flow < e.cap)
				vis[e.to] = 1, st.push_back(e.to);
		}
		for (int i = 0; i < g.size(); i++) for (auto e : g[i])
			if (vis[i] and !vis[e.to] and !e.res) cut.emplace_back(i, e.to);
		return cut;
	}
};
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m;
	cin >> n >> m;
	dinic ber(n);
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		a--, b--;
		ber.add(a, b, 1);
		ber.add(b, a, 1);
	}
	vector<pii> ed = ber.cut_edges(0, n - 1);
	cout << ber.max_flow(0, n - 1) << '\n';
	for (auto x : ed) cout << x.first + 1 << ' ' << x.second + 1 << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Road Construction}
\begin{lstlisting}
// Problem name: Road Construction
// Problem Link: https://cses.fi/problemset/task/1676
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 4000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int pai[MAXN], sz[MAXN], peso[MAXN], comp, maxi;
 
int find(int a) {
	if (pai[a] == a) return a;
	return pai[a] = find(pai[a]);
}
 
void join(int a, int b) {
	a = find(a);
	b = find(b);
	if (a == b) return;
	comp--;
	if (peso[a] > peso[b]) {
		pai[b] = a;
		sz[a] += sz[b];
	}
	if (peso[b] > peso[a]) {
		pai[a] = b;
		sz[b] += sz[a];
	}
	if (peso[a] == peso[b]) {
		pai[a] = b;
		sz[b] += sz[a];
		peso[b]++;
	}
	maxi = max({maxi, sz[a], sz[b]});
	return;
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		pai[i] = i;
		sz[i] = 1;
	}
	comp = n, maxi = 1;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		join(a, b);
		cout << comp << ' ' << maxi << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{Road Reparation}
\begin{lstlisting}
// Problem name: Road Reparation
// Problem Link: https://cses.fi/problemset/task/1675
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int pai[MAXN], peso[MAXN];
vector<pair<int, pii>> v;
 
int find(int a) {
	if (pai[a] == a) return a;
	return pai[a] = find(pai[a]);
}
 
void join(int a, int b) {
	a = find(a);
	b = find(b);
	if (a == b) return;
	if (peso[a] > peso[b]) {
		pai[b] = a;
	}
	if (peso[b] > peso[a]) {
		pai[a] = b;
	}
	if (peso[a] == peso[b]) {
		pai[a] = b;
		peso[b]++;
	}
	return;
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) pai[i] = i;
	for (int i = 0; i < m; i++) {
		int a, b, c;
		cin >> a >> b >> c;
		v.pb({c, {a, b}});
	}
	sort(v.begin(), v.end());
	ll ans = 0;
	int count = 0;
	for (int i = 0; i < m; i++) {
		if (find(v[i].S.F) != find(v[i].S.S)) {
			join(v[i].S.F, v[i].S.S);
			ans += v[i].F;
			count++;
		}
	}
	if (count == n-1) cout << ans << '\n';
	else cout << "IMPOSSIBLE\n";
	return 0;	
}
\end{lstlisting}

\subsection{Round Trip}
\begin{lstlisting}
// Problem name: Round Trip
// Problem Link: https://cses.fi/problemset/task/1669
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000
#define PB push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int n, m, go[MAXN], inicio;
vector<int> viz[MAXN], resp;
bool check[MAXN], ber;
 
void DFS(int node, int pai) {
    check[node] = true;
    for (int i = 0; i < (int)viz[node].size(); i++) {
        int atual = viz[node][i];
        if (!check[atual]) {
            if (!ber) go[atual] = node;
            DFS(atual, node);
        }
        else if (atual != pai and !ber) {
            ber = true;
            inicio = atual;
            go[atual] = node;
        }
    }
}
 
int main() { _
    int a, b;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        viz[a].PB(b);
        viz[b].PB(a);
    }
    for (int i = 1; i <= n; i++) {
        if (!check[i]) {
            resp.PB(i);
            DFS(i, 0);
        }
        if (ber) break;
    }
    if (ber) {
        stack<int> ans;
        ans.push(inicio);
        int atual = go[inicio];
        while (atual != inicio) {
            ans.push(atual);
            atual = go[atual];
        }
        ans.push(atual);
        cout << (int)ans.size() << endl;
        while (!ans.empty()) {
            cout << ans.top() << " ";
            ans.pop();
        }
        cout << endl;
    }
    else cout << "IMPOSSIBLE" << endl;
    return 0;
}
\end{lstlisting}

\subsection{Round Trip II}
\begin{lstlisting}
// Problem name: Round Trip II
// Problem Link: https://cses.fi/problemset/task/1678
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN];
stack<int> ans;
int valid;
int cor[MAXN], go[MAXN];
 
void dfs(int node) {
	cor[node] = 1;
	for (int x : v[node]) {
		if (cor[x] == 1 && ans.empty()) {
			int ini = x;
			valid = node;
			ans.push(x);
			while (valid != ini) {
				ans.push(valid);
				valid = go[valid];
			}
			ans.push(valid);
		}
		if (!cor[x]) {
			go[x] = node;
			dfs(x);
		}
	}
	cor[node] = 2;
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
	}
	for (int i = 1; i <= n && !valid; i++) {
		if (!cor[i]) {
			dfs(i);
		}
	}
	if (!valid) cout << "IMPOSSIBLE\n";
	else {
		cout << ans.size() << '\n';
		while (!ans.empty()) {
			cout << ans.top() << ' ';
			ans.pop();
		}
		cout << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{School Dance}
\begin{lstlisting}
// Problem name: School Dance
// Problem Link: https://cses.fi/problemset/task/1696
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n boys and m girls in a school. Next week a school dance will be organized. 
// A dance pair consists of a boy and a girl, and there are k potential pairs.
// Your task is to find out the maximum number of dance pairs and show how this number can be achieved.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const int INF = 1e9;
 
// Dinic
//
// O(min(m * max_flow, n^2 m))
// Grafo com capacidades 1 -> O(sqrt(n)*m)
struct dinic {
	const bool scaling = false;
	int lim;
	struct edge {
		int to, cap, rev, flow;
		bool res;
		edge(int to_, int cap_, int rev_, bool res_)
			: to(to_), cap(cap_), rev(rev_), flow(0), res(res_) {}
	};
 
	vector<vector<edge>> g;
	vector<int> lev, beg;
	ll F;
	dinic(int n) : g(n), F(0) {}
 
	void add(int a, int b, int c) {
		g[a].emplace_back(b, c, g[b].size(), false);
		g[b].emplace_back(a, 0, g[a].size()-1, true);
	}
	bool bfs(int s, int t) {
		lev = vector<int>(g.size(), -1); lev[s] = 0;
		beg = vector<int>(g.size(), 0);
		queue<int> q; q.push(s);
		while (q.size()) {
			int u = q.front(); q.pop();
			for (auto& i : g[u]) {
				if (lev[i.to] != -1 or (i.flow == i.cap)) continue;
				if (scaling and i.cap - i.flow < lim) continue;
				lev[i.to] = lev[u] + 1;
				q.push(i.to);
			}
		}
		return lev[t] != -1;
	}
	int dfs(int v, int s, int f = INF) {
		if (!f or v == s) return f;
		for (int& i = beg[v]; i < g[v].size(); i++) {
			auto& e = g[v][i];
			if (lev[e.to] != lev[v] + 1) continue;
			int foi = dfs(e.to, s, min(f, e.cap - e.flow));
			if (!foi) continue;
			e.flow += foi, g[e.to][e.rev].flow -= foi;
			return foi;
		}
		return 0;
	}
	ll max_flow(int s, int t) {
		for (lim = scaling ? (1<<30) : 1; lim; lim /= 2)
			while (bfs(s, t)) while (int ff = dfs(s, t)) F += ff;
		return F;
	}
 
	// arestas com fluxo
	vector<pii> flow_edges() {
		vector<pii> ans;
		int n = g.size();
		for (int i = 0; i < n; i++) {
			for (auto edge : g[i]) {
				if (!edge.res && edge.flow) 
					ans.emplace_back(i, edge.to);
			}
		}
		return ans;
	}
 
	// arestas no min cut
	vector<pii> cut_edges(int s, int t) {
		max_flow(s, t);
		vector<pii> cut;
		vector<int> vis(g.size(), 0), st = {s};
		vis[s] = 1;
		while (st.size()) {
			int u = st.back(); st.pop_back();
			for (auto e : g[u]) if (!vis[e.to] and e.flow < e.cap)
				vis[e.to] = 1, st.push_back(e.to);
		}
		for (int i = 0; i < g.size(); i++) for (auto e : g[i])
			if (vis[i] and !vis[e.to] and !e.res) cut.emplace_back(i, e.to);
		return cut;
	}
};
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, m, k;
	cin >> n >> m >> k;
	int src = n + m, snk = n + m + 1;
	dinic ber(snk + 1);
	for (int i = 0; i < k; i++) {
		int a, b;
		cin >> a >> b;
		a--, b--;
		ber.add(a, n + b, 1);
	}
	for (int i = 0; i < n; i++) {
		ber.add(src, i, 1);
	}
	for (int i = 0; i < m; i++) {
		ber.add(i + n, snk, 1);
	}
	cout << ber.max_flow(src, snk) << '\n';
	vector<pii> ed = ber.flow_edges();
	for (auto x : ed) {
		if (x.first != src && x.second != snk) cout << x.first + 1 << ' ' << x.second - n + 1 << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{Shortest Routes I}
\begin{lstlisting}
// Problem name: Shortest Routes I
// Problem Link: https://cses.fi/problemset/task/1671
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000000000000LL
#define PB push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int n, m;
lli dist[MAXN];
vector<pair<lli, int>> viz[MAXN];
 
void dijkstra() {
    for (int i = 2; i <= n; i++) dist[i] = INF;
    dist[1] = 0LL;
    priority_queue <pair<lli, int>, vector<pair<lli, int>>, greater<pair<lli, int>>> fila;
    fila.push({dist[1], 1});
    while(!fila.empty()) {
        int atual = fila.top().S;
        lli d = fila.top().F;
        fila.pop();
        if (d > dist[atual]) continue;
        for (auto v : viz[atual]) {
            if (dist[v.S] > d + v.F) {
                dist[v.S] = d + v.F;
                fila.push({dist[v.S], v.S});
            }
        }
    }
}
 
int main () { _
    int a, b;
    lli c;
    cin >> n >> m;
    for (int i = 0; i < m; i++) {
        cin >> a >> b >> c;
        viz[a].PB({c, b});
    }
    dijkstra();
    for (int i = 1; i <= n; i++) {
        cout << dist[i] << " ";
    }
    cout << endl;
    return 0;
}
\end{lstlisting}

\subsection{Shortest Routes II}
\begin{lstlisting}
// Problem name: Shortest Routes II
// Problem Link: https://cses.fi/problemset/task/1672
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 505
#define INF 1000000000000000LL
#define PB push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
const int mod = 1e9+7;
 
int n, m;
lli dist[MAXN][MAXN];
 
void FW() {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            for (int k = 1; k <= n; k++) {
                dist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);
            }
        }
    }
}
 
int main () { _
    int a, b, q;
    lli c;
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            dist[i][j] = INF;
        }
    }
    for (int i = 0; i < m; i++) {
        cin >> a >> b >> c;
        dist[a][b] = dist[b][a] = min(dist[a][b], c);
    }
    for (int i = 1; i <= n; i++) dist[i][i] = 0;
    FW();
    for (int i = 0; i < q; i++) {
        cin >> a >> b;
        if (dist[a][b] == INF) cout << "-1" << endl;
        else cout << dist[a][b] << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{Teleporters Path}
\begin{lstlisting}
// Problem name: Teleporters Path
// Problem Link: https://cses.fi/problemset/task/1693
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A game has n levels and m teleportes between them. 
// You win the game if you move from level 1 to level n using every teleporter exactly once.
// Can you win the game, and what is a possible way to do it?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 4000100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
stack<int> ans;
vector<pii> v[MAXN];
int grau[MAXN], num[MAXN], edge[MAXN];
 
void euler(int node) {
	stack<int> path;
	path.push(node);
	while (!path.empty()) {
		int cur = path.top();
		if (!num[cur]) {
			ans.push(cur);
			path.pop();
		}
		else {
			pii next = v[cur].back();
			v[cur].pop_back();
			num[cur]--;
			edge[next.S] = 1;
			path.push(next.F);
		}
	}
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb({b, i});
		grau[a]++;
		grau[b]--;
		num[a]++;
	}
	bool valid = (grau[1] == 1 && grau[n] == -1);
	for (int i = 2; i < n; i++) valid &= (grau[i] == 0);
	if (!valid) cout << "IMPOSSIBLE\n";
	else {
		euler(1);
		for (int i = 0; i < m; i++) valid &= edge[i];
		if (!valid) cout << "IMPOSSIBLE\n";
		else {
			while (!ans.empty()) {
				cout << ans.top() << ' ';
				ans.pop();
			}
			cout << '\n';
		}
	}
	return 0;	
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% CSES - Introductory Problems
%
%%%%%%%%%%%%%%%%%%%%

\section{CSES - Introductory Problems}

\subsection{Apple Division}
\begin{lstlisting}
// Problem name: Apple Division
// Problem Link: https://cses.fi/problemset/task/1623
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
 
using namespace std;
typedef long long int lli;
 
int n, aux;
lli soma = 0;
vector <int> v;
 
lli dp(lli atual, int id) {
    if (id == n) return abs(soma - 2*atual);
    if ((atual + v[id])*2 <= soma) {
        return min (dp(atual + v[id], id+1), dp (atual, id+1));
    }
    return dp (atual, id+1);
}
 
bool ordem (int a, int b) { return a < b; }
 
int main() { _
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> aux;
        soma += aux;
        v.push_back(aux);
    }
    sort(v.begin(), v.end(), ordem);
    lli resp = dp(0, 0);
    cout << resp << endl;
    return 0;
}
\end{lstlisting}

\subsection{Bit Strings}
\begin{lstlisting}
// Problem name: Bit Strings
// Problem Link: https://cses.fi/problemset/task/1617
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
const int big = 1e9+7;
 
int main() { _
    int n, resp = 1;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        resp *= 2;
        resp %= big;
    }
    cout << resp << endl;
    return 0;
}
\end{lstlisting}

\subsection{Chessboard and Queens}
\begin{lstlisting}
// Problem name: Chessboard and Queens
// Problem Link: https://cses.fi/problemset/task/1624
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
 
const int mod = 1e9 + 7;
const int n_q = 8;
 
bool m[n_q][n_q];
 
int queen(int n) {
    if (n == n_q) return 1;
    int resp = 0;
    bool aux[n_q][n_q];
    for (int i = 0; i < n_q; i++) {
        for (int j = 0; j < n_q; j++) {
            aux[i][j] = m[i][j];
        }
    }
    int i = n;
    for (int j = 0; j < n_q; j++) {
        if (m[i][j]) {
            for (int k = 0; k < n_q; k++) {
                m[i][k] = m[k][j] = false;
                for (int l = 0; l < n_q; l++) {
                    if ((i-j) == (k-l) or (i+j) == (k+l)) m[k][l] = false;
                }
            }
            resp += queen(n+1);
            for (int k = 0; k < n_q; k++) {
                for (int l = 0; l < n_q; l++) {
                    m[k][l] = aux[k][l];
                }
            }
        }
    }
    return resp;
}
 
int main () { _
    char c;
    for (int i = 0; i < n_q; i++) {
        for (int j = 0; j < n_q; j++) {
            cin >> c;
            if (c == '*') m[i][j] = false;
            else m[i][j] = true;
        }
    }
    cout << queen(0) << endl;
    return 0;
}
\end{lstlisting}

\subsection{Coin Piles}
\begin{lstlisting}
// Problem name: Coin Piles
// Problem Link: https://cses.fi/problemset/task/1754
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
const int big = 1e9+7;
 
int main() { _
    int t, a, b;
    bool ber;
    cin >> t;
    for (int i = 0; i < t; i++) {
        ber = true;
        cin >> a >> b;
        int mod1 = a%3;
        int mod2 = b%3;
        if (a > 2*b or b > 2*a) ber = false;
        if ((mod1 == 0 and mod2 != 0) or (mod2 == 0 and mod1 != 0)) ber = false;
        if ((mod1 == 1 and mod2 != 2) or (mod2 == 1 and mod1 != 2)) ber = false;
        if ((mod1 == 2 and mod2 != 1) or (mod2 == 2 and mod1 != 1)) ber = false;
        if (ber) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{Creating Strings}
\begin{lstlisting}
// Problem name: Creating Strings
// Problem Link: https://cses.fi/problemset/task/1622
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
 
const int mod = 1e9 + 7;
const int n_q = 5;
 
int v[26], ans = 0;
string s, respostas[50000];
 
void permutations (string resp) {
    for (int i = 0; i < 26; i++) {
        if (v[i] > 0) {
            v[i]--;
            char nova = i+97;
            resp.push_back(nova);
            permutations(resp);
            v[i]++;
            resp.pop_back();
        }
    }
    if ((int)resp.size() == (int)s.size()) {
        respostas[ans] = resp;
        ans++;   
    }
    
}
 
int main () { _
    cin >> s;
    for (int i = 0; i < (int)s.size(); i++) {
        v[s.at(i)-97]++;
    }
    string ini = "";
    permutations(ini);
    cout << ans << endl;
    for (int i = 0; i < ans; i++) {
        cout << respostas[i] << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{Digit Queries}
\begin{lstlisting}
// Problem name: Digit Queries
// Problem Link: https://cses.fi/problemset/task/2431
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Consider an infinite string that consists of all positive integers in increasing order:
// 12345678910111213141516171819202122232425...
// Your task is to process q queries of the form: what is the digit at position k in the string?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int q;
	cin >> q;
	while (q--) {
		ll k;
		cin >> k;
		ll count = 1, minus = 9;
		while (k - minus > 0) {
			k -= minus;
			minus /= count;
			count++;
			minus *= 10 * count;
		}
		ll num = (k-1)/count + 1;
		ll base = 0, soma = 9;
		for (int i = 0; i < count-1; i++) {
			base += soma;
			soma *= 10;
		}
		string ans = to_string(base+num);
		int alga;
		if (k % count == 0) alga = count-1;
		else alga = k % count - 1;
		cout << ans[alga] << endl;
	}
	return 0;
}
\end{lstlisting}

\subsection{Gray Code}
\begin{lstlisting}
// Problem name: Gray Code
// Problem Link: https://cses.fi/problemset/task/2205
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
 
using namespace std;
typedef long long int lli;
 
vector <string> v(MAXN);
 
int main() { _
    int n, atual = 2, tam = 2;
    cin >> n;
    v[0] = '0';
    v[1] = '1';
    while (atual <= n) {
        for (int i = 0; i < tam; i++) {
            v[2*tam-i-1] = v[i];
            v[i].push_back('0');
            v[2*tam-i-1].push_back('1');
        }
        tam *= 2;
        atual++;
    }
    for (int i = 0; i < tam; i++) {
        cout << v[i] << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{Grid Paths}
\begin{lstlisting}
// Problem name: Grid Paths
// Problem Link: https://cses.fi/problemset/task/1625
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are 88418 paths in a 7×7 grid from the upper-left square to the lower-left square. 
// Each path corresponds to a 48-character description consisting of characters D (down), U (up), L (left) and R (right).
// You are given a description of a path which may also contain characters ? (any direction). 
// Your task is to calculate the number of paths that match the description.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1e6+2
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
string s;
int check[7][7], dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};
char c[4] = {'D', 'U', 'R', 'L'};
bool valid(int x, int y) { return (x >= 0 && x < 7 && y >= 0 && y < 7 && !check[x][y]); }
bool miou(int x, int y) {
	if (x == 6 && y == 0) return true;
	if (valid(x+1, y) && valid(x-1, y) && !valid(x, y+1) && !valid(x, y-1)) return true;
	if (!valid(x+1, y) && !valid(x-1, y) && valid(x, y+1) && valid(x, y-1)) return true;
	if (valid(x+1, y) && valid(x, y+1) && !valid(x+1, y+1)) return true;
	if (valid(x+1, y) && valid(x, y-1) && !valid(x+1, y-1)) return true;
	if (valid(x-1, y) && valid(x, y-1) && !valid(x-1, y-1)) return true;
	if (valid(x-1, y) && valid(x, y+1) && !valid(x-1, y+1)) return true;
	return false;
}
 
int count(int x, int y, int pos) {
	if (pos == 48) return 1;
	int ans = 0;
	if (miou(x, y)) return 0;
	check[x][y] = 1;
	for (int i = 0; i < 4; i++) {
		if (valid(x + dx[i], y + dy[i]) && (s[pos] == '?' || s[pos] == c[i]))
			ans += count(x + dx[i], y + dy[i], pos + 1);
	}
	check[x][y] = 0;
	return ans;
}
 
int main () { _
	cin >> s;
	cout << count(0, 0, 0) << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Increasing Array}
\begin{lstlisting}
// Problem name: Increasing Array
// Problem Link: https://cses.fi/problemset/task/1094
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
int main() { _
    int n, v[MAXN], atual = 0;
    cin >> n;
    lli resp = 0;
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        if (v[i] >= atual) atual = v[i];
        else resp += atual - v[i];
    }
    cout << resp << endl;
    return 0;
}
\end{lstlisting}

\subsection{Missing Number}
\begin{lstlisting}
// Problem name: Missing Number
// Problem Link: https://cses.fi/problemset/task/1083
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n, aux;
	cin >> n;
	vector<int> check(n+1);
	for (int i = 0; i < n - 1; i++) {
		cin >> aux;
		check[aux] = 1;
	}
	for (int i = 1; i <= n; i++) {
		if (!check[i]) {
			cout << i << "\n";
			break;
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{Number Spiral}
\begin{lstlisting}
// Problem name: Number Spiral
// Problem Link: https://cses.fi/problemset/task/1071
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
int main() { _
    int t, x, y;
    lli resp;
    cin >> t;
    for (int i = 0; i < t; i++) {
        cin >> x >> y;
        if (x > y) {
            if (x%2==0) {
                resp = (1ll)*x*x - y + 1;
            }
            else {
                resp = (1ll)*(x-1)*(x-1) + y;
            }
        }
        else {
            if (y%2==0) {
                resp = (1ll)*(y-1)*(y-1) + x; 
            }
            else {
                resp = (1ll)*y*y - x + 1;
            }
        }
        cout << resp << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{Palindrome Reorder}
\begin{lstlisting}
// Problem name: Palindrome Reorder
// Problem Link: https://cses.fi/problemset/task/1755
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
 
using namespace std;
typedef long long int lli;
 
const int big = 1e9+7;
 
int c[27], impar = 0, id_i;
 
int main() { _
    string s;
    vector<char> pa;
    cin >> s;
    for (int i = 0; i < (int)s.size(); i++) {
        c[s.at(i)-64]++;
    }
    for (int i = 1; i <= 26; i++) {
        if (c[i] % 2 != 0) {
            impar++;
            id_i = i;
        }
    }
    if (impar > 1) cout << "NO SOLUTION" << endl;
    else {
        for (int i = 1; i <= 26; i++) {
            for (int j = 0; j < c[i]/2; j++) {
                pa.push_back(i+64);
            }
        }
        for (int i = 0; i < (int)pa.size(); i++) {
            cout << pa[i];
        }
        if (impar == 1) cout << (char)(id_i+64);
        for (int i = (int)pa.size()-1; i >= 0; i--) {
            cout << pa[i];
        }
        cout << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{Permutations}
\begin{lstlisting}
// Problem name: Permutations
// Problem Link: https://cses.fi/problemset/task/1070
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n;
	cin >> n;
	if (n == 1) cout << "1\n";
	else if (n < 4) cout << "NO SOLUTION\n";
	else {
		int start = n/2 + 1;
		for (int i = 1; i < start; i++) {
			cout << start + i - 1 << " " << i << " ";
		}
		if (n % 2 == 1) cout << 2*start - 1;
		cout << "\n";
	}
	return 0;
}
\end{lstlisting}

\subsection{Repetitions}
\begin{lstlisting}
// Problem name: Repetitions
// Problem Link: https://cses.fi/problemset/task/1069
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	string s;
	cin >> s;
	int ans = 1;
	int count = 1;
	for (int i = 1; i < (int)s.size(); i++) {
		if (s[i] == s[i-1]) count++;
		else {
			ans = max(ans, count);
			count = 1;
		}
	}
	ans = max(ans, count);
	cout << ans << "\n";
	return 0;
}
\end{lstlisting}

\subsection{Tower of Hanoi}
\begin{lstlisting}
// Problem name: Tower of Hanoi
// Problem Link: https://cses.fi/problemset/task/2165
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
 
using namespace std;
typedef long long int lli;
 
void hanoi (int discos, int ini, int fim) {
    if (discos == 1) {
        cout << ini << " " << fim << endl;
    }
    else {
        int outro = 6-ini-fim;
        hanoi (discos-1, ini, outro);
        cout << ini << " " << fim << endl;
        hanoi (discos-1, outro, fim);
    }
}
 
int main() { _
    int n;
    cin >> n;
    cout << (int)(pow(2, n)-1) << endl;
    hanoi (n, 1, 3);
    return 0;
}
\end{lstlisting}

\subsection{Trailing Zeros}
\begin{lstlisting}
// Problem name: Trailing Zeros
// Problem Link: https://cses.fi/problemset/task/1618
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
const int big = 1e9+7;
 
int main() { _
    int n, resp = 0, div = 5;
    cin >> n;
    while (div <= n) {
        resp += n/div;
        div *= 5;
    }
    cout << resp << endl;
    return 0;
}
\end{lstlisting}

\subsection{Two Knights}
\begin{lstlisting}
// Problem name: Two Knights
// Problem Link: https://cses.fi/problemset/task/1072
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
int main() { _
    int n;
    lli resp;
    cin >> n;
    if (n >= 1) cout << "0" << endl;
    if (n >= 2) cout << "6" << endl;
    if (n >= 3) cout << "28" << endl;
    for (int i = 4; i <= n; i++) {
        resp = 0LL;
        resp += (1ll)*(i*i - 3)*4;
        resp += (1ll)*(i*i - 4)*8;
        resp += (1ll)*(i*i - 5)*(4 + 4*(i-4));
        resp += (1ll)*(i*i - 7)*(4*(i-4));
        resp += (1ll)*(i*i - 9)*(i-4)*(i-4);
        cout << resp/2 << endl;
    }
    return 0;
}
\end{lstlisting}

\subsection{Two Sets}
\begin{lstlisting}
// Problem name: Two Sets
// Problem Link: https://cses.fi/problemset/task/1092
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
int main() { _
    int n;
    cin >> n;
    vector<int> v1, v2;
    if (n % 2 == 0) {
        if (n % 4 != 0) cout << "NO" << endl;
        else {
            for (int i = 1; i <= n/4; i++) {
                v1.push_back(i);
                v1.push_back(n-i+1);
            }
            for (int i = n/4 + 1; i <= n/2; i++) {
                v2.push_back(i);
                v2.push_back(n-i+1);
            }
            cout << "YES" << endl;
            cout << (int)v1.size() << endl;
            for (int i = 0; i < (int)v1.size(); i++) {
                cout << v1[i] << " ";
            }
            cout << endl << (int)v2.size() << endl;
            for (int i = 0; i < (int)v2.size(); i++) {
                cout << v2[i] << " ";
            }
            cout << endl;
        }
    }
    else {
        if ((n+1) % 4 != 0) cout << "NO" << endl;
        else {
            bool ber = true;
            for (int i = 1; i <= n; i++) {
                if (ber) v1.push_back(i);
                else v2.push_back(i);
                if (i%2 == 0) ber = 1 - ber;
            }
            cout << "YES" << endl;
            cout << (int)v1.size() << endl;
            for (int i = 0; i < (int)v1.size(); i++) {
                cout << v1[i] << " ";
            }
            cout << endl << (int)v2.size() << endl;
            for (int i = 0; i < (int)v2.size(); i++) {
                cout << v2[i] << " ";
            }
            cout << endl;
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{Weird Algorithm}
\begin{lstlisting}
// Problem name: Weird Algorithm
// Problem Link: https://cses.fi/problemset/task/1068
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	ll n;
	cin >> n;
	while (n != 1) {
		cout << n << " ";
		if (n % 2 == 0) n /= 2;
		else n = 3 * n + 1;
	}
	cout << n << "\n";
	return 0;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% CSES - Mathematics
%
%%%%%%%%%%%%%%%%%%%%

\section{CSES - Mathematics}

\subsection{Another Game}
\begin{lstlisting}
// Problem name: Another Game
// Problem Link: https://cses.fi/problemset/task/2208
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n heaps of coins and two players who move alternately. 
// On each move, a player selects some of the nonempty heaps and removes one coin from each heap. 
// The player who removes the last coin wins the game.
//Your task is to find out who wins if both players play optimally.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int t;
    cin >> t;
    while (t--) {
        int n, aux;
        cin >> n;
        bool ans = false;
        for (int i = 0; i < n; i++) {
            cin >> aux;
            ans |= (aux&1);
        }
        cout << (ans ? "first\n" : "second\n");
    }
    return 0;
}
\end{lstlisting}

\subsection{Binomial Coefficients}
\begin{lstlisting}
// Problem name: Binomial Coefficients
// Problem Link: https://cses.fi/problemset/task/1079
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, int e) {
    ll resp = 1;
    while (e) {
        if (e&1) resp = (resp * b) % M;
        e >>= 1;
        b = (b * b) % M;
    }
    return resp;
}
 
int main () { _
    vector<int> fat(1e6+10), inv(1e6+10);
    fat[0] = fat[1] = 1;
    for (int i = 2; i <= 1e6; i++) {
        fat[i] = ((ll) fat[i-1] * i) % M;
    }
    inv[1e6] = fexp(fat[1e6], M-2);
    for (int i = 1e6-1; i >= 0; i--) {
        inv[i] = ((ll) inv[i+1] * (i+1)) % M;
    }
    int n, a, b;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a >> b;
        cout << (((ll) fat[a] * inv[b]) % M * inv[a-b]) % M << '\n';
    }
    return 0;   
}
\end{lstlisting}

\subsection{Bracket Sequences I}
\begin{lstlisting}
// Problem name: Bracket Sequences I
// Problem Link: https://cses.fi/problemset/task/2064
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to calculate the number of valid bracket sequences of length n. 
// For example, when n=6, there are 5 sequences

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> fat(2, 1);
 
int fexp(ll b, int e) {
    ll resp = 1;
    while(e) {
        if(e&1) resp = (resp * b) % M;
        b = (b*b) % M;
        e = (e>>1);
    }
    return resp;
}
 
int main () { _
    int n;
    ll f = 1;
    for (int i = 2; i < 3e6; i++) {
        f = (f*i) % M;
        fat.pb(f);
    }
    cin >> n;
    if (n&1) cout << "0\n";
    else {
        n /= 2;
        ll ans = ((ll)fat[2*n] * fexp(fat[n], M-2)) % M;
        ans = (ans * fexp(n+1, M-2)) % M;
        ans = (ans * fexp(fat[n], M-2)) % M;
        cout << ans << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{Bracket Sequences II}
\begin{lstlisting}
// Problem name: Bracket Sequences II
// Problem Link: https://cses.fi/problemset/task/2187
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to calculate the number of valid bracket sequences of length n when a prefix of the sequence is given.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
	int n;
	string s;
	cin >> n >> s;
	int x = 0, y = 0;
	bool valid = true;
	for (int i = 0; i < (int)s.size(); i++) {
		x += (s[i] == '(');
		y += (s[i] == ')');
		valid &= (x >= y);
	}
	vector<ll> fat(2e6+10, 1), inv(1e6+10);
	for (int i = 2; i <= 2e6; i++) {
		fat[i] = (fat[i-1] * i) % M;
	}	
	ll b = fat[1e6], e = M-2, resp = 1;
	while (e) {
		if (e&1) resp = resp * b % M;
		e = (e>>1);
		b = b * b % M;
	}
	inv[1e6] = resp;
	for (int i = 1e6-1; i >= 0; i--) {
		inv[i] = (inv[i+1] * (i+1)) % M;
	}
	if (!valid || x > n/2 || n&1) cout << "0\n";
	else if (x == n/2) cout << "1\n";
	else {
		ll ans = fat[n - x - y] * inv[n/2 - x] % M;
		ans = ans * inv[n/2 - y] % M;
		ll tira = fat[n - x - y] * inv[n/2 - y + 1] % M;
		tira = tira * inv[n/2 - x - 1] % M;
		ans -= tira;
		if (ans < 0) ans += M;
		cout << ans << '\n';
	}
	return 0;
}
\end{lstlisting}

\subsection{Candy Lottery}
\begin{lstlisting}
// Problem name: Candy Lottery
// Problem Link: https://cses.fi/problemset/task/1727
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n children, and each of them independently gets a random integer number of candies between 1 and k.
// What is the expected maximum number of candies a child gets?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
	int n, x;
	cin >> n >> x;
	vector<vector<double>> dp(105, vector<double> (105));
	for (int i = 1; i <= x; i++) dp[n][i] = i;
	for (int i = n-1; i >= 0; i--) {
		for (int j = 1; j <= x; j++) {
			for (int k = 1; k <= x; k++) {
				dp[i][j] += 1.0 * dp[i+1][max(j, k)] / x;
			}
		}
	}
	cout << setprecision(6) << fixed;
	cout << dp[0][1] << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Christmas Party}
\begin{lstlisting}
// Problem name: Christmas Party
// Problem Link: https://cses.fi/problemset/task/1717
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n;
    cin >> n;
    ll ans = 0;
    for (int i = 2; i <= n; i++) {
        ans = (ans * i + (i&1 ? - 1 : 1)) % M;
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Common Divisors}
\begin{lstlisting}
// Problem name: Common Divisors
// Problem Link: https://cses.fi/problemset/task/1081
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an array of n positive integers. 
// Your task is to find two integers such that their greatest common divisor is as large as possible.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	ll n, aux;
	cin >> n;
	vector<int> v(1e6+10), c(1e6+10);
	for (int i = 0; i < n; i++) {
		cin >> aux;
		v[aux]++;
	}
	int resp = 0;
	for (int i = 1e6; !resp &&  i > 0; i--) {
		for (int j = i; !resp && j <= 1e6; j+=i) {
			c[i]+=v[j];
			if (c[i] > 1) resp = i;
		}
	}
	cout << resp << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{Counting Coprime Pairs}
\begin{lstlisting}
// Problem name: Counting Coprime Pairs
// Problem Link: https://cses.fi/problemset/task/2417
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a list of n positive integers, your task is to 
// count the number of pairs of integers that are coprime 
// (i.e., their greatest common divisor is one).

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	ll n, aux;
	cin >> n;
	vector<ll> c(1e6+10), t(1e6+10, -1), p(1e6+10, 1);
	for (int i = 0; i < n; i++) {
		cin >> aux;
		c[aux]++;
	}
	ll ans = (n * (n-1)) / 2;
	ll valid = 0;
	for (int i = 2; i <= 1e6; i++) {
		if (p[i]) {
			t[i] = 1;
			for (int j = 2*i; j <= 1e6; j+=i) {
				p[j] = 0;
				if (j/i % i == 0) t[j] = 0;
				else t[j] = 0 - t[j];
			}
		}
	}
	for (int i = 2; i <= 1e6; i++) {
		if (t[i]) {
			ll total = 0;
			for (int j = i; j <= 1e6; j+=i) total += c[j];
			valid += t[i] * (total * (total-1)) / 2;
		}
	}
	cout << ans - valid << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{Counting Divisors}
\begin{lstlisting}
// Problem name: Counting Divisors
// Problem Link: https://cses.fi/problemset/task/1713
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int t;
    cin >> t;
    vector<int> div(MAXN, 1);
    for (int i = 2; i < 1e6+1; i++) {
        for (int j = i; j < 1e6+1; j+=i) div[j]++;
    }
    while (t--) {
        int n;
        cin >> n;
        cout << div[n] << '\n';
    }    
    return 0;
}
\end{lstlisting}

\subsection{Counting Grids}
\begin{lstlisting}
// Problem name: Counting Grids
// Problem Link: https://cses.fi/problemset/task/2210
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to count the number of different n×n grids whose each square is black or white.
// Two grids are considered to be different if it is not possible to rotate one of them so that they look the same.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
ll fexp(ll b, int e) {
    ll resp = 1;
    while(e) {
        if(e&1) resp = (resp * b) % M;
        b = (b*b) % M;
        e = (e>>1);
    }
    return resp;
}
 
int main () { _
    ll n;
    cin >> n;
    if (n == 1) cout << "2\n";
    else {
        ll total = (n*n);
        ll ans = fexp(2, total % (M-1));
        ans += 2*fexp(2, (total/4 + (n&1)) % (M-1));
        ans += fexp(2, (total/2 + (n&1)) % (M-1));
        cout << (ans * fexp(4, M-2)) % M << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{Counting Necklaces}
\begin{lstlisting}
// Problem name: Counting Necklaces
// Problem Link: https://cses.fi/problemset/task/2209
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to count the number of different necklaces that consist of n pearls and each pearl has m possible colors.
// Two necklaces are considered to be different if it is not possible to rotate one of them so that they look the same.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, int e) {
    ll resp = 1;
    while(e) {
        if(e&1) resp = (resp * b) % M;
        b = (b*b) % M;
        e = (e>>1);
    }
    return resp;
}
 
int main () { _
    int n, m;
    cin >> n >> m;
    ll ans = 0;
    for (int i = 1; i <= n; i++) {
        ans += fexp(m, __gcd(i, n));
        if (ans >= M) ans -= M;
    }
    cout << (ans * fexp(n, M-2)) % M << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Creating Strings II}
\begin{lstlisting}
// Problem name: Creating Strings II
// Problem Link: https://cses.fi/problemset/task/1715
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, int e) {
    ll resp = 1;
    while (e) {
        if (e&1) resp = (resp * b) % M;
        e >>= 1;
        b = (b * b) % M;
    }
    return resp;
}
 
int main () { _
    string s;
    cin >> s;
    vector<int> v(30), fat(1e6+10);
    int n = (int)s.size();
    for (int i = 0; i < n; i++) {
        v[s[i] - 'a']++;
    }
    ll ans = 1;
    fat[0] = fat[1] = 1;
    for (int i = 2; i <= n; i++) {
        ans = (ans * i) % M;
        fat[i] = ans;
    }
    for (int i = 0; i < 30; i++) {
        ans = (ans * fexp(fat[v[i]], M-2)) % M;
    }
    cout << ans << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{Dice Probability}
\begin{lstlisting}
// Problem name: Dice Probability
// Problem Link: https://cses.fi/problemset/task/1725
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You throw a dice n times, and every throw produces an outcome between 1 and 6. 
// What is the probability that the sum of outcomes is between a and b?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
	int n, a, b;
	cin >> n >> a >> b;
	vector<double> dp(605), ini(7);
	dp[0] = 1;
	for (int i = 1; i <= 6; i++) ini[i] = 1.0 / 6;
	for (int i = 0; i < n; i++) {
		for (int j = 600; j >= 0; j--) {
			dp[j] = 0;
			for (int k = j-1; k >= max(0, j-6); k--) {
				dp[j] += ini[j-k] * dp[k];
			}
		}
	}
	double ans = 0;
	for (int i = a; i <= b; i++) ans += dp[i];
	cout << setprecision(6) << fixed;
	cout << ans << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Distributing Apples}
\begin{lstlisting}
// Problem name: Distributing Apples
// Problem Link: https://cses.fi/problemset/task/1716
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> fat(2, 1);
 
int fexp(ll b, int e) {
    ll resp = 1;
    while(e) {
        if(e&1) resp = (resp * b) % M;
        b = (b*b) % M;
        e = (e>>1);
    }
    return resp;
}
 
int main () { _
    ll f = 1;
    for (int i = 2; i < 3e6; i++) {
        f = (f*i) % M;
        fat.pb(f);
    }
    int n, m;
    cin >> n >> m;
    ll ans = ((ll)fat[n+m-1] * fexp(fat[n-1], M-2)) % M;
    ans = (ans * fexp(fat[m], M-2)) % M;
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Divisor Analysis}
\begin{lstlisting}
// Problem name: Divisor Analysis
// Problem Link: https://cses.fi/problemset/task/2182
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given an integer, your task is to find the number, sum and product of its divisors. % MOD
// As an example, let us consider the number 12:
//     the number of divisors is 6 (they are 1, 2, 3, 4, 6, 12)
//     the sum of divisors is 1+2+3+4+6+12=28
//     the product of divisors is 1⋅2⋅3⋅4⋅6⋅12=1728
// Since the input number may be large, it is given as a prime factorization.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, ll e) {
    ll resp = 1;
    while (e) {
        if (e&1) resp = (resp * b) % M;
        e >>= 1;
        b = (b * b) % M;
    }
    return resp;
}
 
int main () { _
    int n, x, k, pos;
	cin >> n;
	vector<ll> ans(3, 1);
	vector<pii> v;
	bool odd = true;
	ll exp = 1;
	for (int i = 0; i < n; i++) {
		cin >> x >> k;
		v.pb({x, k});
		if (odd && k&1) {
			odd = false;
			pos = i;
		}
		ans[0] = (ans[0] * (k+1)) % M;
		ll prox = ((ll)(fexp(x, k+1) - 1) * fexp(x-1, M-2)) % M;
        ans[1] = (ans[1] * prox) % M;
	}
	for (int i = 0; i < n; i++) {
		if (!odd && pos == i) {
			exp = (exp * (v[i].S+1)/2) % (M-1);
		}
		else exp = (exp * (v[i].S+1)) %  (M-1);
	}
	for (int i = 0; i < n; i++) {
		if (odd) {
			ans[2] = (ans[2] * fexp(v[i].F, (v[i].S/2) * exp)) % M;
		}
		else {
			ans[2] = (ans[2] * fexp(v[i].F, exp * v[i].S)) % M;
		}
	}
	for (int x : ans) cout << x << ' ';
	cout << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{Exponentiation}
\begin{lstlisting}
// Problem name: Exponentiation
// Problem Link: https://cses.fi/problemset/task/1095
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 10010
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, int e) {
    ll resp = 1;
    while (e) {
        if (e&1) {
            resp = (resp * b) % M;
        }
        e = e >> 1;
        b = (b * b) % M;
    }
    return resp;
}
 
int main () { _
    int n;
    cin >> n;
    while(n--) {
        int a, b;
        cin >> a >> b;
        cout << fexp(a, b) << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{Exponentiation II}
\begin{lstlisting}
// Problem name: Exponentiation II
// Problem Link: https://cses.fi/problemset/task/1712
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to efficiently calculate values a ^ (b ^ c) modulo 10 ^ 9 + 7.
// Note that in this task we assume that 0 ^ 0=1.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 10010
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int fexp(ll b, int e, int MOD) {
    ll resp = 1;
    while (e) {
        if (e&1) {
            resp = (resp * b) % MOD;
        }
        e = (e >> 1);
        b = (b * b) % MOD;
    }
    return resp;
}
 
int main () { _
    int n;
    cin >> n;
    while(n--) {
        int a, b, c;
        cin >> a >> b >> c;
        cout << fexp(a, fexp(b, c, M-1), M) << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{Fibonacci Numbers}
\begin{lstlisting}
// Problem name: Fibonacci Numbers
// Problem Link: https://cses.fi/problemset/task/1722
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to calculate the value of Fn for a given n.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
typedef vector<vector<ll>> matriz;
 
matriz mat;
 
matriz mult(matriz a, matriz b) {
	matriz c(2, vector<ll> (2));
	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < 2; j++) {
			for (int k = 0; k < 2; k++) {
				c[i][j] = (c[i][j] + (a[i][k] * b[k][j]) % M) % M;
			}
		}
	}
	return c;
}
 
matriz expo(matriz a, ll e) {
	if (e == 1) return a;
	matriz ans = expo(a, e/2);
	ans = mult(ans, ans);
	if (e&1) ans = mult(ans, a);
	return ans;
}
 
int main () { _
	ll n;
	cin >> n;
	if (!n) cout << "0\n";
	else if (n == 1) cout << "1\n";
	else {
		matriz c (2, vector<ll> (2)); 
		c = {{1, 1}, {1, 0}};
		c = expo(c, n-1);
		cout << c[0][0] % M << '\n';
	}
	return 0;
}
\end{lstlisting}

\subsection{Graph Paths I}
\begin{lstlisting}
// Problem name: Graph Paths I
// Problem Link: https://cses.fi/problemset/task/1723
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Consider a directed graph that has n nodes and m edges. 
// Your task is to count the number of paths from node 1 to node n with exactly k edges.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 3e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
typedef vector<vector<ll>> matriz;
 
int n;
 
matriz mult(matriz a, matriz b) {
	matriz c(n, vector<ll> (n));
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			for (int k = 0; k < n; k++) {
				c[i][j] += (a[i][k] * b[k][j]) % M;
				if (c[i][j] >= M) c[i][j] -= M; 
			}
		}
	}
	return c;
}
 
matriz expo(matriz a, ll e) {
	if (e == 1) return a;
	matriz ans = expo(a, e/2);
	ans = mult(ans, ans);
	if (e&1) ans = mult(ans, a);
	return ans;
}
 
int main () { _
	int m, k;
	cin >> n >> m >> k;
	matriz v(n, vector<ll> (n));
	for (int i = 0; i < m; i++) {
		ll a, b;
		cin >> a >> b;
		v[a-1][b-1]++;
	}
	v = expo(v, k);
	cout << v[0][n-1] << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Graph Paths II}
\begin{lstlisting}
// Problem name: Graph Paths II
// Problem Link: https://cses.fi/problemset/task/1724
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Consider a directed weighted graph having n nodes and m edges. 
// Your task is to calculate the minimum path length from node 1 to node n with exactly k edges.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 3e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const ll M = 4294967296;
 
typedef vector<vector<ll>> matriz;
 
int n;
 
matriz mult(matriz a, matriz b) {
	matriz c(n, vector<ll> (n, INF));
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			for (int k = 0; k < n; k++) {
				c[i][j] = min(c[i][j], a[i][k] + b[k][j]);
			}
		}
	}
	return c;
}
 
matriz expo(matriz a, ll e) {
	if (e == 1) return a;
	matriz ans = expo(a, e/2);
	ans = mult(ans, ans);
	if (e&1) ans = mult(ans, a);
	return ans;
}
 
int main () { _
	int m, k;
	cin >> n >> m >> k;
	matriz v(n, vector<ll> (n, INF));
	for (int i = 0; i < m; i++) {
		ll a, b, c;
		cin >> a >> b >> c;
		v[a-1][b-1] = min(v[a-1][b-1], c);
	}
	v = expo(v, k);
	if (v[0][n-1] > 1e18) cout << "-1\n";
	else cout << v[0][n-1] << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Grundy's Game}
\begin{lstlisting}
// Problem name: Grundy's Game
// Problem Link: https://cses.fi/problemset/task/2207
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There is a heap of n coins and two players who move alternately. 
// On each move, a player chooses a heap and divides into two nonempty heaps that have a different number of coins. 
// The player who makes the last move wins the game.
// Your task is to find out who wins if both players play optimally.

// se n <= 1222, podemos rodar uma dp n ^ 2, se nao o primeiro jogador sempre vence

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
vector<int> v = {1,2,4,7,10,20,23,26,50,53,270,273,276,282,285,288,316,334,337,340,346,359,362,365,386,389,392,566,630,633,636,639,673,676,682,685,923,926,929,932,1222,1240};
int ans[1230];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int cnt = 0;
    for (int i = 1; i <= 1222; i++) {
        if (v[cnt] == i) cnt++;
        else ans[i] = 1;
    }
    int t, n;
    cin >> t;
    while (t--) {
        cin >> n;
        if (n > 1222) cout << "first\n";
        else {
            cout << (ans[n] ? "first\n" : "second\n");
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{Inversion Probability}
\begin{lstlisting}
// Problem name: Inversion Probability
// Problem Link: https://cses.fi/problemset/task/1728
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// An array has n integers x1,x2, ... xn, and each of them has been randomly chosen between 1 and ri. 
// An inversion is a pair (a,b) where a<b and xa>xb.
// What is the expected number of inversions in the array?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
	int n;
	cin >> n;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	vector<vector<double>> dp(105, vector<double> (105));
	vector<double> prob(105);
	for (int i = 1; i < v[0]; i++) {
		prob[i] += ((double)v[0] - i) / v[0];
	}
	for (int i = 1; i < n; i++) {
		for (int j = 1; j <= v[i]; j++) {
			dp[i][j] = prob[j];
			for (int k = 1; k <= v[i-1]; k++) {
				dp[i][j] += (dp[i-1][k]) / v[i-1];
			}
		}
		for (int j = 1; j < v[i]; j++) {
			prob[j] += ((double)v[i] - j) / v[i];
		}
	}
	double ans = 0;
	for (int i = 1; i <= v[n-1]; i++) ans += dp[n-1][i];
	cout << setprecision(6) << fixed;
	cout << ans / v[n-1] << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Josephus Queries}
\begin{lstlisting}
// Problem name: Josephus Queries
// Problem Link: https://cses.fi/problemset/task/2164
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Consider a game where there are n children (numbered 1,2,…,n) in a circle. 
// During the game, every second child is removed from the circle, until there are no children left.
// Your task is to process q queries of the form: "when there are n children, who is the kth child that will be removed?"

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int jose(int n, int pos, bool impar) {
	if (n == 0) return 1;
	if (impar) {
		if (n&1) {
			if (pos <= n/2 + 1) return 2 * pos - 1;
			return 2 * jose(n/2, pos - n/2 - 1, false);
		}
		else {
			if (pos <= n/2) return 2 * pos - 1;
			return 2 * jose(n/2, pos - n/2, true);
		}
	}
	else {
		if (pos <= n/2) return 2 * pos;
		if (n&1) {
			return 2 * jose(n/2+1, pos - n/2, true) - 1;
		}
		else {
			return 2 * jose(n/2, pos - n/2, false) - 1;
		}
	}
}
 
int main () { _
	int q, n, k;
	cin >> q;
	for (int i = 0; i < q; i++) {
		cin >> n >> k;
		cout << jose(n, k, false) << '\n';
	}
    return 0;   
}
\end{lstlisting}

\subsection{Moving Robots}
\begin{lstlisting}
// Problem name: Moving Robots
// Problem Link: https://cses.fi/problemset/task/1726
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Each square of an 8×8 chessboard has a robot. Each robot independently moves k steps, 
// and there can be many robots on the same square.
// On each turn, a robot moves one step left, right, up or down, but not outside the board. 
// It randomly chooses a direction among those where it can move.
// Your task is to calculate the expected number of empty squares after k turns.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int dx[4] = {1, -1, 0, 0};
int dy[4] = {0, 0, 1, -1};
 
bool valid(int x, int y) { return (x >= 0 && x < 8 && y >= 0 && y < 8); }
 
int main () { _
	int n;
	cin >> n;
	vector<vector<int>> count(8, vector<int> (8));
	vector<vector<vector<pii>>> moves(8, vector<vector<pii>> (8));
	for (int i = 0; i < 8; i++) {
		for (int j = 0; j < 8; j++) {
			for (int k = 0; k < 4; k++) {
				if (valid(i + dx[k], j + dy[k])) {
					count[i][j]++;
					moves[i][j].pb({i+dx[k], j+dy[k]});
				}
			}
		}
	}
	vector<vector<double>> ans(8, vector<double> (8, 1.0));
	for (int l = 0; l < 8; l++) {
		for (int m = 0; m < 8; m++) {
			vector<vector<double>> v(8, vector<double> (8)), w(8, vector<double> (8));
			v[l][m] = 1;
			for (int k = 0; k < n; k++) {
				for (int i = 0; i < 8; i++) {
					for (int j = 0; j < 8; j++) {
						for (int a = 0; a < (int)moves[i][j].size(); a++) {
							w[moves[i][j][a].F][moves[i][j][a].S] += v[i][j] / count[i][j];
						}
					}
				}
				v = w;
				fill(w.begin(), w.end(), vector<double> (8));
			}
			for (int i = 0; i < 8; i++) {
				for (int j = 0; j < 8; j++) {
					ans[i][j] *= (1.0 - v[i][j]);
				}
			}
		}
	}
	double resp = 0;
	for (int i = 0; i < 8; i++) {
		for (int j = 0; j < 8; j++) {
			resp += ans[i][j];
		}
	}
	cout << setprecision(6) << fixed;
	cout << resp << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Nim Game I}
\begin{lstlisting}
// Problem name: Nim Game I
// Problem Link: https://cses.fi/problemset/task/1730
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int t;
    cin >> t;
    while (t--) {
        int n, aux, ans = 0;
        cin >> n;
        for (int i = 0; i < n; i++) {
            cin >> aux;
            ans ^= aux;
        }
        cout << (ans ? "first\n" : "second\n");
    }
    return 0;
}
\end{lstlisting}

\subsection{Nim Game II}
\begin{lstlisting}
// Problem name: Nim Game II
// Problem Link: https://cses.fi/problemset/task/1098
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int t;
    cin >> t;
    while (t--) {
        int n, aux, ans = 0;
        cin >> n;
        for (int i = 0; i < n; i++) {
            cin >> aux;
            ans ^= (aux % 4);
        }
        cout << (ans ? "first\n" : "second\n");
    }
    return 0;
}
\end{lstlisting}

\subsection{Prime Multiples}
\begin{lstlisting}
// Problem name: Prime Multiples
// Problem Link: https://cses.fi/problemset/task/2185
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given k distinct prime numbers a1,a2,…,ak and an integer n.
// Your task is to calculate how many of the first n positive integers 
// are divisible by at least one of the given prime numbers.
// Inclusao exclusao classica

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    ll n;
	int k;
	cin >> n >> k;
	vector<ll> v(k), l(k);
	for (int i = 0; i < k; i++) cin >> v[i];
	sort(v.begin(), v.end());
	for (int i = 0; i < k; i++) l[i] = n/v[i] + 1;
	ll ans = 0;
	for (int i = 1; i < (1<<k); i++) {
		ll tot = 1;
		bool par = true;
		for (int j = 0; j < k; j++) {
			if (i & (1<<j)) {
				par = 1-par;
				if (tot > l[j]) {
					tot = 0;
					break;	
				}
				tot *= v[j];
			}
		}
		if (tot) tot = n/tot;
		ans += (par ? -tot : tot);
	}
	cout << ans << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{Removal Game}
\begin{lstlisting}
// Problem name: Removal Game
// Problem Link: https://cses.fi/problemset/task/1097
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n;
    cin >> n;
    vector<int> v(n);
    vector<vector<ll>> dp(n, vector<ll> (n));
    ll soma = 0;
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        soma += v[i];
        dp[i][i] = v[i];
    }
    for (int j = 1; j < n; j++) {
        for (int i = 0; i < n; i++) {
            if (i + j < n) {
                dp[i][i+j] = max(v[i] - dp[i+1][i+j], v[i+j] - dp[i][i+j-1]);
            }
        }
    }
    cout << (soma+dp[0][n-1])/2 << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Stair Game}
\begin{lstlisting}
// Problem name: Stair Game
// Problem Link: https://cses.fi/problemset/task/1099
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There is a staircase consisting of n stairs, numbered 1,2,…,n. Initially, each stair has some number of balls.
// There are two players who move alternately. 
// On each move, a player chooses a stair k where k≠1 and it has at least one ball. 
// Then, the player moves any number of balls from stair k to stair k−1. The player who moves last wins the game.
// Your task is to find out who wins the game when both players play optimally.
// Note that if there are no possible moves at all, the second player wins.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int t;
    cin >> t;
    while (t--) {
        int n, aux, ans = 0;
        cin >> n;
        for (int i = 0; i < n; i++) {
            cin >> aux;
            if (i&1) ans ^= aux;
        }
        cout << (ans ? "first\n" : "second\n");
    }
    return 0;
}
\end{lstlisting}

\subsection{Stick Game}
\begin{lstlisting}
// Problem name: Stick Game
// Problem Link: https://cses.fi/problemset/task/1729
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, k;
    cin >> n >> k;
    vector<int> v(k), ans(n+1);
    for (int i = 0; i < k; i++) {
        cin >> v[i];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < k; j++) {
            if (i - v[j] >= 0 && !ans[i-v[j]]) {
                ans[i] = 1;
                break;
            }
        }        
        cout << (ans[i] ? 'W' : 'L');
    }
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Sum of Divisors}
\begin{lstlisting}
// Problem name: Sum of Divisors
// Problem Link: https://cses.fi/problemset/task/1082
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    ll n;
    cin >> n;
    ll ans = 0, last = n, ult, um, dois;
    for (int i = 2; i <= 1e6; i++) {
        ult = n/i + 1;
        if ((last + ult) % 2 == 0) {
            um = ((last + ult) / 2) % M;
            dois = (last - ult + 1) % M;
        }
        else {
            um = (last + ult) % M;
            dois = ((last - ult + 1) / 2) % M;
        }
        ll mais = (um * dois) % M;
        mais = (mais * (i-1)) % M;
        ans += mais;
        if (ans >= M) ans -= M;
        last = ult-1;
    }
    for (int i = 1; i <= last; i++) {
        ans = (ans + (n/i * i)) % M;
    }
    cout << ans << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{Throwing Dice}
\begin{lstlisting}
// Problem name: Throwing Dice
// Problem Link: https://cses.fi/problemset/task/1096
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to calculate the number of ways to get a sum n by throwing dice. Each throw yields an integer between 1…6.
// For example, if n=10, some possible ways are 3+3+4, 1+4+1+4 and 1+1+6+1+1.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
const int x = 6;
 
typedef vector<vector<ll>> matriz;
 
ll n;
 
matriz mult(matriz a, matriz b) {
	matriz c(x, vector<ll> (x));
	for (int i = 0; i < x; i++) {
		for (int j = 0; j < x; j++) {
			for (int k = 0; k < x; k++) {
				c[i][j] += (a[i][k] * b[k][j]) % M;
				if (c[i][j] >= M) c[i][j] -= M;
			}
		}
	}
	return c;
}
 
matriz expo(matriz a, ll e) {
	if (e == 1) return a;
	matriz ans = expo(a, e/2);
	ans = mult(ans, ans);
	if (e&1) ans = mult(ans, a);
	return ans;
}
 
int main () { _
	cin >> n;
	if (n <= 6) cout << (1<<(n-1)) << '\n';
	else {
		matriz m (6, vector<ll> (6));
		for (int i = 0; i < 6; i++) {
			if (i < 5) m[i][i+1] = 1;
			m[5][i] = 1;
		}
		m = expo(m, n-6);
		ll ans = 0;
		for (int i = 0; i < 6; i++) {
			ans += (m[5][i] * (1<<i)) % M;
			if (ans >= M) ans -= M;
		}
		cout << ans << '\n';
	}
	return 0;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% CSES - Range Queries
%
%%%%%%%%%%%%%%%%%%%%

\section{CSES - Range Queries}

\subsection{Distinct Values Queries}
\begin{lstlisting}
// Problem name: Distinct Values Queries
// Problem Link: https://cses.fi/problemset/task/1734
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an array of n integers and q queries of the form: 
// how many distinct values are there in a range [a,b]?
// Aqui ta o algo nlog, mas tbm da p fazer com MO

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
const int X = 700;
 
struct que {
	int l, r, id, ans;
};
 
int a[MAXN], v[MAXN];
vector<que> qs;
vector<int> c, vals[MAXN];
 
void upd(int pos, int val) {
	for (int i = pos; i < MAXN; i += (i & -i)) 
		a[i] += val;
}
 
int sum(int pos) {
	int ans = 0;
	for (int i = pos; i > 0; i -= (i & -i))
		ans += a[i];
	return ans;
}
 
int main() { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		c.pb(v[i]);
	}
	sort(c.begin(), c.end());
	c.erase(unique(c.begin(), c.end()), c.end());
	for (int i = 1; i <= n; i++) {
		v[i] = upper_bound(c.begin(), c.end(), v[i]) - c.begin();
		if (vals[v[i]].empty()) upd(i, 1);
		vals[v[i]].pb(i);
	}
	que aux;
	for (int i = 0; i < q; i++) {
		cin >> aux.l >> aux.r;
		aux.id = i;
		qs.pb(aux);
	}
	sort(qs.begin(), qs.end(), [&] (que x, que y) { return x.l < y.l; });
	int last = 1, np;
	for (int i = 0; i < q; i++) {
		while (qs[i].l > last) {
			upd(last, -1);
			np = upper_bound(vals[v[last]].begin(), vals[v[last]].end(), last) - vals[v[last]].begin();
			if (np < (int)vals[v[last]].size()) upd(vals[v[last]][np], 1);
			last++;
		}
		qs[i].ans = sum(qs[i].r);
	}
	sort(qs.begin(), qs.end(), [&] (que x, que y) { return x.id < y.id; });
	for (que x : qs) cout << x.ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Dynamic Range Minimum Queries}
\begin{lstlisting}
// Problem name: Dynamic Range Minimum Queries
// Problem Link: https://cses.fi/problemset/task/1649
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 10000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
 
int n, q, a, b, v[MAXN], arvore[4*MAXN];
 
void build(int node, int i, int j) {
	if (i == j) arvore[node] = v[i];
	else {
		int meio = (i+j)/2;
		build(2*node, i, meio);
		build(2*node+1, meio+1, j);
		arvore[node] = min(arvore[2*node], arvore[2*node+1]);
	}
}
 
void atualiza(int node, int i, int j, int posicao, int novo) {
	if (i == j) { 
		v[posicao] = novo;
		arvore[node] = novo;
	}
	else {
		int meio = (i+j)/2;
		if (posicao > meio) atualiza(2*node+1, meio+1, j, posicao, novo);
		else atualiza(2*node, i, meio, posicao, novo);
		arvore[node] = min(arvore[2*node], arvore[2*node+1]);
	}
}
 
int consulta (int node, int i, int j, int ini, int fim) {
	if (i > fim || j < ini) return INT_MAX;
	if (i >= ini && j <= fim) return arvore[node];
	else {
		int meio = (i+j)/2;
		int resp1 = consulta (2*node, i, meio, ini, fim);
		int resp2 = consulta (2*node+1, meio+1, j, ini, fim);
		return min(resp1, resp2);
	}
}
 
int main () { _
	int tipo;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	build(1, 1, n);
	for (int i = 0; i < q; i++) {
		cin >> tipo >>  a >> b;
		if (tipo == 1) 
			atualiza (1, 1, n, a, b);
		else 
			cout << consulta(1, 1, n, a, b) << endl;
	}
    return 0;
}
\end{lstlisting}

\subsection{Dynamic Range Sum Queries}
\begin{lstlisting}
// Problem name: Dynamic Range Sum Queries
// Problem Link: https://cses.fi/problemset/task/1648
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
 
using namespace std;
typedef long long int lli;
 
int n, q, v[MAXN];
lli BIT[MAXN];
 
void atualiza (int id, int novo, int antigo) {
    while(id <= n) {
        BIT[id] += novo - antigo;
        id += (id&-id);
    }
}
 
lli soma (int id) {
    lli resp = 0;
    while (id > 0) {
        resp += BIT[id];
        id -= (id&-id);
    }
    return resp;
}
 
int main() { _
    int k, andar1, andar2, pessoas;
    cin >> n >> q;
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
        atualiza(i, v[i], 0);
    }
    for (int i = 0; i < q; i++) {
        cin >> k;
        if (k==1){
            cin >> andar1 >> pessoas;
            atualiza(andar1, pessoas, v[andar1]);
            v[andar1] = pessoas;
        }
        else{
            cin >> andar1 >> andar2;
            cout << soma(andar2) - soma(andar1-1) << endl;
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{Forest Queries}
\begin{lstlisting}
// Problem name: Forest Queries
// Problem Link: https://cses.fi/problemset/task/1652
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an n×n grid representing the map of a forest. 
// Each square is either empty or contains a tree. 
// The upper-left square has coordinates (1,1), and the lower-right square has coordinates (n,n).
// Your task is to process q queries of the form: 
// how many trees are inside a given rectangle in the forest?
// Fiz com BIT mas dava p ter feito so com soma de prefixo 2D

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1010
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
 
int bit[MAXN][MAXN], n;
 
int soma (int x, int y) {
	int resp = 0;
	for (int i = x; i > 0; i -= (i & -i)) {
		for (int j = y; j > 0; j -= (j & -j)) {
			resp += bit[i][j];
		}
	}
	return resp;
}
 
void update (int x, int y) {
	for (int i = x; i < 1001; i += (i&-i)) {
		for (int j = y; j < 1001; j += (j & -j)) {
			bit[i][j] += 1;
		}
	}
}
 
int main () { _
	int q, x1, y1, x2, y2;
	char c;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> c;
			if (c == '*') update(i, j);
		}
	}
	for (int i = 0; i < q; i++) {
		cin >> y1 >> x1 >> y2 >> x2;
		cout << soma(y2, x2) - soma(y1-1, x2) - soma(y2, x1-1) + soma(y1-1, x1-1) << endl;
	}
    return 0;	
}
\end{lstlisting}

\subsection{Forest Queries II}
\begin{lstlisting}
// Problem name: Forest Queries II
// Problem Link: https://cses.fi/problemset/task/1739
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an n x n grid representing the map of a forest. 
// Each square is either empty or has a tree. Your task is to process q queries of the following types: 
//     Change the state (empty/tree) of a square.
//     How many trees are inside a rectangle in the forest?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1010
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int bit[MAXN][MAXN];
char m[MAXN][MAXN];
 
void upd(int x, int y, int val) {
	for (int i = x; i < MAXN; i += (i & -i)) {
		for (int j = y; j < MAXN; j += (j & -j)) bit[i][j] += val;
	}
}
 
int sum(int x, int y) {
	int resp = 0;
	for (int i = x; i > 0; i -= (i & -i)) {
		for (int j = y; j > 0; j -= (j & -j)) resp += bit[i][j];
	}
	return resp;
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> m[i][j];
			if (m[i][j] == '*') upd(i, j, 1);
		}
	}
	int tipo, x1, x2, y1, y2;
	for (int i = 0; i < q; i++) {
		cin >> tipo;
		if (tipo == 1) {
			cin >> x1 >> y1;
			if (m[x1][y1] == '*') {
				upd(x1, y1, -1);
				m[x1][y1] = '.';
			}
			else {
				upd(x1, y1, 1);
				m[x1][y1] = '*';
			}
		}
		else {
			cin >> x1 >> y1 >> x2 >> y2;
			cout << sum(x2, y2) + sum(x1-1, y1-1) - sum(x2, y1-1) - sum(x1-1, y2) << '\n';
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{Hotel Queries}
\begin{lstlisting}
// Problem name: Hotel Queries
// Problem Link: https://cses.fi/problemset/task/1143
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n hotels on a street. For each hotel you know the number of free rooms. 
// Your task is to assign hotel rooms for groups of tourists. 
// All members of a group want to stay in the same hotel.
// The groups will come to you one after another, and you know 
// for each group the number of rooms it requires. You always assign a group to 
// the first hotel having enough rooms. 
// After this, the number of free rooms in the hotel decreases.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int a[4*MAXN], v[MAXN];
 
void build(int node, int ini, int fim) {
	if (ini == fim) {
		a[node] = v[ini];
	}
	else {
		int m = (ini+fim) >> 1;
		build(2*node, ini, m);
		build(2*node+1, m+1, fim);
		a[node] = max(a[2*node], a[2*node+1]);
	}
}
 
int ans(int n, int i, int j, int v) {
	if (i == j && a[n] >= v) {
		int resp = i;
		a[n] -= v;
		return resp;
	}
	else if (i == j) return 0;
	else {
		int m = (i+j) >> 1;
		if (a[2*n] >= v) {
			int resp = ans(2*n, i, m, v);
			a[n] = max(a[2*n], a[2*n+1]);
			return resp;
		}
		else if (a[2*n+1] >= v) {
			int resp = ans(2*n+1, m+1, j, v);
			a[n] = max(a[2*n], a[2*n+1]);
			return resp;
		}
		else {
			return 0;
		}
	}
}
 
int main () { _
	int n, m, aux;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	build(1, 1, n);
	for (int i = 0; i < m; i++) {
		cin >> aux;
		cout << ans(1, 1, n, aux) << ' ';
	}
	cout << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Increasing Array Queries}
\begin{lstlisting}
// Problem name: Increasing Array Queries
// Problem Link: https://cses.fi/problemset/task/2416
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an array that consists of n integers. The array elements are indexed 1,2,…,n.
// You can modify the array using the following operation: choose an array element and increase its value by one.
// Your task is to process q queries of the form: when we consider a subarray from position a to position b, 
// what is the minimum number of operations after which the subarray is increasing?
// An array is increasing if each element is greater than or equal with the previous element.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
struct que{
	int l, r, id;
};
 
ll v[MAXN], a[MAXN], pre[MAXN], cb[MAXN], resp[MAXN];
vector<que> qs[MAXN];
 
void upd(int pos, ll val) { for (int i = pos; i < MAXN; i += (i & -i)) a[i] += val; }
 
ll sum(int pos) {
	ll ans = 0;
	for (int i = pos; i > 0; i -= (i & -i)) ans += a[i];
	return ans;
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		pre[i] = v[i] + pre[i-1];
	}
	v[n+1] = INF;
	pre[n+1] = v[n+1] + pre[n];
	que aux;
	for (int i = 0; i < q; i++) {
		cin >> aux.l >> aux.r;
		aux.id = i;
		qs[aux.l].pb(aux);
	}
	deque<int> sk(1, n+1);
	for (int i = n; i > 0; i--) {
		while (v[i] > v[sk.front()]) {
			upd(sk.front(), -cb[sk.front()]);
			sk.pop_front();
		}
		cb[i] = 1ll * (sk.front() - i - 1) * v[i] - (pre[sk.front() - 1] - pre[i]);
		upd(i, cb[i]);
		sk.push_front(i);
		for (que x : qs[i]) {
			int pos = upper_bound(sk.begin(), sk.end(), x.r) - sk.begin() - 1;
			ll ans = sum(sk[pos]) - 1ll * (sk[pos+1] - x.r - 1) * v[sk[pos]] + (pre[sk[pos+1]-1] - pre[x.r]); 
			resp[x.id] = ans;
		}
	}
	for (int i = 0; i < q; i++) cout << resp[i] << '\n';
    return 0;
}
\end{lstlisting}

\subsection{List Removals}
\begin{lstlisting}
// Problem name: List Removals
// Problem Link: https://cses.fi/problemset/task/1749
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a list consisting of n integers. 
// Your task is to remove elements from the list at given positions, and report the removed elements.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int a[4*MAXN];
 
void build(int node, int i, int j) {
	if (i == j) a[node] = 1;
	else {
		int m = (i+j)/2;
		build(2*node, i, m);
		build(2*node+1, m+1, j);
		a[node] = a[2*node] + a[2*node+1];
	}
}
 
int ans(int node, int i, int j, int k) {
	a[node]--;
	if (i == j) {
		return i;
	}
	else {
		int m = (i+j)/2;
		if (a[2*node] >= k) 
			return ans(2*node, i, m, k);
		else 
			return ans(2*node+1, m+1, j, k-a[2*node]);
	}
}
 
int main () { _
	int n, aux;
	cin >> n;
	vector<int> v(n+1);
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	build(1, 1, n);
	for (int i = 0; i < n; i++) {
		cin >> aux;
		cout << v[ans(1, 1, n, aux)] << ' ';
	}	
	cout << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Pizzeria Queries}
\begin{lstlisting}
// Problem name: Pizzeria Queries
// Problem Link: https://cses.fi/problemset/task/2206
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
int a1[4*MAXN], a0[4*MAXN], v[MAXN], n, q;
 
void build(int node, int i, int j, bool a) {
	if (i == j) {
		if (a) a1[node] = v[i] + i;
		else a0[node] = v[i] + n - i;
	}
	else {
		int m = (i+j)/2;
		build(2*node, i, m, a);
		build(2*node+1, m+1, j, a);
		if (a) a1[node] = min(a1[2*node], a1[2*node+1]);
		else a0[node] = min(a0[2*node], a0[2*node+1]);
	}
}
 
void upd(int node, int i, int j, int pos, bool a) {
	if (i == j) {
		if (a) a1[node] = v[pos] + pos;
		else a0[node] = v[pos] + n - pos;
	}
	else {
		int m = (i+j)/2;
		if (pos <= m) upd(2*node, i, m, pos, a);
		else upd(2*node+1, m+1, j, pos, a);
		if (a) a1[node] = min(a1[2*node], a1[2*node+1]);
		else a0[node] = min(a0[2*node], a0[2*node+1]);
	}
}
 
int ans(int node, int i, int j, int ini, int fim, bool a) {
	if (j < ini || i > fim) return 2e9;
	if (ini <= i && j <= fim) return (a ? a1[node] : a0[node]);
	else {
		int m = (i+j)/2;
		return min(ans(2*node, i, m, ini, fim, a), ans(2*node+1, m+1, j, ini, fim, a));
	}
}
 
int main () { _
	cin >> n >> q;
	for (int i = 1; i <= n; i++) cin >> v[i];
	build(1, 1, n, true);
	build(1, 1, n, false);
	int tipo, x, y;
	for (int i = 0; i < q; i++) {
		cin >> tipo;
		if (tipo == 1) {
			cin >> x >> y;
			v[x] = y;
			upd(1, 1, n, x, 0);
			upd(1, 1, n, x, 1);
		}
		else {
			cin >> x;
			cout << min(ans(1, 1, n, x, n, 1) - x, ans(1, 1, n, 1, x, 0) - n + x) << '\n';
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{Polynomial Queries}
\begin{lstlisting}
// Problem name: Polynomial Queries
// Problem Link: https://cses.fi/problemset/task/1736
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to maintain an array of n values and efficiently process the following types of queries:
//     Increase the first value in range [a,b] by 1, the second value by 2, the third by 3...
// 	   Calculate the sum of values in range [a,b]

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
ll v[MAXN], a[4*MAXN];
pll lz[4*MAXN];
 
void build(int node, int i, int j) {
	if (i == j) a[node] = v[i];
	else {
		int m = (i+j)/2;
		build(2*node, i, m), build(2*node+1, m+1, j);
		a[node] = a[2*node] + a[2*node+1];
	}
}
 
void push(int node, int i, int j) {
	a[node] += lz[node].F * 1ll * (j-i+1);
	a[node] += lz[node].S * (1ll * (j-i+1) * (j-i) / 2);
	if (i != j && lz[node].F) {
		int m = (i+j)/2;
		lz[2*node] = {lz[2*node].F + lz[node].F, lz[2*node].S + lz[node].S};
		lz[2*node+1] = {lz[2*node+1].F + lz[node].F + 1ll * (m-i+1) * lz[node].S, lz[2*node+1].S + lz[node].S};
	}
	lz[node] = {0, 0};
}
 
void upd(int node, int i, int j, int ini, int fim) {
	push(node, i, j);
	if (j < ini || i > fim) return;
	if (ini <= i && j <= fim) {
		lz[node].S++;
		lz[node].F += (i-ini+1);
		push(node, i, j);
	}
	else {
		int m = (i+j)/2;
		upd(2*node, i, m, ini, fim);
		upd(2*node+1, m+1, j, ini, fim);
		a[node] = a[2*node] + a[2*node+1];
	}
}
 
ll query(int node, int i, int j, int ini, int fim) {
	push(node, i, j);
	if (j < ini || i > fim) return 0;
	if (ini <= i && j <= fim) return a[node];
	else {
		int m = (i+j)/2;
		return query(2*node, i, m, ini, fim) + query(2*node+1, m+1, j, ini, fim);
	}
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) cin >> v[i];
	build(1, 1, n);
	int tipo, a, b;
	for (int i = 0; i < q; i++) {
		cin >> tipo >> a >> b;
		if (tipo == 1) 
			upd(1, 1, n, a, b);
		if (tipo == 2) 
			cout << query(1, 1, n, a, b) << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{Prefix Sum Queries}
\begin{lstlisting}
// Problem name: Prefix Sum Queries
// Problem Link: https://cses.fi/problemset/task/2166
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given an array of n integers, your task is to process q queries of the following types:
//     update the value at position k to u
//     what is the maximum prefix sum in range [a,b]

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
ll a[4*MAXN], lz[4*MAXN], v[MAXN], w[MAXN];
 
void build(int node, int i, int j) {
	if (i == j) a[node] = w[i];
	else {
		int m = (i+j)/2;
		build(2*node, i, m), build(2*node+1, m+1, j);
		a[node] = max(a[2*node], a[2*node+1]);
	}
}
 
void push(int node, int i, int j) {
	a[node] += lz[node];
	if (i != j) {
		lz[2*node] += lz[node];
		lz[2*node+1] += lz[node];
	}
	lz[node] = 0;
}
 
void upd(int node, int i, int j, int ini, int fim, int val) {
	push(node, i, j);
	if (j < ini || i > fim) return;
	if (ini <= i && j <= fim) {
		lz[node] += val;
		push(node, i, j);
	}
	else {
		int m = (i+j)/2;
		upd(2*node, i, m, ini, fim, val);
		upd(2*node+1, m+1, j, ini, fim, val);
		a[node] = max(a[2*node], a[2*node+1]);
	}
}
 
ll query(int node, int i, int j, int ini, int fim) {
	push(node, i, j);
	if (j < ini || i > fim) return -INF;
	if (ini <= i && j <= fim) return a[node];
	else {
		int m = (i+j)/2;
		return max(query(2*node, i, m, ini, fim), query(2*node+1, m+1, j, ini, fim));
	}
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		w[i] = v[i] + w[i-1];
	}
	build(1, 0, n);
	int tipo, a, b;
	for (int i = 0; i < q; i++) {
		cin >> tipo >> a >> b;
		if (tipo == 1) {
			upd(1, 0, n, a, n, b - v[a]);
			v[a] = b;
		}
		if (tipo == 2) 
			cout << max(query(1, 0, n, a, b) - query(1, 0, n, a-1, a-1), 0ll) << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{Range Queries and Copies}
\begin{lstlisting}
// Problem name: Range Queries and Copies
// Problem Link: https://cses.fi/problemset/task/1737
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to maintain a list of arrays which initially has a single array. 
// You have to process the following types of queries:
//     Set the value a in array k to x
//     Calculate the sum of values in range [a,b] in array k
//     Create a copy of array k and add it to the end of the list.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 5e6 + 5;
const ll INF = 2e18;
 
ll esq[MAXN], dir[MAXN], a[MAXN];
int raiz[(int)2e5 + 5], v[(int)2e5 + 5], disp = 0, lst = 2;
 
void build(int node, int i, int j) {
    if (i == j) {
        a[node] = v[i];
        disp = max((int)disp, node);
    }
    else {
        int m = (i + j) / 2;
        build(2 * node, i, m);
        build(2 * node + 1, m + 1, j);
        esq[node] = 2 * node;
        dir[node] = 2 * node + 1;
        a[node] = a[2 * node] + a[2 * node + 1];
    }
}
 
ll query(int node, int i, int j, int ini, int fim) {
    if (i > fim || j < ini) return 0;
    else if (ini <= i && j <= fim) return a[node];
    else {
        int m = (i + j) / 2;
        return query(esq[node], i, m, ini, fim) + query(dir[node], m + 1, j, ini, fim);
    }
}
 
int upd(int node, int i, int j, int pos, int val) {
    int novo = disp++;
    if (i == j) {
        a[novo] = val;
        return novo;
    }
    int m = (i + j) / 2;
    if (m >= pos) {
        esq[novo] = upd(esq[node], i, m, pos, val);
        dir[novo] = dir[node];
    }
    else {
        dir[novo] = upd(dir[node], m + 1, j, pos, val);
        esq[novo] = esq[node];
    }
    a[novo] = a[esq[novo]] + a[dir[novo]];
    return novo;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
	int n, q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> v[i];
    raiz[1] = 1;
    build(1, 1, n);
    disp++;
    int tipo, ar, x, y;
    for (int i = 0; i < q; i++) {
        cin >> tipo;
        switch(tipo) {
            case 1:
                cin >> ar >> x >> y;
                raiz[ar] = upd(raiz[ar], 1, n, x, y);
                break;
            case 2:
                cin >> ar >> x >> y;
                cout << query(raiz[ar], 1, n, x, y) << '\n';
                break;
            case 3:
                cin >> ar;
                raiz[lst++] = disp;
                esq[disp] = esq[raiz[ar]];
                dir[disp] = dir[raiz[ar]];
                a[disp] = a[esq[disp]] + a[dir[disp]];
                disp++;
                break;
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{Range Update Queries}
\begin{lstlisting}
// Problem name: Range Update Queries
// Problem Link: https://cses.fi/problemset/task/1651
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
 
lli bit[MAXN], n;
 
lli soma (int x) {
	lli resp = 0;
	while (x > 0) {
		resp += bit[x];
		x -= (x & -x);
	}
	return resp;
}
 
void update (int x, int valor) {
	while (x <= n) {
		bit[x] += valor;
		x += (x & -x);
	}
}
 
int main () { _
	int q, tipo, a, b, c, anterior;
	cin >> n >> q;
	cin >> a;
	update (1, a);
	anterior = a;
	for (int i = 2; i <= n; i++) {
		cin >> a;
		update(i, a-anterior);
		anterior = a;
	}
	for (int i = 0; i < q; i++) {
		cin >> tipo;
		if (tipo == 1) {
			cin >> a >> b >> c;
			update(a, c);
			update(b+1, -c);
		}
		else {
			cin >> a;
			cout << soma(a) << endl;
		}
	}
    return 0;	
}
\end{lstlisting}

\subsection{Range Updates and Sums}
\begin{lstlisting}
// Problem name: Range Updates and Sums
// Problem Link: https://cses.fi/problemset/task/1735
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to maintain an array of n values and efficiently process the following types of queries:
//     Increase each value in range [a,b] by x
//     Set each value in range [a,b] to x
//     Calculate the sum of values in range [a,b]

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
ll v[MAXN], a[4*MAXN], lz1[4*MAXN], lz2[4*MAXN], a1[4*MAXN], a2[4*MAXN];
 
void build(int node, int i, int j) {
	if (i == j) a[node] = v[i];
	else {
		int m = (i+j)/2;
		build(2*node, i, m), build(2*node+1, m+1, j);
		a[node] = a[2*node] + a[2*node+1];
	}
}
 
void push(int node, int i, int j) {
	if (a1[node]) {
		a[node] = (j-i+1) * lz1[node];
		if (i != j) {
			lz1[2*node] = lz1[2*node+1] = lz1[node];
			a1[2*node] = a1[2*node+1] = 1;
			lz2[2*node] = lz2[2*node+1] = a2[2*node] = a2[2*node+1] = 0;
		}
		lz2[node] = lz1[node] = a2[node] = a1[node] = 0;
	}
	if (a2[node]) {
		a[node] += (j-i+1) * lz2[node];
		if (i != j) {
			if (lz1[2*node]) {
				lz1[2*node] += lz2[node];
				lz2[2*node] = 0;
				a2[2*node] = 0;
			}
			else {
				lz2[2*node] += lz2[node];
				a2[2*node] = 1;
			}
			if (lz1[2*node+1]) {
				lz1[2*node+1] += lz2[node];
				lz2[2*node+1] = 0;
				a2[2*node+1] = 0;
			}
			else {
				lz2[2*node+1] += lz2[node];
				a2[2*node+1] = 1;
			}
		}
		lz2[node] = 0;
		a2[node] = 0;
	}
}
 
void upd(int node, int i, int j, int ini, int fim, int val, bool set) {
	push(node, i, j);
	if (j < ini || i > fim) return;
	if (ini <= i && j <= fim) {
		if (set) {
			lz1[node] = val;
			a1[node] = true;
		}
		else {
			if (a1[node]) lz1[node] += val;
			else {
				lz2[node] += val;
				a2[node] = true;
			}
		}
		push(node, i, j);
	}
	else {
		int m = (i+j)/2;
		upd(2*node, i, m, ini, fim, val ,set);
		upd(2*node+1, m+1, j, ini, fim, val, set);
		a[node] = a[2*node] + a[2*node+1];
	}
}
 
ll query(int node, int i, int j, int ini, int fim) {
	push(node, i, j);
	if (j < ini || i > fim) return 0;
	if (ini <= i && j <= fim) return a[node];
	else {
		int m = (i+j)/2;
		return query(2*node, i, m, ini, fim) + query(2*node+1, m+1, j, ini, fim);
	}
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) cin >> v[i];
	build(1, 1, n);
	int tipo, a, b, val;
	for (int i = 0; i < q; i++) {
		cin >> tipo >> a >> b;
		if (tipo == 1) {
			cin >> val;
			upd(1, 1, n, a, b, val, false);
		}
		if (tipo == 2) {
			cin >> val;
			upd(1, 1, n, a, b, val, true);
		}
		if (tipo == 3) {
			cout << query(1, 1, n, a, b) << '\n';
		}
	}
    return 0;
}
\end{lstlisting}

\subsection{Range Xor Queries}
\begin{lstlisting}
// Problem name: Range Xor Queries
// Problem Link: https://cses.fi/problemset/task/1650
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 10000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
 
int n, q, a, b, v[MAXN], arvore[4*MAXN];
 
void build(int node, int i, int j) {
	if (i == j) arvore[node] = v[i];
	else {
		int meio = (i+j)/2;
		build(2*node, i, meio);
		build(2*node+1, meio+1, j);
		arvore[node] = (arvore[2*node]^arvore[2*node+1]);
	}
}
 
void atualiza(int node, int i, int j, int posicao, int novo) {
	if (i == j) { 
		v[posicao] = novo;
		arvore[node] = novo;
	}
	else {
		int meio = (i+j)/2;
		if (posicao > meio) atualiza(2*node+1, meio+1, j, posicao, novo);
		else atualiza(2*node, i, meio, posicao, novo);
		arvore[node] = min(arvore[2*node], arvore[2*node+1]);
	}
}
 
int consulta (int node, int i, int j, int ini, int fim) {
	if (i > fim || j < ini) return 0;
	if (i >= ini && j <= fim) return arvore[node];
	else {
		int meio = (i+j)/2;
		int resp1 = consulta (2*node, i, meio, ini, fim);
		int resp2 = consulta (2*node+1, meio+1, j, ini, fim);
		return (resp1^resp2);
	}
}
 
int main () { _
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	build(1, 1, n);
	for (int i = 0; i < q; i++) {
		cin >> a >> b;
		cout << consulta(1, 1, n, a, b) << endl;
	}
    return 0;
}
\end{lstlisting}

\subsection{Salary Queries}
\begin{lstlisting}
// Problem name: Salary Queries
// Problem Link: https://cses.fi/problemset/task/1144
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 400100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
vector<int> mapa;
vector<pair<char, pii>> que;
ll a[MAXN], v[MAXN];
 
void upd(int pos, int val) {
	int id = upper_bound(mapa.begin(), mapa.end(), pos) - mapa.begin();
	for (int i = id; i < MAXN; i += (i & -i)) {
		a[i] += val;
	}
}
 
ll sum(int pos) {
	int id = upper_bound(mapa.begin(), mapa.end(), pos) - mapa.begin();
	ll resp = 0;
	for (int i = id; i > 0; i -= (i & -i)) {
		resp += a[i];
	}
	return resp;
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 0; i < n; i++) {
		cin >> v[i];
		mapa.pb(v[i]);
	}
	char c;
	int x, y;
	for (int i = 0; i < q; i++) {
		cin >> c >> x >> y;
		que.pb({c, {x, y}});
		if (c == '!') mapa.pb(y);
	}
	sort(mapa.begin(), mapa.end());
	mapa.erase(unique(mapa.begin(), mapa.end()), mapa.end());
	for (int i = 0; i < n; i++) {
		upd(v[i], 1);
	}
	for (int i = 0; i < q; i++) {
		que[i].S.F--;
		if (que[i].F == '?') {
			cout << sum(que[i].S.S) - sum(que[i].S.F) << '\n';
		}
		else {
			upd(v[que[i].S.F], -1);
			v[que[i].S.F] = que[i].S.S;
			upd(v[que[i].S.F], 1);
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{Static Range Minimum Queries}
\begin{lstlisting}
// Problem name: Static Range Minimum Queries
// Problem Link: https://cses.fi/problemset/task/1647
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 10000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
 
int n, q, a, b, v[MAXN], arvore[4*MAXN];
 
void build(int node, int i, int j) {
	if (i == j) arvore[node] = v[i];
	else {
		int meio = (i+j)/2;
		build(2*node, i, meio);
		build(2*node+1, meio+1, j);
		arvore[node] = min(arvore[2*node], arvore[2*node+1]);
	}
}
 
int consulta (int node, int i, int j, int ini, int fim) {
	if (i > fim || j < ini) return INT_MAX;
	if (i >= ini && j <= fim) return arvore[node];
	else {
		int meio = (i+j)/2;
		int resp1 = consulta (2*node, i, meio, ini, fim);
		int resp2 = consulta (2*node+1, meio+1, j, ini, fim);
		return min(resp1, resp2);
	}
}
 
int main () { _
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
	}
	build(1, 1, n);
	for (int i = 0; i < q; i++) {
		cin >> a >> b;
		cout << consulta(1, 1, n, a, b) << endl;
	}
    return 0;
}
\end{lstlisting}

\subsection{Static Range Sum Queries}
\begin{lstlisting}
// Problem name: Static Range Sum Queries
// Problem Link: https://cses.fi/problemset/task/1646
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 10000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int lli;
typedef pair<int, int> pii;
 
int main () { _
	int n, q, a, b;
	lli v[MAXN];
	cin >> n >> q;
	v[0] = 0;
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		v[i] += v[i-1];
	}
	for (int i = 0; i < q; i++) {
		cin >> a >> b;
		cout << v[b] - v[a-1] << endl;
	}
    return 0;
}
\end{lstlisting}

\subsection{Subarray Sum Queries}
\begin{lstlisting}
// Problem name: Subarray Sum Queries
// Problem Link: https://cses.fi/problemset/task/1190
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There is an array consisting of n integers. 
// Some values of the array will be updated, and after each update, 
// your task is to report the maximum subarray sum in the array. 

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e17
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 998244353;
 
struct t{
	ll pre, suf, tot, ans;
};
 
t a[4*MAXN];
ll v[MAXN];
 
void build(int node, int i, int j) {
	if (i == j) {
		a[node].pre = a[node].suf = a[node].ans = max(0ll, v[i]);
		a[node].tot = v[i];
	}
	else {
		int m = (i+j)/2;
		build(2*node, i, m);
		build(2*node+1, m+1, j);
		a[node].pre = max(a[2*node].pre, a[2*node].tot + a[2*node+1].pre);
		a[node].suf = max(a[2*node].suf + a[2*node+1].tot, a[2*node+1].suf);
		a[node].tot = a[2*node].tot + a[2*node+1].tot;
		a[node].ans = max({a[node].pre, a[node].suf, a[2*node].ans, a[2*node+1].ans, a[2*node].suf + a[2*node+1].pre});
	}
}
 
void upd(int node, int i, int j, int pos) {
	if (i == j) {
		a[node].pre = a[node].suf = a[node].ans = max(0ll, v[i]);
		a[node].tot = v[i];
	}
	else {
		int m = (i+j)/2;
		if (pos <= m) upd(2*node, i, m, pos);
		else upd(2*node+1, m+1, j, pos);
		a[node].pre = max(a[2*node].pre, a[2*node].tot + a[2*node+1].pre);
		a[node].suf = max(a[2*node].suf + a[2*node+1].tot, a[2*node+1].suf);
		a[node].tot = a[2*node].tot + a[2*node+1].tot;
		a[node].ans = max({a[node].pre, a[node].suf, a[2*node].ans, a[2*node+1].ans, a[2*node].suf + a[2*node+1].pre});
	}
}
 
int main () { _
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> v[i];
	build(1, 1, n);
	int x, y;
	for (int i = 0; i < m; i++) {
		cin >> x >> y;
		v[x] = y;
		upd(1, 1, n, x);
		cout << a[1].ans << '\n';
	}
	return 0;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% CSES - Sorting and Searching
%
%%%%%%%%%%%%%%%%%%%%

\section{CSES - Sorting and Searching}

\subsection{Apartments}
\begin{lstlisting}
// Problem name: Apartments
// Problem Link: https://cses.fi/problemset/task/1084
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 999999
 
using namespace std;
typedef long long int lli;
 
int main() {
	int n, m, k, ap[MAXN], v[MAXN], resp = 0;
	cin >> n >> m >> k;
	for (int i = 0; i < n; i++) {
		cin >> v[i];
	}
	for (int i = 0; i < m; i++) {
		cin >> ap[i];
	}
	sort(v, v+n);
	sort(ap, ap+m);
	int id = 0;
	for (int i = 0; i < n && id < m; i++) {
		while (v[i] > ap[id]+k and id < m) id++;
		if (v[i] < ap[id]-k) continue;
		if (id < m) resp++;
		id++;
	}
	cout << resp << endl;
	return 0;
}
\end{lstlisting}

\subsection{Array Division}
\begin{lstlisting}
// Problem name: Array Division
// Problem Link: https://cses.fi/problemset/task/1085
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n, k;
	cin >> n >> k;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	ll l = 0, r = 1e16;
	while (r > l + 1) {
		ll m = (r+l)/2;
		ll count = 0, sum = 0;
		for (int i = 0; i < n; i++) {
			if (sum + v[i] <= m) sum += v[i];
			else {
				sum = v[i];
				if (sum > m) count = 1e8;
				count++;
			}
		}
		count += (sum > 0);
		if (count <= k) r = m;
		else l = m;
	}	
	cout << r << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Collecting Numbers}
\begin{lstlisting}
// Problem name: Collecting Numbers
// Problem Link: https://cses.fi/problemset/task/2216
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n;
	cin >> n;
	vector<pii> v(n);
	for (int i = 0; i < n; i++) {
		cin >> v[i].F; 
		v[i].S = i;
	}
	sort(v.begin(), v.end());
	int resp = 1;
	for (int i = 1; i < n; i++) {
		resp += (v[i].S < v[i-1].S);
	}
	cout << resp << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Collecting Numbers II}
\begin{lstlisting}
// Problem name: Collecting Numbers II
// Problem Link: https://cses.fi/problemset/task/2217
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an array that contains each number between 1…n exactly once. 
// Your task is to collect the numbers from 1 to n in increasing order.
// On each round, you go through the array from left to right and collect as many numbers as possible.
// Given m operations that swap two numbers in the array, 
// your task is to report the number of rounds after each operation.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 300100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
map<int, int> mp;
 
int count(int a, int b, vector<int> &w) {
    if (a > b) swap(a, b);
    int ans = 0;
    ans += w[a-1] > w[a];
    ans += w[b] > w[b+1];
    if (a+1 == b) {
        ans += w[a] > w[b];
    }
    else {
        ans += w[a] > w[a+1];
        ans += w[b-1] > w[b];
    }
    return ans;
}
 
int main() { _
    int n, m;
    cin >> n >> m;
    vector<pii> v(n+2);
    vector<int> w;
    for (int i = 1; i <= n; i++) {
        cin >> v[i].F;
        v[i].S = i;
        mp[i] = v[i].F; 
    }
    v[n+1] = {n+1, n+1};
    sort(v.begin(), v.end());
    for (int i = 0; i < n+2; i++) {
        w.pb(v[i].S);
    }
    int resp = 1;
    for (int i = 1; i <= n; i++) {
        resp += (w[i-1] > w[i]);
    }
    for (int i = 0; i < m; i++) {
        int a, b, ma, mb, aux;
        cin >> a >> b;
        ma = mp[a], mb = mp[b];
        aux = ma;
        mp[a] = mp[b];
        mp[b] = aux;
        int antes = count(ma, mb, w);
        swap(w[ma], w[mb]);
        int dif = count(ma, mb, w) - antes;
        resp += dif;
        cout << resp << '\n';
    }
	return 0;
}
\end{lstlisting}

\subsection{Concert Tickets}
\begin{lstlisting}
// Problem name: Concert Tickets
// Problem Link: https://cses.fi/problemset/task/1091
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n, m, aux;
	cin >> n >> m;
	multiset<int> s;
	for (int i = 0; i < n; i++) {
		cin >> aux;
		s.insert(-aux);
	}
	for (int i = 0; i < m; i++) {
		cin >> aux;
		auto it = s.begin();
		it = s.lower_bound(-aux);
		if (it == s.end()) cout << "-1\n";
		else {
			cout << -*it << '\n';
			s.erase(it);
		}
	}
	return 0;
}
\end{lstlisting}

\subsection{Distinct Numbers}
\begin{lstlisting}
// Problem name: Distinct Numbers
// Problem Link: https://cses.fi/problemset/task/1621
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
 
using namespace std;
 
set<int> conjunto;
 
int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        int aux;
        cin >> aux;
        conjunto.insert(aux);
    }
    cout << conjunto.size() << endl;
    return 0;
}
\end{lstlisting}

\subsection{Factory Machines}
\begin{lstlisting}
// Problem name: Factory Machines
// Problem Link: https://cses.fi/problemset/task/1620
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 300100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main() { _
    int n, k;
    cin >> n >> k;
    vector<int> v(n);
    for (int i = 0; i < n; i++) cin >> v[i];
    ll l = 0, r = 1e18+1;
    while (r > l + 1) {
        ll m = (l+r)>>1, count = 0;
        for (int i = 0; i < n && count < k; i++) count += m/v[i];
        if (count >= k) r = m;
        else l = m;
    }
    cout << r << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Ferris Wheel}
\begin{lstlisting}
// Problem name: Ferris Wheel
// Problem Link: https://cses.fi/problemset/task/1090
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000005
 
using namespace std;
typedef long long int lli;
 
pair<int, bool> p[MAXN];
 
int main () { _
    int n, x, resp = 0;
    cin >> n >> x;
    for (int i = 0; i < n; i++) {
        cin >> p[i].first;
    }
    sort(p, p+n);
    int j = n-1;
    for (int i = 0; i < n && !p[i].second; i++) {
        while (p[i].first + p[j].first > x and !p[i].second) {
            resp++;
            p[j].second = true;
            j--;
        }
        if (!p[i].second and !p[j].second) {
            resp++;
            p[i].second = true;
            p[j].second = true;
            j--;
        }
    }
    cout << resp << endl;
    return 0;
}
\end{lstlisting}

\subsection{Josephus Problem I}
\begin{lstlisting}
// Problem name: Josephus Problem I
// Problem Link: https://cses.fi/problemset/task/2162
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 300100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
set<int> s;
 
int main() { _
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) s.insert(i);
    auto it = s.begin();
    it++;
    int count = 0;
    while (count < n) {
        cout << *it << ' ';
        auto it2 = it;
        it++;
        if (it == s.end()) it = s.begin();
        s.erase(*it2);
        it++;
        if (it == s.end()) it = s.begin();
        count++;
    }
    cout << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Josephus Problem II}
\begin{lstlisting}
// Problem name: Josephus Problem II
// Problem Link: https://cses.fi/problemset/task/2163
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Consider a game where there are n children (numbered 1,2,…,n) in a circle. 
// During the game, repeatedly k children are skipped and one child is removed from the circle. 
// In which order will the children be removed?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
typedef tree<int,null_type,less<int>,rb_tree_tag,
tree_order_statistics_node_update> ordered_set;
const int M = 1e9+7;
 
int main () { _
    int n, k;
    cin >> n >> k;
    ordered_set s;
    for (int i = 1; i <= n; i++) {
        s.insert(i);
    }
    int tam = n, pos = k % tam;
    for (int i = 0; i < n; i++) {
        auto x = s.find_by_order(pos);
        cout << *x << ' ';
        s.erase(*x);
        tam--;
        if (tam) pos = (pos + k) % tam;
    }
    cout << '\n';
    return 0;   
}
\end{lstlisting}

\subsection{Maximum Subarray Sum}
\begin{lstlisting}
// Problem name: Maximum Subarray Sum
// Problem Link: https://cses.fi/problemset/task/1643
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1e5+2
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 998244353;
 
int main () { _
	int n;
	cin >> n;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	ll ans = -1e9 - 10, sum = 0;
	for (int i = 0; i < n; i++) {
		sum += v[i];
		ans = max(ans, sum);
		if (sum < 0) sum = 0;
	}
	cout << ans << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Maximum Subarray Sum II}
\begin{lstlisting}
// Problem name: Maximum Subarray Sum II
// Problem Link: https://cses.fi/problemset/task/1644
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given an array of n integers, your task is to find the 
// maximum sum of values in a contiguous subarray with length between a and b.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
multiset<ll> s;
 
int main () { _
	int n, a, b;
    cin >> n >> a >> b;
    vector<ll> v(n+1);
    for (int i = 1; i <= n; i++) {
        cin >> v[i];
        v[i] += v[i-1];
    }
    ll ans = -1e16;
    for (int i = 0; i <= n; i++) {
        if (i-a >= 0) s.insert(v[i-a]);
        if (i >= a) ans = max(ans, v[i] - *s.begin());
        if (i-b >= 0) s.erase(s.find(v[i-b]));
    }
    cout << ans << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{Missing Coin Sum}
\begin{lstlisting}
// Problem name: Missing Coin Sum
// Problem Link: https://cses.fi/problemset/task/2183
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You have n coins with positive integer values. 
// What is the smallest sum you cannot create using a subset of the coins?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n;
	cin >> n;
	vector<ll> v(n);
	for (int i = 0; i < n; i++) {
		cin >> v[i];
	}
	sort(v.begin(), v.end());
	ll resp = 0;
	for (int i = 0; i < n; i++) {
		if (v[i] - resp > 1) break;
		else resp += v[i];
	}
	cout << resp+1 << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Movie Festival}
\begin{lstlisting}
// Problem name: Movie Festival
// Problem Link: https://cses.fi/problemset/task/1629
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1e5+2
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 998244353;
 
int main () { _
	int n;
	cin >> n;
	vector<pii> v(n);
	for (int i = 0; i < n; i++) cin >> v[i].S >> v[i].F;
	sort(v.begin(), v.end());
	int ans = 0, cd = 0;
	for (int i = 0; i < n; i++) {
		if (v[i].S >= cd) {
			ans++;
			cd = v[i].F;
		}
	}
	cout << ans << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Movie Festival II}
\begin{lstlisting}
// Problem name: Movie Festival II
// Problem Link: https://cses.fi/problemset/task/1632
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// In a movie festival, n movies will be shown. 
// Syrjälä's movie club consists of k members, who will be all attending the festival.
// You know the starting and ending time of each movie. 
// What is the maximum total number of movies the club members can watch entirely if they act optimally?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
    int n, k;
    cin >> n >> k;
    vector<pii> v(n);
    for (int i = 0; i < n; i++) cin >> v[i].S >> v[i].F;
    sort(begin(v), end(v));
    multiset<int> s;
    for (int i = 0; i < k; i++) s.insert(0);
    int resp = 0;
    for (int i = 0; i < n; i++) {
        auto it = s.upper_bound(v[i].S);
        if (it == begin(s)) continue;
        resp++;
        s.erase(--it);
        s.insert(v[i].F);
    }
    cout << resp << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Nearest Smaller Values}
\begin{lstlisting}
// Problem name: Nearest Smaller Values
// Problem Link: https://cses.fi/problemset/task/1645
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n;
	cin >> n;
	vector<int> v(n+1), ans(n+1);
	for (int i = 1; i <= n; i++) {
		cin >> v[i];
		ans[i] = i-1;
	}
	for (int i = 1; i <= n; i++) {
		while (v[ans[i]] >= v[i]) {
			ans[i] = ans[ans[i]];
		}
	}
	for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Nested Ranges Check}
\begin{lstlisting}
// Problem name: Nested Ranges Check
// Problem Link: https://cses.fi/problemset/task/2168
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given n ranges, your task is to determine for each range if it contains some other range and if some other range contains it.
// Range [a,b] contains range [c,d] if a <= c and d <= b.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
    int n;
    cin >> n;
    vector<pair<pii, int>> v(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i].F.F >> v[i].F.S;
        v[i].S = i;
    }
    sort(begin(v), end(v), [&](pair<pii, int> a, pair<pii, int> b) {
        if (a.F.F == b.F.F) return a.F.S > b.F.S;
        return a.F.F < b.F.F;
    });
    int mini = 1e9+1;
    vector<pii> contem(n), contido(n);
    for (int i = n-1; i >= 0; i--) {
        contem[i].S = (v[i].F.S >= mini);
        contem[i].F = v[i].S;
        mini = min(mini, v[i].F.S);
    }
    int maxi = -1;
    for (int i = 0; i < n; i++) {
        contido[i].S = (v[i].F.S <= maxi);
        contido[i].F = v[i].S;
        maxi = max(maxi, v[i].F.S);
    }
    sort(begin(contem), end(contem));
    sort(begin(contido), end(contido));
    for (pii x : contem) cout << x.S << ' ';
    cout << '\n';
    for (pii x : contido) cout << x.S << ' ';
    cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{Nested Ranges Count}
\begin{lstlisting}
// Problem name: Nested Ranges Count
// Problem Link: https://cses.fi/problemset/task/2169
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given n ranges, your task is to count for each range how many other ranges it contains and how many other ranges contain it.
// Range [a,b] contains range [c,d] if a <= c and d <= b.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 400100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int a[MAXN];
 
void upd(int pos) {
    for (int i = pos; i < MAXN; i+=(i & -i)) {
        a[i]++;
    }
}
 
int sum(int pos) {
    int resp = 0;
    for (int i = pos; i > 0; i-=(i & -i)) {
        resp += a[i];
    }
    return resp;
}
 
int main () { _
    int n;
    cin >> n;
    vector<pair<pii, int>> v(n);
    set<int> comp;
    for (int i = 0; i < n; i++) {
        cin >> v[i].F.F >> v[i].F.S;
        v[i].S = i;
        comp.insert(v[i].F.F), comp.insert(v[i].F.S);
    }   
    map<int,int> mp;
    int atual = 1;
    for (int x : comp) {
        mp[x] = atual++;
    }
    for (int i = 0; i < n; i++) {
        v[i].F.F = mp[v[i].F.F];
        v[i].F.S = mp[v[i].F.S];
    }
    sort(begin(v), end(v), [&](pair<pii, int> a, pair<pii, int> b) {
        if (a.F.F == b.F.F) return a.F.S > b.F.S;
        return a.F.F < b.F.F;
    });
    vector<pii> contem(n), contido(n);
    for (int i = n-1; i >= 0; i--) {
        contem[i].S = sum(v[i].F.S);
        contem[i].F = v[i].S;
        upd(v[i].F.S);
    }
    memset(a, 0, sizeof(a));
    for (int i = 0; i < n; i++) {
        contido[i].S = sum(MAXN-1) - sum(v[i].F.S - 1);
        contido[i].F = v[i].S;
        upd(v[i].F.S);
    }
    sort(begin(contem), end(contem));
    sort(begin(contido), end(contido));
    for (pii x : contem) cout << x.S << ' ';
    cout << '\n';
    for (pii x : contido) cout << x.S << ' ';
    cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{Playlist}
\begin{lstlisting}
// Problem name: Playlist
// Problem Link: https://cses.fi/problemset/task/1141
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n;
	cin >> n;
	vector<int> v(n);
	map<int, int> mapa;
	for (int i = 0; i < n; i++) {
		cin >> v[i];
	}
	int r = 0, resp = 0;
	mapa[v[0]]++;
	for (int l = 0; l < n; l++) {
		while (r < n && mapa[v[r]] <= 1) {
			resp = max(resp, r - l + 1);
			r++;
			mapa[v[r]]++;
		}
		mapa[v[l]]--;
	}
	cout << resp << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Reading Books}
\begin{lstlisting}
// Problem name: Reading Books
// Problem Link: https://cses.fi/problemset/task/1631
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There are n books, and Kotivalo and Justiina are going to read them all. 
// For each book, you know the time it takes to read it.
// They both read each book from beginning to end, and they cannot read a book at the same time. 
// What is the minimum total time required?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 300100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main() { _
    int n;
    cin >> n;
    vector<int> v(n);
    for (int i = 0; i < n; i++) cin >> v[i];
    sort(v.begin(), v.end());
    ll a1 = 0, a2 = 0, ma1, ma2;
    for (int i = n-1; i >= 0; i--) {
        if (a1 <= a2) {
            a1 += v[i];
            ma1 = v[i];
        }
        else {
            a2 += v[i];
            ma2 = v[i];
        }
    }
    if (a1 > a2) {
        if (a2 >= ma1) cout << a1 + a2 << '\n';
        else cout << 2*a1 << '\n';
    }
    else {
        if (a1 >= ma2) cout << a1 + a2 << '\n';
        else cout << 2*a2 << '\n';
    }
	return 0;
}
\end{lstlisting}

\subsection{Restaurant Customers}
\begin{lstlisting}
// Problem name: Restaurant Customers
// Problem Link: https://cses.fi/problemset/task/1619
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1e5+2
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 998244353;
 
int main () { _
	int n, a;
	cin >> n;
	vector<pair<int, int>> v;
	for (int i = 0; i < n; i++) {
		cin >> a;
		v.pb({a, 1});
		cin >> a;
		v.pb({a, 0});
	}
	sort(v.begin(), v.end());
	int ans = 0, atual = 0;
	for (int i = 0; i < 2*n; i++) {
		if (v[i].S) atual++;
		else atual--;
		ans = max(ans, atual);
	}
	cout << ans << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Room Allocation}
\begin{lstlisting}
// Problem name: Room Allocation
// Problem Link: https://cses.fi/problemset/task/1164
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
struct t {
	int f, s;
	bool sair;
};
 
int main() { _
    int n;
	t aux;
	cin >> n;
	vector<t> v;
	vector<int> w(n, -1);
	for (int i = 0; i < n; i++) {
		cin >> aux.f >> aux.s;
		int depois = aux.s;
		aux.s = i;
		aux.sair = false;
		v.pb(aux);
		aux.f = depois+1;
		aux.sair = true;
		v.pb(aux);
	}
	int tot = 1;
	queue<int> q;
	sort(v.begin(), v.end(), [&](t a, t b) { 
		if (a.f != b.f) return a.f < b.f;
		return (a.sair && !b.sair);
	});
	for (t x : v) {
		if (w[x.s] == -1) {
			if (q.empty()) {
				w[x.s] = tot++;
			}
			else {
				w[x.s] = q.front();
				q.pop();
			}
		}
		else {
			q.push(w[x.s]);
		}
	}
	cout << tot-1 << '\n';
	sort(v.begin(), v.end(), [&](t a, t b) {
		return a.s < b.s;
	});
	bool ber = true;
	for (t x : v) {
		if (ber)
			cout << w[x.s] << ' ';
		ber = 1-ber;
	}
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Sliding Cost}
\begin{lstlisting}
// Problem name: Sliding Cost
// Problem Link: https://cses.fi/problemset/task/1077
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an array of n integers. 
// Your task is to calculate for each window of k elements, from left to right, 
// the minimum total cost of making all elements equal.
// You can increase or decrease each element with cost x where x is the 
// difference between the new and the original value. The total cost is the sum of such costs.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
	int n, k;
    cin >> n >> k;
    vector<int> v(n);
    multiset<ll> menor, maior, aux;
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        if (i < k) aux.insert(v[i]);
    }
    int count = 0;
    ll mi = 0, mj = 0;
    for (int x : aux) {
        if (count < (k+1)/2) {
            menor.insert(x);
            mi += x;
        }
        else {
            maior.insert(x);
            mj += x;
        }
        count++;
    }
    cout << abs(mi - (int)menor.size() * *menor.rbegin()) + abs(mj - (int)maior.size() * *menor.rbegin()) << ' ';
    for (int i = k; i < n; i++) {
        if (maior.find(v[i-k]) != maior.end()) {
            maior.erase(maior.find(v[i-k]));
            mj -= v[i-k];
        }
        else {
            menor.erase(menor.find(v[i-k]));
            mi -= v[i-k];
        }
        if (menor.empty() || v[i] > *menor.rbegin()) {
            maior.insert(v[i]);
            mj += v[i];
        }
        else {
            menor.insert(v[i]);
            mi += v[i];
        }
        while (maior.size() > menor.size()) {
            menor.insert(*maior.begin());
            mi += *maior.begin();
            mj -= *maior.begin();
            maior.erase(maior.begin());
        }
        while (menor.size()-1 > maior.size()) {
            auto it = menor.end();
            it--;
            mi -= *it;
            mj += *it;
            maior.insert(*it);
            menor.erase(it);
        }
        cout << abs(mi - (int)menor.size() * *menor.rbegin()) + abs(mj - (int)maior.size() * *menor.rbegin()) << ' ';
    }
    cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{Sliding Median}
\begin{lstlisting}
// Problem name: Sliding Median
// Problem Link: https://cses.fi/problemset/task/1076
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given an array of n integers. 
// Your task is to calculate the median of each window of k elements, from left to right.
// The median is the middle element when the elements are sorted. 
// If the number of elements is even, there are two possible medians 
// and we assume that the median is the smaller of them.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main () { _
	int n, k;
    cin >> n >> k;
    vector<int> v(n);
    multiset<int> menor, maior, aux;
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        if (i < k) aux.insert(v[i]);
    }
    int count = 0;
    for (int x : aux) {
        if (count < (k+1)/2) {
            menor.insert(x);
        }
        else {
            maior.insert(x);
        }
        count++;
    }
    cout << *menor.rbegin() << ' ';
    for (int i = k; i < n; i++) {
        if (maior.find(v[i-k]) != maior.end()) maior.erase(maior.find(v[i-k]));
        else menor.erase(menor.find(v[i-k]));
        if (menor.empty() || v[i] > *menor.rbegin()) maior.insert(v[i]);
        else menor.insert(v[i]);
        while (maior.size() > menor.size()) {
            menor.insert(*maior.begin());
            maior.erase(maior.begin());
        }
        while (menor.size()-1 > maior.size()) {
            auto it = menor.end();
            it--;
            maior.insert(*it);
            menor.erase(it);
        }
        cout << *menor.rbegin() << ' ';
    }
    cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{Stick Lengths}
\begin{lstlisting}
// Problem name: Stick Lengths
// Problem Link: https://cses.fi/problemset/task/1074
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int n;
    cin >> n;
    vector<int> v(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i];
    }
    sort(v.begin(), v.end());
    long long int ans = 0;
    for (int i = 0; i < n; i++) {
        ans += abs(v[i] - v[n / 2]);
    }
    cout << ans << endl;
    return 0;
}
\end{lstlisting}

\subsection{Subarray Distinct Values}
\begin{lstlisting}
// Problem name: Subarray Distinct Values
// Problem Link: https://cses.fi/problemset/task/2428
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n, k;
	cin >> n >> k;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	map<int, int> mapa;
	ll resp = 0;
	int r = 0, dist = 0;
	for (int l = 0; l < n; l++) {
		while (r < n && dist <= k) {
			mapa[v[r]]++;
			if (mapa[v[r]] == 1) dist++;
			r++;
		}
		resp += (r-l);
		if (dist > k) resp--;
		mapa[v[l]]--;
		if (mapa[v[l]] == 0) dist--;
	}
	cout << resp << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Subarray Divisibility}
\begin{lstlisting}
// Problem name: Subarray Divisibility
// Problem Link: https://cses.fi/problemset/task/1662
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n;
	cin >> n;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	map<int, int> mp;
	ll soma = 0, resp = 0;
	mp[0] = 1;
	for (int i = 0; i < n; i++) {
		soma = (soma + v[i]) % n;
		if (soma < 0) soma += n;
		resp += mp[soma % n];
		mp[soma % n]++;
	}
	cout << resp << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Subarray Sums I}
\begin{lstlisting}
// Problem name: Subarray Sums I
// Problem Link: https://cses.fi/problemset/task/1660
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n, x;
	cin >> n >> x;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	ll soma = 0, r = 0, resp = 0;
	for (int l = 0; l < n; l++) {
		while (r < n && soma < x) {
			soma += v[r];
			r++;
		}
		if (soma == x) resp++;
		soma -= v[l];
	}
	cout << resp << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Subarray Sums II}
\begin{lstlisting}
// Problem name: Subarray Sums II
// Problem Link: https://cses.fi/problemset/task/1661
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n, x;
	cin >> n >> x;
	vector<int> v(n);
	for (int i = 0; i < n; i++) cin >> v[i];
	if (!x) cout << 1ll * n * (n+1) / 2 << '\n';
	else {
		map<ll, ll> mapa;
		mapa[0] = 1;
		ll soma = 0, resp = 0;
		for (int i = 0; i < n; i++) {
			soma += v[i];
			mapa[soma]++;
			resp += mapa[soma - x];
		}
		cout << resp << '\n';
	}
    return 0;
}
\end{lstlisting}

\subsection{Sum of Four Values}
\begin{lstlisting}
// Problem name: Sum of Four Values
// Problem Link: https://cses.fi/problemset/task/1642
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
bool comp (int a, int b, int c, int d) {
	bool ber = false;
	ber |= (a == b || a == c || a == d);
	ber |= (b == c || b == d);
	ber |= (c == d);
	return ber;
}
 
int main() { _
    int n, x;
	cin >> n >> x;
	vector<int> v(n);
	for (int i = 0; i < n; i++) {
		cin >> v[i];
	}
	vector<pair<ll, pii>> w;
	vector<ll> u;
	for (int i = 0; i < n; i++) {
		for (int j = i+1; j < n; j++) {
			w.pb({v[i] + v[j], {i, j}});
			u.pb(v[i] + v[j]);
		}
	}	
	sort(w.begin(), w.end());
	sort(u.begin(), u.end());
	int tam = w.size();
	for (int i = 0; i < tam; i++) {
		ll sum = x - w[i].F;
		int pos = lower_bound(u.begin(), u.end(), sum) - u.begin();
		while (pos < tam && (comp(w[i].S.F, w[i].S.S, w[pos].S.F, w[pos].S.S))) pos++;
		if (pos < tam && w[pos].F == sum && !comp(w[i].S.F, w[i].S.S, w[pos].S.F, w[pos].S.S)) {
			cout << w[i].S.F + 1 << ' ' << w[i].S.S + 1 << ' ' << w[pos].S.F + 1 << ' ' << w[pos].S.S + 1 << '\n';
			return 0;
		}
	}
	cout << "IMPOSSIBLE\n";
    return 0;
}
\end{lstlisting}

\subsection{Sum of Three Values}
\begin{lstlisting}
// Problem name: Sum of Three Values
// Problem Link: https://cses.fi/problemset/task/1641
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
int main() { _
    int n, k;
	cin >> n >> k;
	vector<pair<ll, int>> v(n);
	for (int i = 0; i < n; i++) {
		cin >> v[i].F;
		v[i].S = i+1;
	}
	sort(v.begin(), v.end());
	for (int i = 0; i < n-2; i++) {
		int r = n-1;
		for (int l = i+1; l < r; l++) {
			while (r > l + 1 && v[i].F + v[l].F + v[r].F > k) r--;
			if (v[i].F + v[r].F + v[l].F == k) {
				cout << v[i].S << ' ' << v[l].S << ' ' << v[r].S << '\n';
				return 0;
			}
		}
	}
	cout << "IMPOSSIBLE\n";
    return 0;
}
\end{lstlisting}

\subsection{Sum of Two Values}
\begin{lstlisting}
// Problem name: Sum of Two Values
// Problem Link: https://cses.fi/problemset/task/1640
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
    int n, x;
    cin >> n >> x;
    vector<int> v(n);
    map<int, int> mp;
    for (int i = 0; i < n; i++) {
        cin >> v[i];
        mp[v[i]] = i + 1;
    }
    bool ok = false;
    for (int i = 0; i < n; i++) {
        if (mp[x - v[i]] && mp[x - v[i]] != (i + 1)) {
            cout << i + 1 << ' ' << mp[x - v[i]] << endl;
            ok = true;
            break;
        }
    }
    if (!ok) cout << "IMPOSSIBLE" << endl;
    return 0;
}
\end{lstlisting}

\subsection{Tasks and Deadlines}
\begin{lstlisting}
// Problem name: Tasks and Deadlines
// Problem Link: https://cses.fi/problemset/task/1630
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 300100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main() { _
    int n, aux;
    cin >> n;
    ll soma = 0;
    vector<int> v(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i] >> aux;
        soma += aux;
    }
    sort(v.begin(), v.end());
    ll tempo = 0;
    for (int i = 0; i < n; i++) {
        tempo += v[i];
        soma -= tempo;
    }
    cout << soma << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Towers}
\begin{lstlisting}
// Problem name: Towers
// Problem Link: https://cses.fi/problemset/task/1073
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 100000000
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int main () { _
	int n, aux;
	cin >> n;
	vector<int> pilha;
	for (int i = 0; i < n; i++) {
		cin >> aux;
		auto it = upper_bound(pilha.begin(), pilha.end(), aux);
		if (it == pilha.end()) pilha.pb(aux);
		else *it = aux;
	}
	cout << pilha.size() << '\n';
	return 0;
}
\end{lstlisting}

\subsection{Traffic Lights}
\begin{lstlisting}
// Problem name: Traffic Lights
// Problem Link: https://cses.fi/problemset/task/1163
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// There is a street of length x whose positions are numbered 0,1... x. 
// Initially there are no traffic lights, but n sets of traffic lights are added to the street one after another.
// Your task is to calculate the length of the longest passage without traffic lights after each addition.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 100100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
set<int> luz;
multiset<int> dist;
 
int main() { _
    int x, n, aux;
    cin >> x >> n;
    luz.insert(0), luz.insert(x);
    dist.insert(x);
    for (int i = 0; i < n; i++) {
        cin >> aux;
        auto it1 = luz.upper_bound(aux);
        auto it2 = it1;
        it2--;
        dist.erase(dist.find(*it1 - *it2));
        dist.insert(*it1 - aux), dist.insert(aux - *it2);
        luz.insert(aux);
        it1 = dist.end(), it1--;
        cout << *it1 << ' ';
    }
    cout << '\n';
    return 0;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% CSES - String
%
%%%%%%%%%%%%%%%%%%%%

\section{CSES - String}

\subsection{Counting Patterns}
\begin{lstlisting}
// Problem name: Counting Patterns
// Problem Link: https://cses.fi/problemset/task/2103
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a string and patterns, count for each pattern the number of positions where it appears in the string.

#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
 
#define PB push_back
 
string S;
int K, I = 1, ans[500005];
 
vector<int> adj[500005];
 
struct node {
    int fail, ch[26] = {}, cnt = 0;
    vector<int> word;
} T[500005];
 
void insert(string s, int i) {
    int x = 1;
    for (int i = 0; i < s.size(); i++) {
        if (T[x].ch[s[i] - 'a'] == 0)
            T[x].ch[s[i] - 'a'] = ++I;
        x = T[x].ch[s[i] - 'a'];
    }
    T[x].word.PB(i);
}
 
void build() {
    queue<int> Q;
    int x = 1; 
    T[1].fail = 1;
    for (int i = 0; i < 26; i++) {
        if (T[x].ch[i])
            T[T[x].ch[i]].fail = x, Q.push(T[x].ch[i]);
        else 
            T[x].ch[i] = 1;
    }
    while (!Q.empty()) {
        x = Q.front(); Q.pop();
        for (int i = 0; i < 26; i++) {
            if (T[x].ch[i])
                T[T[x].ch[i]].fail = T[T[x].fail].ch[i], Q.push(T[x].ch[i]);
            else 
                T[x].ch[i] = T[T[x].fail].ch[i];
        }
    }
    for (int i = 2; i <= I; i++)
        adj[T[i].fail].PB(i);
}
 
void run(string s) {
    for (int i = 0, x = 1; i < s.size(); i++) {
        x = T[x].ch[s[i] - 'a'];
        T[x].cnt++;
    }
}
 
int dfs(int u) {
    int res = T[u].cnt;
    for (int v : adj[u])
        res += dfs(v);
    for (int w : T[u].word)
        ans[w] = res;
    return res;
}
 
int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    
    cin >> S >> K;
    for (int i = 0; i < K; i++) {
        string s; cin >> s;
        insert(s, i);
    }
 
    build();
    run(S);
    dfs(1);
 
    for (int i = 0; i < K; i++)
        cout << ans[i] << '\n';
}
\end{lstlisting}

\subsection{Distinct Substrings}
\begin{lstlisting}
// Problem name: Distinct Substrings
// Problem Link: https://cses.fi/problemset/task/2105
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
void count_sort(vector<int> &p, vector<int> &c) {
    int n = p.size();
    vector<int> cnt(n);
    for (auto x : c) cnt[x]++;
    vector<int> p_new(n), pos(n);
    pos[0] = 0;
    for (int i = 1; i < n; i++) {
        pos[i] = pos[i - 1] + cnt[i - 1];
    }
    for (auto x : p) {
        p_new[pos[c[x]]] = x;
        pos[c[x]]++;
    }
    p = p_new;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    s += '$';
    int n = s.size();
    vector<int> p(n), c(n);
    {
        vector<pair<char, int>> a(n);
        for (int i = 0; i < n; i++) a[i] = {s[i], i};
        sort(a.begin(), a.end());
        for (int i = 0; i < n; i++) p[i] = a[i].second;
        c[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            if (a[i - 1].first == a[i].first) c[p[i]] = c[p[i - 1]];
            else c[p[i]] = c[p[i - 1]] + 1;
        }
    }
    int k = 0;
    while ((1 << k) < n) {
        for (int i = 0; i < n; i++) p[i] = (p[i] - (1 << k) + n) % n;
        count_sort(p, c);
        vector<int> c_new(n);
        c_new[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            pii prev = {c[p[i - 1]], c[(p[i - 1] + (1 << k)) % n]};
            pii now = {c[p[i]], c[(p[i] + (1 << k)) % n]};
            if (prev == now) c_new[p[i]] = c_new[p[i - 1]];
            else c_new[p[i]] = c_new[p[i - 1]] + 1;
        }
        c = c_new;
        k++;
    }
    vector<int> lcp(n);
    k = 0;
    for (int i = 0; i < n - 1; i++) {
        int pi = c[i];
        int j = p[pi - 1];
        while (s[i + k] == s[j + k]) k++;
        lcp[pi] = k;
        k = max(k - 1, 0);
    }
    ll ans = (1ll * n * (n - 1)) / 2;
    for (int i = 1; i < n; i++) ans -= lcp[i];
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Finding Borders}
\begin{lstlisting}
// Problem name: Finding Borders
// Problem Link: https://cses.fi/problemset/task/1732
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int pre[MAXN], pwr[MAXN];
 
int main () { _
	string s1;
	cin >> s1;
	int tam1 = (int)s1.size();
	pwr[0] = 1;
	for (int i = 1; i <= 1e6; i++) pwr[i] = (1ll * pwr[i-1] * 31) % M;
	for (int i = 0; i < tam1; i++) {
		pre[i] = ((!i ? 0 : pre[i-1]) + (s1[i] - 'a' + 1ll) * pwr[i]) % M;
	}
	vector<int> ans;
	for (int i = 0; i < tam1-1; i++) {
		if ((1ll * pre[i] * pwr[tam1-i-1]) % M == (pre[tam1-1] - pre[tam1-i-2] + M) % M)
			ans.pb(i+1);
	}
	for (int x : ans) cout << x << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Finding Patterns}
\begin{lstlisting}
// Problem name: Finding Patterns
// Problem Link: https://cses.fi/problemset/task/2102
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a string and patterns, check for each pattern if it appears in the string.

#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
 
#define PB push_back
 
string S;
int K, I = 1, ans[500005];
 
vector<int> adj[500005];
 
struct node {
    int fail, ch[26] = {}, cnt = 0;
    vector<int> word;
} T[500005];
 
void insert(string s, int i) {
    int x = 1;
    for (int i = 0; i < s.size(); i++) {
        if (T[x].ch[s[i] - 'a'] == 0)
            T[x].ch[s[i] - 'a'] = ++I;
        x = T[x].ch[s[i] - 'a'];
    }
    T[x].word.PB(i);
}
 
void build() {
    queue<int> Q;
    int x = 1; 
    T[1].fail = 1;
    for (int i = 0; i < 26; i++) {
        if (T[x].ch[i])
            T[T[x].ch[i]].fail = x, Q.push(T[x].ch[i]);
        else 
            T[x].ch[i] = 1;
    }
    while (!Q.empty()) {
        x = Q.front(); Q.pop();
        for (int i = 0; i < 26; i++) {
            if (T[x].ch[i])
                T[T[x].ch[i]].fail = T[T[x].fail].ch[i], Q.push(T[x].ch[i]);
            else 
                T[x].ch[i] = T[T[x].fail].ch[i];
        }
    }
    for (int i = 2; i <= I; i++)
        adj[T[i].fail].PB(i);
}
 
void run(string s) {
    for (int i = 0, x = 1; i < s.size(); i++) {
        x = T[x].ch[s[i] - 'a'];
        T[x].cnt++;
    }
}
 
int dfs(int u) {
    int res = T[u].cnt;
    for (int v : adj[u])
        res += dfs(v);
    for (int w : T[u].word)
        ans[w] = res;
    return res;
}
 
int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    
    cin >> S >> K;
    for (int i = 0; i < K; i++) {
        string s; cin >> s;
        insert(s, i);
    }
 
    build();
    run(S);
    dfs(1);
 
    for (int i = 0; i < K; i++)
        cout << (ans[i] ? "YES\n" : "NO\n");
}
\end{lstlisting}

\subsection{Finding Periods}
\begin{lstlisting}
// Problem name: Finding Periods
// Problem Link: https://cses.fi/problemset/task/1733
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A period of a string is a prefix that can be used to generate the whole string by repeating the prefix. 
// The last repetition may be partial. For example, the periods of abcabca are abc, abcabc and abcabca.
// Your task is to find all period lengths of a string.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int pre[MAXN], pwr[MAXN], ja[MAXN];
 
int main () { _
	string s1;
	cin >> s1;
	int tam1 = (int)s1.size();
	pwr[0] = 1;
	for (int i = 1; i <= 1e6; i++) pwr[i] = (1ll * pwr[i-1] * 31) % M;
	for (int i = 0; i < tam1; i++) {
		pre[i] = ((!i ? 0 : pre[i-1]) + (s1[i] - 'a' + 1ll) * pwr[i]) % M;
	}
	for (int i = 1; i <= tam1; i++) {
		if (!ja[i]) {
			bool ok = true;
			for (int j = i; j < tam1 && ok; j+=i) {
				if (j + i >= tam1) 
					ok &= ((1ll * pre[tam1-j-1] * pwr[j]) % M == (pre[tam1-1] - pre[j-1] + M) % M);
				else ok &= ((1ll * pre[i-1] * pwr[j]) % M == (pre[j+i-1] - pre[j-1] + M) % M);
			}
			if (ok) {
				for (int j = i; j <= tam1; j+=i) ja[j] = 1;
			}
		}
	}
	for (int i = 1; i <= tam1; i++) 
		if (ja[i]) cout << i << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Longest Palindrome}
\begin{lstlisting}
// Problem name: Longest Palindrome
// Problem Link: https://cses.fi/problemset/task/1111
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a string, your task is to determine the longest palindromic substring of the string. 
// For example, the longest palindrome in aybabtu is bab.
// Manacher O(n), calcula o maior palindromo que comeca em toda posicao


#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e6 + 5;
const ll INF = 2e18;
 
int v[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string ns, s;
    cin >> ns;
    s = "$";
    for (auto x : ns) s += "#", s += x;
    s += "#@";
    int c = 0, r = 0, n = s.size(), mx = 0;
    for (int i = 1; i < n - 1; i++) {
        int mir = 2 * c - i;
        if (i < r) {
            v[i] = min(v[mir], r - i);
        }
        while (s[i + v[i] + 1] == s[i - v[i] - 1]) v[i]++;
        if (i + v[i] > r) {
            c = i;
            r = i + v[i];
        }
        mx = max(mx, v[i]);
    }
    string ans;
    for (int i = 2; i < n - 1; i++) {
        if (v[i] == mx) {
            for (int j = (s[i - v[i]] == '#' ? i - v[i] + 1 : i - v[i]); j <= i + v[i]; j += 2) ans += s[j];
            cout << ans << '\n';
            break;
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{Minimal Rotation}
\begin{lstlisting}
// Problem name: Minimal Rotation
// Problem Link: https://cses.fi/problemset/task/1110
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// A rotation of a string can be generated by moving characters one after another from beginning to end. 
// For example, the rotations of acab are acab, caba, abac, and baca.
// Your task is to determine the lexicographically minimal rotation of a string.
// O(n)

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
// https://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation
 
int least_rotation(string s) {
    s += s;
    int n = s.size();
    vector<int> f(n, -1);
    int k = 0;
    for (int j = 1; j < n; j++) {
        int sj = s[j];
        int i = f[j - k - 1];
        while (i != -1 && sj != s[k + i + 1]) {
            if (sj < s[k + i + 1])
                k = j - i - 1;
            i = f[i];
        }
        if (sj != s[k + i + 1]) {
            if (sj < s[k])
                k = j;
            f[j - k] = -1;
        }
        else {
            f[j - k] = i + 1;
        }
    }
    return k;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    int st = least_rotation(s), n = s.size();
    for (int i = st; i < n; i++) cout << s[i];
    for (int i = 0; i < st; i++) cout << s[i];
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Palindrome Queries}
\begin{lstlisting}
// Problem name: Palindrome Queries
// Problem Link: https://cses.fi/problemset/task/2420
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a string that consists of n characters between a–z. The positions of the string are indexed 1,2, ... n.
// Your task is to process m operations of the following types:
//     Change the character at position k to x
//     Check if the substring from position a to position b is a palindrome

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 4e5 + 5;
const ll INF = 2e18;
 
int pre[MAXN], pwr[MAXN], a[MAXN];
 
void add(int pos, int val) {
    pos+=2;
    for (; pos < MAXN; pos += (pos & -pos)) {
        a[pos] += val;
        if (a[pos] >= MOD) a[pos] -= MOD;
        if (a[pos] < 0) a[pos] += MOD;
    }
}
 
int ans(int pos) {
    int ans = 0;
    pos+=2;
    for (; pos; pos -= (pos & -pos)) {
        ans += a[pos];
        if (ans >= MOD) ans -= MOD;
        if (ans < 0) ans += MOD;
    }
    return ans;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
    string s, ns;
    cin >> n >> m >> s;
    ns = s;
    reverse(ns.begin(), ns.end());
    s += ns;
    pwr[0] = 1;
    for (int i = 1; i < MAXN; i++) pwr[i] = (1ll * pwr[i-1] * 29) % MOD;
    for (int i = 0; i < 2 * n; i++) {
        add(i, ((s[i] - 'a' + 1ll) * pwr[i]) % MOD); 
    }
    int tipo, a, b;
    char c;
    for (int i = 0; i < m; i++) {
        cin >> tipo;
        if (tipo == 1) {
            cin >> a >> c;
            a--;
            add(a, -1 * (((s[a] - 'a' + 1ll) * pwr[a]) % MOD));
            add(2 * n - a - 1, -1 * (((s[2 * n - a - 1] - 'a' + 1ll) * pwr[2 * n - a - 1]) % MOD));
            s[a] = s[2 * n - a - 1] = c;
            add(a, ((s[a] - 'a' + 1ll) * pwr[a]) % MOD);
            add(2 * n - a - 1, ((s[2 * n - a - 1] - 'a' + 1ll) * pwr[2 * n - a - 1]) % MOD);
        }
        else {
            cin >> a >> b;
            a--, b--;
            int val1 = (ans(b) - ans(a - 1) + MOD) % MOD;
            int val2 = (ans(2 * n - a - 1) - ans(2 * n - b - 2) + MOD) % MOD;
            val1 = (1ll * val1 * pwr[2 * n - a - b - 1]) % MOD;
            cout << (val1 == val2 ? "YES\n" : "NO\n");
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{Pattern Positions}
\begin{lstlisting}
// Problem name: Pattern Positions
// Problem Link: https://cses.fi/problemset/task/2104
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a string and patterns, find for each pattern the first position (1-indexed) where it appears in the string.

#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
 
#define PB push_back
 
string S;
int K, I = 1, ans[500005], sz[500005];
 
vector<int> adj[500005];
 
struct node {
    int fail, ch[26] = {}, cnt = 1e9;
    vector<int> word;
} T[500005];
 
void insert(string s, int i) {
    int x = 1;
    for (int i = 0; i < s.size(); i++) {
        if (T[x].ch[s[i] - 'a'] == 0)
            T[x].ch[s[i] - 'a'] = ++I;
        x = T[x].ch[s[i] - 'a'];
    }
    T[x].word.PB(i);
}
 
void build() {
    queue<int> Q;
    int x = 1; 
    T[1].fail = 1;
    for (int i = 0; i < 26; i++) {
        if (T[x].ch[i])
            T[T[x].ch[i]].fail = x, Q.push(T[x].ch[i]);
        else 
            T[x].ch[i] = 1;
    }
    while (!Q.empty()) {
        x = Q.front(); Q.pop();
        for (int i = 0; i < 26; i++) {
            if (T[x].ch[i])
                T[T[x].ch[i]].fail = T[T[x].fail].ch[i], Q.push(T[x].ch[i]);
            else 
                T[x].ch[i] = T[T[x].fail].ch[i];
        }
    }
    for (int i = 2; i <= I; i++)
        adj[T[i].fail].PB(i);
}
 
void run(string s) {
    for (int i = 0, x = 1; i < s.size(); i++) {
        x = T[x].ch[s[i] - 'a'];
        T[x].cnt = min(T[x].cnt, i);
    }
}
 
int dfs(int u) {
    int res = T[u].cnt;
    for (int v : adj[u])
        res = min(res, dfs(v));
    for (int w : T[u].word)
        ans[w] = res;
    return res;
}
 
int main() {
    ios_base::sync_with_stdio(0); cin.tie(0);
    
    cin >> S >> K;
    for (int i = 0; i < K; i++) {
        string s; cin >> s;
        sz[i] = s.size();
        insert(s, i);
    }
 
    build();
    run(S);
    dfs(1);
 
    for (int i = 0; i < K; i++)
        cout << (ans[i] == 1e9 ? -1 : ans[i] - sz[i] + 2) << '\n';
}
\end{lstlisting}

\subsection{Repeating Substring}
\begin{lstlisting}
// Problem name: Repeating Substring
// Problem Link: https://cses.fi/problemset/task/2106
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
void count_sort(vector<int> &p, vector<int> &c) {
    int n = p.size();
    vector<int> cnt(n);
    for (auto x : c) cnt[x]++;
    vector<int> p_new(n), pos(n);
    pos[0] = 0;
    for (int i = 1; i < n; i++) {
        pos[i] = pos[i - 1] + cnt[i - 1];
    }
    for (auto x : p) {
        p_new[pos[c[x]]] = x;
        pos[c[x]]++;
    }
    p = p_new;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    s += '$';
    int n = s.size();
    vector<int> p(n), c(n);
    {
        vector<pair<char, int>> a(n);
        for (int i = 0; i < n; i++) a[i] = {s[i], i};
        sort(a.begin(), a.end());
        for (int i = 0; i < n; i++) p[i] = a[i].second;
        c[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            if (a[i - 1].first == a[i].first) c[p[i]] = c[p[i - 1]];
            else c[p[i]] = c[p[i - 1]] + 1;
        }
    }
    int k = 0;
    while ((1 << k) < n) {
        for (int i = 0; i < n; i++) p[i] = (p[i] - (1 << k) + n) % n;
        count_sort(p, c);
        vector<int> c_new(n);
        c_new[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            pii prev = {c[p[i - 1]], c[(p[i - 1] + (1 << k)) % n]};
            pii now = {c[p[i]], c[(p[i] + (1 << k)) % n]};
            if (prev == now) c_new[p[i]] = c_new[p[i - 1]];
            else c_new[p[i]] = c_new[p[i - 1]] + 1;
        }
        c = c_new;
        k++;
    }
    vector<int> lcp(n);
    k = 0;
    for (int i = 0; i < n - 1; i++) {
        int pi = c[i];
        int j = p[pi - 1];
        while (s[i + k] == s[j + k]) k++;
        lcp[pi] = k;
        k = max(k - 1, 0);
    }
    int max = 0, id = -1;
    for (int i = 0; i < n; i++) {
        if (lcp[i] > max) {
            max = lcp[i];
            id = p[i];
        }
    }
    if (!max) cout << "-1\n";
    else {
        for (int i = id; i < id + max; i++) cout << s[i];
        cout << '\n';
    }
    return 0;
}
\end{lstlisting}

\subsection{Required Substring}
\begin{lstlisting}
// Problem name: Required Substring
// Problem Link: https://cses.fi/problemset/task/1112
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Your task is to calculate the number of strings of length n having a given pattern 
// of length m as their substring. All strings consist of characters A–Z.
// DP + Automato KMP

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
vector<int> prefix(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i-1];
        while (j > 0 && s[i] != s[j])
            j = pi[j-1];
        if (s[i] == s[j])
            j++;
        pi[i] = j;
    }
    return pi;
}
 
vector<vector<int>> aut;
 
void automato(string s) {
    vector<int> kmp = prefix(s + '$');
    int n = s.size() + 1;
    aut.assign(n, vector<int> (26));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < 26; j++) {
            if (i > 0 && 'A' + j != s[i]) 
                aut[i][j] = aut[kmp[i -  1]][j];
            else 
                aut[i][j] = i + ('A' + j == s[i]);
        }
    }
}
 
void add(int &a, int b) {
    a += b;
    if (a >= MOD) a -= MOD;
}
 
// dp[position][size of prefix of s][char i´m at]
int dp[1005][105];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
    string s;
    cin >> n >> s;
    m = s.size();
    automato(s);
    dp[0][0] = 1;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            for (int k = 0; k < 26; k++) {
                if (aut[j][k] == m) continue;
                add(dp[i + 1][aut[j][k]], dp[i][j]);
            }
        }
    }
    int ans = 1;
    for (int i = 0; i < n; i++) ans = (ans * 26ll) % MOD;
    for (int i = 0; i < m; i++) {
        add(ans, MOD - dp[n][i]);
    }
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{String Functions}
\begin{lstlisting}
// Problem name: String Functions
// Problem Link: https://cses.fi/problemset/task/2107
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
 
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
vector<int> pi(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i-1];
        while (j > 0 && s[i] != s[j])
            j = pi[j-1];
        if (s[i] == s[j])
            j++;
        pi[i] = j;
    }
    return pi;
}
 
vector<int> z(string s) {
    int n = (int) s.length();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r)
            z[i] = min (r - i + 1, z[i - l]);
        while (i + z[i] < n && s[z[i]] == s[i + z[i]])
            ++z[i];
        if (i + z[i] - 1 > r)
            l = i, r = i + z[i] - 1;
    }
    return z;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    vector<int> vpi = pi(s), vz = z(s);
    for (int x : vz) cout << x << ' ';
    cout << '\n';
    for (int x : vpi) cout << x << ' ';
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{String Matching}
\begin{lstlisting}
// Problem name: String Matching
// Problem Link: https://cses.fi/problemset/task/1753
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int pre[MAXN], pwr[MAXN];
 
int main () { _
	string s1, s2;
	cin >> s1 >> s2;
	int tam1 = (int)s1.size(), tam2 = (int)s2.size();
	if (tam2 > tam1) cout << "0\n";
	else {
		pwr[0] = 1;
		int h = 0;
		for (int i = 1; i <= 1e6; i++) pwr[i] = (1ll * pwr[i-1] * 31) % M;
		for (int i = 0; i < tam1; i++) {
			if (i < tam2) 
				h = (h + (s2[i] - 'a' + 1ll) * pwr[i]) % M;
			pre[i] = ((!i ? 0 : pre[i-1]) + (s1[i] - 'a' + 1ll) * pwr[i]) % M;
		}
		int ans = 0;
		for (int i = tam2-1; i < tam1; i++) {
			ans += (((pre[i] - (i == tam2-1 ? 0 : pre[i-tam2]) + M) % M) == ((1ll * h * pwr[i-tam2+1]) % M));
		}
		cout << ans << '\n';
	}
 
    return 0;
}
\end{lstlisting}

\subsection{Substring Distribution}
\begin{lstlisting}
// Problem name: Substring Distribution
// Problem Link: https://cses.fi/problemset/task/2110
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a string of length n. For every integer between 1...n 
// you need to print the number of distinct substrings of that length.

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
ll a[MAXN];
 
void upd(int pos, int val) {
    pos += 2;
    for (; pos < MAXN; pos += pos & -pos) a[pos] += val;
}
 
int qry(int pos) {
    pos += 2;
    ll ans = 0;
    for (; pos; pos -= pos & -pos) ans += a[pos];
    return ans;
}
 
void count_sort(vector<int> &p, vector<int> &c) {
    int n = p.size();   
    vector<int> cnt(n);
    for (auto x : c) cnt[x]++;
    vector<int> p_new(n), pos(n);
    pos[0] = 0;
    for (int i = 1; i < n; i++) {
        pos[i] = pos[i - 1] + cnt[i - 1];
    }
    for (auto x : p) {
        p_new[pos[c[x]]] = x;
        pos[c[x]]++;
    }
    p = p_new;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    s += '$';
    int n = s.size();
    vector<int> p(n), c(n);
    {
        vector<pair<char, int>> a(n);
        for (int i = 0; i < n; i++) a[i] = {s[i], i};
        sort(a.begin(), a.end());
        for (int i = 0; i < n; i++) p[i] = a[i].second;
        c[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            if (a[i - 1].first == a[i].first) c[p[i]] = c[p[i - 1]];
            else c[p[i]] = c[p[i - 1]] + 1;
        }
    }
    int k = 0;
    while ((1 << k) < n) {
        for (int i = 0; i < n; i++) p[i] = (p[i] - (1 << k) + n) % n;
        count_sort(p, c);
        vector<int> c_new(n);
        c_new[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            pii prev = {c[p[i - 1]], c[(p[i - 1] + (1 << k)) % n]};
            pii now = {c[p[i]], c[(p[i] + (1 << k)) % n]};
            if (prev == now) c_new[p[i]] = c_new[p[i - 1]];
            else c_new[p[i]] = c_new[p[i - 1]] + 1;
        }
        c = c_new;
        k++;
    }
    vector<int> lcp(n);
    k = 0;
    for (int i = 0; i < n - 1; i++) {
        int pi = c[i];
        int j = p[pi - 1];
        while (s[i + k] == s[j + k]) k++;
        lcp[pi] = k;
        k = max(k - 1, 0);
    }
    for (int i = 1; i < n; i++) {
        upd(lcp[i] + 1, 1);
        upd(n - p[i], -1);
    }
    for (int i = 1; i < n; i++) {
        cout << qry(i) << ' ';
    }
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Substring Order I}
\begin{lstlisting}
// Problem name: Substring Order I
// Problem Link: https://cses.fi/problemset/task/2108
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a string of length n. 
// If all of its distinct substrings are ordered lexicographically, what is the kth smallest of them?

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAX = 4e3 + 5;
const ll INF = 2e18;
 
void count_sort(vector<int> &p, vector<int> &c) {
    int n = p.size();   
    vector<int> cnt(n);
    for (auto x : c) cnt[x]++;
    vector<int> p_new(n), pos(n);
    pos[0] = 0;
    for (int i = 1; i < n; i++) {
        pos[i] = pos[i - 1] + cnt[i - 1];
    }
    for (auto x : p) {
        p_new[pos[c[x]]] = x;
        pos[c[x]]++;
    }
    p = p_new;
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    s += '$';
    int n = s.size();
    vector<int> p(n), c(n);
    {
        vector<pair<char, int>> a(n);
        for (int i = 0; i < n; i++) a[i] = {s[i], i};
        sort(a.begin(), a.end());
        for (int i = 0; i < n; i++) p[i] = a[i].second;
        c[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            if (a[i - 1].first == a[i].first) c[p[i]] = c[p[i - 1]];
            else c[p[i]] = c[p[i - 1]] + 1;
        }
    }
    int k = 0;
    while ((1 << k) < n) {
        for (int i = 0; i < n; i++) p[i] = (p[i] - (1 << k) + n) % n;
        count_sort(p, c);
        vector<int> c_new(n);
        c_new[p[0]] = 0;
        for (int i = 1; i < n; i++) {
            pii prev = {c[p[i - 1]], c[(p[i - 1] + (1 << k)) % n]};
            pii now = {c[p[i]], c[(p[i] + (1 << k)) % n]};
            if (prev == now) c_new[p[i]] = c_new[p[i - 1]];
            else c_new[p[i]] = c_new[p[i - 1]] + 1;
        }
        c = c_new;
        k++;
    }
    vector<int> lcp(n);
    k = 0;
    for (int i = 0; i < n - 1; i++) {
        int pi = c[i];
        int j = p[pi - 1];
        while (s[i + k] == s[j + k]) k++;
        lcp[pi] = k;
        k = max(k - 1, 0);
    }
    ll find;
    cin >> find;
    ll tot = 0;
    for (int i = 1; i < n; i++) {
        if (tot + n - p[i] - 1 - (!i ? 0 : lcp[i]) >= find) {
            // just print
            cout << s.substr(p[i], find - tot + lcp[i]) << '\n';
            break;
        }
        tot += n - p[i] - 1 - (!i ? 0 : lcp[i]);
    }
    return 0;
}
\end{lstlisting}

\subsection{Substring Order II}
\begin{lstlisting}
// Problem name: Substring Order II
// Problem Link: https://cses.fi/problemset/task/2109
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a string of length n. 
// If all of its substrings (not necessarily distinct) are ordered lexicographically, 
// what is the kth smallest of them?

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const ll INF = 2e18;
 
const int MAXB = 20;
 
struct suffix_array{
    const int alpha = 300;
 
    int c[MAXB][MAXN] , p[MAXN] , cn[MAXN] , pn[MAXN] , cnt[MAXN];
    string s;
 
    void suffix_ini(){
        memset(cnt,0,sizeof cnt);
        memset(c,-1,sizeof c);
 
        int n = s.size();
 
        for(int i = 0;i < n;i++) cnt[s[i]] ++;
        for(int i = 1;i < alpha;i++) cnt[i] += cnt[i - 1];
        for(int i = n - 1;i >= 0;i--) p[--cnt[s[i]]] = i;
 
        int cla = 0;
        c[0][p[0]] = 0;
 
        for(int i = 1;i < n;i++){
            if(s[p[i]] != s[p[i - 1]]) ++cla;
            c[0][p[i]] = cla;
        }
    }
 
    void suffix(){
        int n = s.size();
 
        for(int h = 0;(1 << h) < n;h++){
            for(int i = 0;i < n;i++){
                pn[i] = p[i] - (1 << h);
                if(pn[i] < 0) pn[i] += n;
            }
 
            memset(cnt,0,sizeof cnt);
 
            for(int i = 0;i < n;i++) cnt[c[h][pn[i]]] ++;
            for(int i = 0;i < n;i++) cnt[i] += cnt[i - 1];
            for(int i = n - 1;i >= 0;i--) p[--cnt[c[h][pn[i]]]] = pn[i];
 
            int cla = 0;
            cn[p[0]] = 0;
 
            for(int i = 1;i < n;i++){
                pair<int,int> cur = {c[h][p[i]],c[h][(p[i] + (1 << h)) % n]};
                pair<int,int> pre = {c[h][p[i - 1]],c[h][(p[i - 1] + (1 << h)) % n]};
 
                if(cur.first != pre.first || cur.second != pre.second) cla ++;
                cn[p[i]] = cla;
            }
 
            for(int i = 0;i < n;i++) c[h + 1][i] = cn[i];
        }
    }
 
    void sdo(string S){
        s = S;
        s += "&";
        suffix_ini();
        suffix();
    }
 
    int comp(int x,int y){
        int res = 0;
        int n = s.size();
 
        for(int i = MAXB - 1;i >= 0;i--){
            if(c[i][x] == -1 || c[i][y] == -1 || c[i][x] != c[i][y])
                continue;
 
            x += (1 << i);
            y += (1 << i);
            res += (1 << i);
 
            if(x >= n)
                x -= n;
            if(y >= n)
                y -= n;            
        }
 
        return res;
    }
 
    void printP(){
        cout << s << endl;
        for(int i = 0;i < s.size();i++){
            cout << p[i] << " ";
        }
        cout << endl;
    }
};
 
suffix_array sa;
ll pre[MAXN];
vector<int> v[MAXN];
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    string s;
    cin >> s;
    sa.sdo(s);
    int n = s.size();
    for (int i = 1; i <= n; i++) {
        pre[i] = pre[i - 1] + n - sa.p[i];
    }
    for (int i = 2; i <= n; i++) {
        int c = sa.comp(sa.p[i], sa.p[i - 1]);
        v[c].push_back(i - 1);
    }
    ll find;
    cin >> find;
    int l = 1, r = n, tam;
    for (int i = 0; i < n; i++) {
        
        // soh temos strings > i no range
        for (int x : v[i]) {
            if (x < l || x > r) continue;
        
            // processar os lcp´s iguais a i
            ll temos = pre[x] - pre[l - 1] - (x - l + 1ll) * i;
            if (find > temos) {
                find -= temos;
                l = x + 1;
            }
            else {
                r = x;
                break;
            }
        }
        find -= r - l + 1;
        tam = i + 1;
        if (find <= 0) break;
    }
    for (int i = 0; i < tam; i++) cout << s[sa.p[l] + i];
    cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Word Combinations}
\begin{lstlisting}
// Problem name: Word Combinations
// Problem Link: https://cses.fi/problemset/task/1731
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a string of length n and a dictionary containing k words. 
// In how many ways can you create the string using the words?

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 1000100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M = 1e9+7;
 
int dp[5050], trie[MAXN][26], quant[MAXN], fim[MAXN], cnt = 0, n;
string s;
 
void insert(string &a) {
	int node = 0;
	for (char c : a) {
		quant[node]++;
		if (!trie[node][c-'a']) trie[node][c-'a'] = ++cnt;
		node = trie[node][c - 'a'];
	}
	quant[node]++;
	fim[node]++;
}
 
int query(int x) {
	int ans = 0, node = 0;
	for (int i = x; i < n; i++) {
		if (!trie[node][s[i] - 'a']) return ans;
		node = trie[node][s[i] - 'a'];
		ans = (ans + 1ll * fim[node] * dp[i+1]) % M;
	}
	return ans;
}
 
int main () { _
	string aux;
	cin >> s;
	n = (int)s.size();
	int k;
	cin >> k;
	for (int i = 0; i < k; i++) {
		cin >> aux;
		insert(aux);
	}
	dp[n] = 1;
	for (int i = n-1; i >= 0; i--) 
		dp[i] = query(i);
	
	cout << dp[0] << '\n';
    return 0;
}
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%
%
% CSES - Tree Algorithms
%
%%%%%%%%%%%%%%%%%%%%

\section{CSES - Tree Algorithms}

\subsection{Company Queries I}
\begin{lstlisting}
// Problem name: Company Queries I
// Problem Link: https://cses.fi/problemset/task/1687
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int tab[MAXN][25];
vector<int> v[MAXN];
 
void dfs(int node) {
	for (int i = 1; i < 20; i++) {
		tab[node][i] = tab[tab[node][i-1]][i-1];
	}
	for (int x : v[node]) {
		dfs(x);
	}
}
 
int main () { _
	memset(tab, 0, sizeof(tab));
	int n, q;
	cin >> n >> q;
	for (int i = 2; i <= n; i++) {
		cin >> tab[i][0];
		v[tab[i][0]].pb(i);
	}
	dfs(1);
	for (int i = 0; i < q; i++) {
		int x, k;
		cin >> x >> k;
		for (int j = 0; j < 20; j++) {
			if (k & (1<<j)) x = tab[x][j];
		}
		cout << (!x ? -1 : x) << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{Company Queries II}
\begin{lstlisting}
// Problem name: Company Queries II
// Problem Link: https://cses.fi/problemset/task/1688
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int tab[MAXN][25], nivel[MAXN];
vector<int> v[MAXN];
 
int lca(int a, int b) {
	if (nivel[a] < nivel[b]) swap(a, b);
	for (int i = 19; i >= 0; i--) {
		if (nivel[a] - nivel[b] >= (1<<i)) {
			a = tab[a][i];
		}
	}
	if (a == b) return a;
	for (int i = 19; i >= 0; i--) {
		if (tab[a][i] != tab[b][i]) {
			a = tab[a][i];
			b = tab[b][i];
		}
	}
	return tab[a][0];
}
 
void dfs(int node) {
	for (int i = 1; i < 20; i++) {
		tab[node][i] = tab[tab[node][i-1]][i-1];
	}
	for (int x : v[node]) {
		nivel[x] = nivel[node]+1;
		dfs(x);
	}
}
 
int main () { _
	int n, q;
	cin >> n >> q;
	for (int i = 2; i <= n; i++) {
		cin >> tab[i][0];
		v[tab[i][0]].pb(i);
	}
	nivel[1] = 1;
	dfs(1);
	for (int i = 0; i < q; i++) {
		int a, b;
		cin >> a >> b;
		cout << lca(a, b) << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{Counting Paths}
\begin{lstlisting}
// Problem name: Counting Paths
// Problem Link: https://cses.fi/problemset/task/1136
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a tree consisting of n nodes, and m paths in the tree.
// Your task is to calculate for each node the number of paths containing that node.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN], a;
int tab[MAXN][25], nivel[MAXN], ans[MAXN];
 
void dfs(int node, int pai) {
    a.pb(node);
    tab[node][0] = pai;
    nivel[node] = 1 + nivel[pai];
    for (int i = 1; i <= 20; i++) {
        tab[node][i] = tab[tab[node][i-1]][i-1];
    }
    for (int x : v[node])
        if (x != pai)   
            dfs(x, node);
}
 
void dfs2(int node, int pai) {
    for (int x : v[node]) {
        if (x != pai) {
            dfs2(x, node);
            ans[node] += ans[x];
        }
    }
}
 
int lca(int a, int b) {
    if (nivel[a] < nivel[b]) swap(a, b);
 
    for (int i = 20; i >= 0; i--) {
        if (nivel[a] - nivel[b] >= (1<<i)) {
            a = tab[a][i];
        }
    }
 
    if (a == b) return a;
 
    for (int i = 20; i >= 0; i--) {
        if (tab[a][i] != tab[b][i]) {
            a = tab[a][i];
            b = tab[b][i];
        }
    }
    return tab[a][0];
}
 
int main () { _
    int n, m, a, b;
    cin >> n >> m;
    for (int i = 0; i < n-1; i++) {
        cin >> a >> b;
        v[a].pb(b);
        v[b].pb(a);
    }
    dfs(1, 0);
    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        ans[a]++;
        ans[b]++;
        int pater = lca(a, b);
        ans[pater]--;
        ans[tab[pater][0]]--;
    }
    dfs2(1, 0);
    for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
    cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{Distance Queries}
\begin{lstlisting}
// Problem name: Distance Queries
// Problem Link: https://cses.fi/problemset/task/1135
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
int tab[MAXN][25], nivel[MAXN];
vector<int> v[MAXN];
 
int lca(int a, int b) {
	if (nivel[a] < nivel[b]) swap(a, b);
	for (int i = 19; i >= 0; i--) {
		if (nivel[a] - nivel[b] >= (1<<i)) {
			a = tab[a][i];
		}
	}
	if (a == b) return a;
	for (int i = 19; i >= 0; i--) {
		if (tab[a][i] != tab[b][i]) {
			a = tab[a][i];
			b = tab[b][i];
		}
	}
	return tab[a][0];
}
 
void dfs(int node) {
	for (int i = 1; i < 20; i++) {
		tab[node][i] = tab[tab[node][i-1]][i-1];
	}
	for (int x : v[node]) {
		if (x != tab[node][0]) {
			nivel[x] = nivel[node]+1;
			tab[x][0] = node;
			dfs(x);
		}
	}
}
 
int main () { _
	int n, q, a, b;
	cin >> n >> q;
	for (int i = 0; i < n-1; i++) {
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	nivel[1] = 1;
	dfs(1);
	for (int i = 0; i < q; i++) {
		cin >> a >> b;
		cout << nivel[a] + nivel[b] - 2 * nivel[lca(a, b)] << '\n';
	}
	return 0;	
}
\end{lstlisting}

\subsection{Distinct Colors}
\begin{lstlisting}
// Problem name: Distinct Colors
// Problem Link: https://cses.fi/problemset/task/1139
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a rooted tree consisting of n nodes. 
// The nodes are numbered 1,2 ... n, and node 1 is the root. Each node has a color.
// Your task is to determine for each node the number of distinct colors in the subtree of the node.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN];
int c[MAXN], ans[MAXN];
set<int> s[MAXN];
 
void dfs(int node, int pai) {
    s[node].insert(c[node]);
    for (int x : v[node]) {
        if (x != pai) {
            dfs(x, node);
            if ((int)s[x].size() > (int)s[node].size()) swap(s[x], s[node]);
            for (int y : s[x]) s[node].insert(y);
        }
    }
    ans[node] = (int)s[node].size();
}
 
int main () { _
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> c[i];
    for (int i = 0; i < n-1; i++) {
        int a, b;
        cin >> a >> b;
        v[a].pb(b);
        v[b].pb(a);
    }
    dfs(1, 0);
    for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
    cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{Finding a Centroid}
\begin{lstlisting}
// Problem name: Finding a Centroid
// Problem Link: https://cses.fi/problemset/task/2079
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a tree of n nodes, your task is to find a centroid, 
// i.e., a node such that when it is appointed the root of the tree, 
// each subtree has at most floor(n / 2) nodes.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1e18
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
const int M1 = 1e9+7, M2 = 998244353;
 
vector<int> v[MAXN];
int dp[MAXN], valid[MAXN], n;
 
void dfs(int node, int pai) {
	dp[node] = 1;
	bool ok = true;
	for (int x : v[node]) {
		if (x != pai) {
			dfs(x, node);
			dp[node] += dp[x];
			ok &= (dp[x] <= (n/2));
		}
	}
	ok &= (n - dp[node] <= (n/2));
	valid[node] = ok;
}
 
int main() { _
	cin >> n;
	for (int i = 0; i < n-1; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	dfs(1, -1);
	for (int i = 1; i <= n; i++) 
		if (valid[i]) {
			cout << i << '\n';
			break;
		}
	return 0;
}
\end{lstlisting}

\subsection{Fixed-Length Paths I}
\begin{lstlisting}
// Problem name: Fixed-Length Paths I
// Problem Link: https://cses.fi/problemset/task/2080
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a tree of n nodes, your task is to count the number of distinct paths that consist of exactly k edges.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
vector<int> v[MAXN];
int sz[MAXN], cnt[MAXN]{1}, n, k, mx;
ll ans;
bool vis[MAXN];
 
int subtree(int node, int pai = 0) {
    sz[node] = 1;
    for (int x : v[node]) {
        if (!vis[x] && x != pai) {
            sz[node] += subtree(x, node);
        }
    }
    return sz[node];
}
 
int centroid(int node, int desired, int pai = 0) {
    for (int x : v[node]) {
        if (!vis[x] && x != pai && sz[x] > desired) {
            return centroid(x, desired, node);
        }
    }
    return node;
}
 
void get_cnt(int node, int pai, bool filling, int depth) {
    if (depth > k) return;
    mx = max(mx, depth);
    if (filling) {
        cnt[depth]++;
    }
    else {
        ans += cnt[k - depth];
    }
    for (int x : v[node]) {
        if (!vis[x] && x != pai) {
            get_cnt(x, node, filling, depth + 1);
        }
    }
}
 
void solve(int node) {
    int c = centroid(node, subtree(node) / 2);
    vis[c] = true;
    mx = 0;
    for (int x : v[c]) {
        if (!vis[x]) {
            get_cnt(x, c, false, 1);
            get_cnt(x, c, true, 1);
        }
    }
    fill(cnt + 1, cnt + mx + 1, 0);
    for (int x : v[c]) {
        if (!vis[x]) {
            solve(x);
        }
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> k;
    int a, b;
    for (int i = 0; i < n - 1; i++) {
        cin >> a >> b;
        v[a].push_back(b);
        v[b].push_back(a);
    }
    solve(1);
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Fixed-Length Paths II}
\begin{lstlisting}
// Problem name: Fixed-Length Paths II
// Problem Link: https://cses.fi/problemset/task/2081
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// Given a tree of n nodes, your task is to count the number of distinct paths that have at least k1 and at most k2 edges.

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;
 
vector<int> v[MAXN];
int sz[MAXN], n, k1, k2, mx;
ll ans, a[MAXN];
bool vis[MAXN];
 
void upd(int pos, int val) {
    for (pos++; pos < MAXN; pos += pos & -pos) a[pos] += val;
}
 
ll query(int l, int r) {
    ll ans = 0;
    for (; l; l -= l & -l) ans -= a[l];
    for (r++; r; r -= r & -r) ans += a[r];
    return ans;
}
 
int subtree(int node, int pai = 0) {
    sz[node] = 1;
    for (int x : v[node]) {
        if (!vis[x] && x != pai) {
            sz[node] += subtree(x, node);
        }
    }
    return sz[node];
}
 
int centroid(int node, int desired, int pai = 0) {
    for (int x : v[node]) {
        if (!vis[x] && x != pai && sz[x] >= desired) {
            return centroid(x, desired, node);
        }
    }
    return node;
}
 
void get_cnt(int node, int pai, bool filling, int depth) {
    if (depth > k2) return;
    mx = max(mx, depth);
    if (filling) {
        upd(depth, 1);
    }
    else {
        ans += query(max(0, k1 - depth), k2 - depth);
    }
    for (int x : v[node]) {
        if (!vis[x] && x != pai) {
            get_cnt(x, node, filling, depth + 1);
        }
    }
}
 
void solve(int node) {
    int c = centroid(node, subtree(node) / 2);
    vis[c] = true;
    mx = 0;
    for (int x : v[c]) {
        if (!vis[x]) {
            get_cnt(x, c, false, 1);
            get_cnt(x, c, true, 1);
        }
    }
    for (int i = 1; i <= mx; i++) upd(i, -query(i, i));
    for (int x : v[c]) {
        if (!vis[x]) {
            solve(x);
        }
    }
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> k1 >> k2;
    int a, b;
    for (int i = 0; i < n - 1; i++) {
        cin >> a >> b;
        v[a].push_back(b);
        v[b].push_back(a);
    }
    upd(0, 1);
    solve(1);
    cout << ans << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Path Queries}
\begin{lstlisting}
// Problem name: Path Queries
// Problem Link: https://cses.fi/problemset/task/1138
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a rooted tree consisting of n nodes. 
// The nodes are numbered 1,2,…,n, and node 1 is the root. Each node has a value.
// Your task is to process following types of queries:
//     change the value of node s to x
//     calculate the sum of values on the path from the root to node s

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN], a(1);
int sz[MAXN], pos[MAXN];
ll ini[MAXN], val[MAXN];
vector<ll> dif(MAXN);
 
void dfs(int node, int pai) {
    sz[node] = 1;
    ini[node] = ini[pai] + val[node];
    a.pb(node);
    pos[node] = (int)a.size()-1;
    for (int x : v[node]) {
        if (x != pai) {
            dfs(x, node);
            sz[node] += sz[x];
        }
    }
}
 
ll sum(int pos) {
    ll resp = 0;
    for (int i = pos; i > 0; i -= (i & -i)) {
        resp += dif[i];
    }
    return resp;
}
 
void upd(int pos, ll value) {
    for (int i = pos; i < MAXN; i += (i & -i)) {
        dif[i] += value;
    }
}
 
int main () { _
    int n, m, x, y, z;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> val[i];
    for (int i = 0; i < n-1; i++) {
        cin >> x >> y;
        v[x].pb(y);
        v[y].pb(x);
    }
    dfs(1, 0);
    for (int i = 0; i < m; i++) {
        cin >> x;
        if (x == 1) {
            cin >> y >> z;
            upd(pos[y], z - val[y]);
            upd(pos[y] + sz[y], val[y] - z);
            val[y] = z;
        }
        if (x == 2) {
            cin >> y;
            cout << ini[y] + sum(pos[y]) << '\n';
        }
    }
	return 0;	
}
\end{lstlisting}

\subsection{Path Queries II}
\begin{lstlisting}
// Problem name: Path Queries II
// Problem Link: https://cses.fi/problemset/task/2134
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a tree consisting of n nodes. The nodes are numbered 1,2,…,n. Each node has a value.
// Your task is to process following types of queries:
//     change the value of node s to x
//     find the maximum value on the path between nodes a and b.

#include <bits/stdc++.h>
    
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
    
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const int INF = 2e9;
 
vector<int> g[MAXN];
int pos[MAXN], sz[MAXN], pai[MAXN], peso[MAXN];
int h[MAXN], t, n;
int seg[2 * MAXN];
 
void build() {
	for (int i = n - 1; i; i--) seg[i] = max(seg[2*i], seg[2*i+1]);
}
 
int query(int a, int b) {
	int ret = 0;
	for(a += n, b += n; a <= b; ++a /= 2, --b /= 2) {
		if (a % 2 == 1) ret = max(ret, seg[a]);
		if (b % 2 == 0) ret = max(ret, seg[b]);
	}
	return ret;
}
 
void upd(int p, int x) {
	seg[p += n] = x;
	while (p /= 2) seg[p] = max(seg[2*p], seg[2*p+1]);
}
 
void dfs(int node, int p = -1) {
    sz[node] = 1;
    for (int& x : g[node]) {
        if (x == p) continue;
        dfs(x, node);
        sz[node] += sz[x];
        if (sz[x] > sz[g[node][0]] || g[node][0] == p) swap(x, g[node][0]);
    }
}
 
void build_hld(int k, int p = -1) {
    pos[k] = t++;
    seg[pos[k] + n] = peso[k];
    for (auto& i : g[k]) {
        if (i != p) {
            pai[i] = k;
            h[i] = (i == g[k][0] ? h[k] : i);
            build_hld(i, k); 
        }
    }
}
 
int query_path(int a, int b) {
    if (pos[a] < pos[b]) swap(a, b);
    int ans = 0;
    while (h[a] != h[b]) {
        if (pos[a] < pos[b]) swap(a, b);
        ans = max(ans, query(pos[h[a]], pos[a]));
        a = pai[h[a]];
    }
    if (pos[a] < pos[b]) swap(a, b);
    return max(ans, query(pos[b], pos[a]));
}
 
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> peso[i];
    int tipo, a, b;
    for (int i = 0; i < n - 1; i++) {
        cin >> a >> b;
        g[a].push_back(b);
        g[b].push_back(a);
    }
    dfs(1);
    h[1] = 1;
    build_hld(1);
    build();
    for (int i = 0; i < q; i++) {
        cin >> tipo >> a >> b;
        if (tipo == 1) {
            upd(pos[a], b);
        }
        else {
            cout << query_path(a, b) << '\n';
        }
    }
    return 0;
}
\end{lstlisting}

\subsection{Subordinates}
\begin{lstlisting}
// Problem name: Subordinates
// Problem Link: https://cses.fi/problemset/task/1674
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
vector<int> v[MAXN], dp(MAXN);
 
void dfs(int node) {
	for (int x : v[node]) {
		dfs(x);
		dp[node] += 1+dp[x];
	}
}
 
int main() { _
    int n, aux;
	cin >> n;
	for (int i = 2; i <= n; i++) {
		cin >> aux;
		v[aux].pb(i);
	}
	dfs(1);
	for (int i = 1; i <= n; i++) cout << dp[i] << ' ';
	cout << '\n';
    return 0;
}
\end{lstlisting}

\subsection{Subtree Queries}
\begin{lstlisting}
// Problem name: Subtree Queries
// Problem Link: https://cses.fi/problemset/task/1137
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a rooted tree consisting of n nodes. 
// The nodes are numbered 1,2,…,n, and node 1 is the root. Each node has a value.
// Your task is to process following types of queries:
//     change the value of node s to x
//     calculate the sum of values in the subtree of node s

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN], a(1, 0);
int val[MAXN], sz[MAXN], pos[MAXN];
ll t[MAXN];
 
ll sum(int pos) {
	ll resp = 0;
	for (int i = pos; i > 0; i -= (i & -i)) {
		resp += t[i];
	}
	return resp;
}
 
void upd(int pos, int val) {
	for (int i = pos; i < MAXN; i += (i & -i)) {
		t[i] += val;
	}
}
 
void dfs(int node, int pai) {
	sz[node] = 1;
	a.pb(node);
	pos[node] = (int)a.size()-1;
	upd(pos[node], val[node]);
	for (int x : v[node]) {
		if (x != pai) {
			dfs(x, node);
			sz[node] += sz[x];
		}
	}
}
 
int main () { _
	int n, q, x, y, z;
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> val[i];
	}
	for (int i = 0; i < n-1; i++) {
		cin >> x >> y;
		v[x].pb(y);
		v[y].pb(x);
	}
	dfs(1, 0);
	for (int i = 0; i < q; i++) {
		cin >> x;
		if (x == 1) {
			cin >> y >> z;
			upd(pos[y], z - val[y]);
			val[y] = z;
		}
		else {
			cin >> y;
			cout << sum(pos[y] + sz[y] - 1) - sum(pos[y]-1) << '\n';
		}
	}
	return 0;	
}
\end{lstlisting}

\subsection{Tree Diameter}
\begin{lstlisting}
// Problem name: Tree Diameter
// Problem Link: https://cses.fi/problemset/task/1131
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a tree consisting of n nodes.
// The diameter of a tree is the maximum distance between two nodes. 
// Your task is to determine the diameter of the tree.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9 + 7;
 
vector<int> v[MAXN];
int n;
 
int bfs(int node, bool flag) {
	queue<pii> q;
	vector<int> check(n+1);
	check[node] = 1;
	q.push({node, 0});
	int resp = 0, no;
	while (!q.empty()) {
		pii atual = q.front();
		q.pop();
		for (int x : v[atual.F]) {
			if (!check[x]) {
				check[x] = 1;
				q.push({x, atual.S+1});
				if (atual.S + 1 > resp) {
					resp = atual.S + 1;
					no = x;
				}
			}
		}
	}
	return (flag ? resp : no);
}
 
int main() { _
    int a, b;
	cin >> n;
	if (n == 1) cout << "0\n";
	else {
		for (int i = 0; i < n - 1; i++) {
			cin >> a >> b;
			v[a].pb(b);
			v[b].pb(a);
		}
		int no = bfs(1, false);
		cout << bfs(no, true) << '\n';
	}	
    return 0;
}
\end{lstlisting}

\subsection{Tree Distances I}
\begin{lstlisting}
// Problem name: Tree Distances I
// Problem Link: https://cses.fi/problemset/task/1132
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a tree consisting of n nodes.
// Your task is to determine for each node the maximum distance to another node.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN];
pair<pii, pii> dp[MAXN];
int ans[MAXN];
 
void dfs(int node, int pai) {
	for (int x : v[node]) {
		if (x != pai) {
			dfs(x, node);
			if (dp[x].F.F+1 > dp[node].F.F) {
				dp[node].S = dp[node].F;
				dp[node].F = {dp[x].F.F+1, x};
			}
			else if (dp[x].F.F+1 > dp[node].S.F) {
				dp[node].S = {dp[x].F.F+1, x};
			}
		}
	}
}
 
void dfs2(int node, int pai) {
	for (int x : v[node]) {
		if (x != pai) {
			if (dp[node].F.S == x) {
				ans[x] = max(dp[node].S.F, ans[node]) + 1;
			}
			else {
				ans[x] = max(dp[node].F.F, ans[node]) + 1;
			}
			dfs2(x, node);
		}
	}
}
 
int main () { _
	int n;
	cin >> n;
	for (int i = 0; i < n-1; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	dfs(1, 0);
	dfs2(1, 0);
	for (int i = 1; i <= n; i++) cout << max(dp[i].F.F, ans[i]) << ' ';
	cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{Tree Distances II}
\begin{lstlisting}
// Problem name: Tree Distances II
// Problem Link: https://cses.fi/problemset/task/1133
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

// You are given a tree consisting of n nodes.
// Your task is to determine for each node the sum of the distances from the node to all other nodes.

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN];
ll tam[MAXN], dp[MAXN], ans[MAXN], n;
 
void dfs(int node, int pai) {
	tam[node] = 1;
	for (int x : v[node]) {
		if (x != pai) {
			dfs(x, node);
			tam[node] += tam[x];
			dp[node] += tam[x] + dp[x];
		}
	}
}
 
void dfs2(int node, int pai) {
	ans[node] = ans[pai] + n - 2 * tam[node];
	for (int x : v[node]) 
		if (x != pai) dfs2(x, node);
}
 
int main () { _
	cin >> n;
	for (int i = 0; i < n-1; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	dfs(1, 0);
	ans[0] = dp[1] + 2*tam[1] - n;
	dfs2(1, 0);
	for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
	cout << '\n';
	return 0;	
}
\end{lstlisting}

\subsection{Tree Matching}
\begin{lstlisting}
// Problem name: Tree Matching
// Problem Link: https://cses.fi/problemset/task/1130
// Author: Bernardo Archegas (https://codeforces.com/profile/Ber)

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define MAXN 200100
#define INF 1000000001
#define pb push_back
#define F first
#define S second
 
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
const int M = 1e9+7;
 
vector<int> v[MAXN];
int dp[MAXN][2];
 
void dfs(int node, bool flag, int pai) {
	if (dp[node][flag] > -1) return;
	vector<int> zero, um;
	int ans = 0;
	for (int x : v[node]) {
		if (x != pai) {
			if (flag) {
				dfs(x, false, node);
				ans += dp[x][0];
			}
			else {
				dfs(x, false, node);
				dfs(x, true, node);
				zero.pb(dp[x][0]);
				um.pb(1 + dp[x][1]);
			}
		}
	}
	if (!flag) {
		int tam = (int)zero.size(), total = 0;
		for (int i = 0; i < tam; i++) {
			total += zero[i];
		}
		for (int i = 0; i < tam; i++) {
			ans = max(ans, um[i] + total - zero[i]);
		}
	}
	dp[node][flag] = ans;
}
 
int main () { _
	int n;
	cin >> n;
	for (int i = 0; i < n-1; i++) {
		int a, b;
		cin >> a >> b;
		v[a].pb(b);
		v[b].pb(a);
	}
	memset(dp, -1, sizeof(dp));
	dfs(1, 0, 0);
	cout << dp[1][0] << '\n';
	return 0;	
}
\end{lstlisting}

\pagebreak


%%%%%%%%%%%%%%%%%%%%
%
% Extra
%
%%%%%%%%%%%%%%%%%%%%

\section{Extra}

\subsection{template.cpp}
\begin{lstlisting}
// Template
// 

#include <bits/stdc++.h>
 
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using pll = pair<ll, ll>;
 
mt19937 rng((int) chrono::steady_clock::now().time_since_epoch().count());
    
const int MOD = 1e9 + 7;
const int MAXN = 2e5 + 5;
const ll INF = 2e18;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    return 0;
}
\end{lstlisting}

\subsection{__int128_t.cpp}
\begin{lstlisting}
// __int128_t
//
// nao pode ler nem printar
// pra ler use a to128
// pra printar use a tostring

__int128_t to128(string s) {
    __int128_t a = 0;
    __int128_t pot = 1;
    int n = s.size();
    for (int i = n - 1; i >= 0; i--, pot *= 10) {
        a += (s[i] - '0') * pot;
    }
    return a;
}
string tostring(__int128_t a) {
    string s;
    while (a) {
        s += (a % 10) + '0';
        a /= 10;
    }
    reverse(s.begin(), s.end());
    return (s.empty() ? "0" : s);
}
\end{lstlisting}

\subsection{bigint.cpp}
\begin{lstlisting}
// bigint
//

#include <bits/stdc++.h>
using namespace std;
 
typedef long long ll;
const int maxn = 1e2 + 14, lg = 15;

/*
  ######################################################################
  #######################   THE   BIG   INT   ##########################
*/
const int base = 1000000000;
const int base_digits = 9; 
struct bigint {
	vector<int> a;
	int sign;
	/*<arpa>*/
	int size(){
		if(a.empty())return 0;
		int ans=(a.size()-1)*base_digits;
		int ca=a.back();
		while(ca)
			ans++,ca/=10;
		return ans;
	}
	bigint operator ^(const bigint &v){
		bigint ans=1,a=*this,b=v;
		while(!b.isZero()){
			if(b%2)
				ans*=a;
			a*=a,b/=2;
		}
		return ans;
	}
	string to_string(){
		stringstream ss;
		ss << *this;
		string s;
		ss >> s;
		return s;
	}
	int sumof(){
		string s = to_string();
		int ans = 0;
		for(auto c : s)  ans += c - '0';
		return ans;
	}
	/*</arpa>*/
	bigint() :
		sign(1) {
	}
 
	bigint(long long v) {
		*this = v;
	}
 
	bigint(const string &s) {
		read(s);
	}
 
	void operator=(const bigint &v) {
		sign = v.sign;
		a = v.a;
	}
 
	void operator=(long long v) {
		sign = 1;
		a.clear();
		if (v < 0)
			sign = -1, v = -v;
		for (; v > 0; v = v / base)
			a.push_back(v % base);
	}
 
	bigint operator+(const bigint &v) const {
		if (sign == v.sign) {
			bigint res = v;
 
			for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {
				if (i == (int) res.a.size())
					res.a.push_back(0);
				res.a[i] += carry + (i < (int) a.size() ? a[i] : 0);
				carry = res.a[i] >= base;
				if (carry)
					res.a[i] -= base;
			}
			return res;
		}
		return *this - (-v);
	}
 
	bigint operator-(const bigint &v) const {
		if (sign == v.sign) {
			if (abs() >= v.abs()) {
				bigint res = *this;
				for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {
					res.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);
					carry = res.a[i] < 0;
					if (carry)
						res.a[i] += base;
				}
				res.trim();
				return res;
			}
			return -(v - *this);
		}
		return *this + (-v);
	}
 
	void operator*=(int v) {
		if (v < 0)
			sign = -sign, v = -v;
		for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {
			if (i == (int) a.size())
				a.push_back(0);
			long long cur = a[i] * (long long) v + carry;
			carry = (int) (cur / base);
			a[i] = (int) (cur % base);
			//asm("divl %%ecx" : "=a"(carry), "=d"(a[i]) : "A"(cur), "c"(base));
		}
		trim();
	}
 
	bigint operator*(int v) const {
		bigint res = *this;
		res *= v;
		return res;
	}
 
	void operator*=(long long v) {
		if (v < 0)
			sign = -sign, v = -v;
		if(v > base){
			*this = *this * (v / base) * base + *this * (v % base);
			return ;
		}
		for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {
			if (i == (int) a.size())
				a.push_back(0);
			long long cur = a[i] * (long long) v + carry;
			carry = (int) (cur / base);
			a[i] = (int) (cur % base);
			//asm("divl %%ecx" : "=a"(carry), "=d"(a[i]) : "A"(cur), "c"(base));
		}
		trim();
	}
 
	bigint operator*(long long v) const {
		bigint res = *this;
		res *= v;
		return res;
	}
 
	friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {
		int norm = base / (b1.a.back() + 1);
		bigint a = a1.abs() * norm;
		bigint b = b1.abs() * norm;
		bigint q, r;
		q.a.resize(a.a.size());
 
		for (int i = a.a.size() - 1; i >= 0; i--) {
			r *= base;
			r += a.a[i];
			int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];
			int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];
			int d = ((long long) base * s1 + s2) / b.a.back();
			r -= b * d;
			while (r < 0)
				r += b, --d;
			q.a[i] = d;
		}
 
		q.sign = a1.sign * b1.sign;
		r.sign = a1.sign;
		q.trim();
		r.trim();
		return make_pair(q, r / norm);
	}
 
	bigint operator/(const bigint &v) const {
		return divmod(*this, v).first;
	}
 
	bigint operator%(const bigint &v) const {
		return divmod(*this, v).second;
	}
 
	void operator/=(int v) {
		if (v < 0)
			sign = -sign, v = -v;
		for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {
			long long cur = a[i] + rem * (long long) base;
			a[i] = (int) (cur / v);
			rem = (int) (cur % v);
		}
		trim();
	}
 
	bigint operator/(int v) const {
		bigint res = *this;
		res /= v;
		return res;
	}
 
	int operator%(int v) const {
		if (v < 0)
			v = -v;
		int m = 0;
		for (int i = a.size() - 1; i >= 0; --i)
			m = (a[i] + m * (long long) base) % v;
		return m * sign;
	}
 
	void operator+=(const bigint &v) {
		*this = *this + v;
	}
	void operator-=(const bigint &v) {
		*this = *this - v;
	}
	void operator*=(const bigint &v) {
		*this = *this * v;
	}
	void operator/=(const bigint &v) {
		*this = *this / v;
	}
 
	bool operator<(const bigint &v) const {
		if (sign != v.sign)
			return sign < v.sign;
		if (a.size() != v.a.size())
			return a.size() * sign < v.a.size() * v.sign;
		for (int i = a.size() - 1; i >= 0; i--)
			if (a[i] != v.a[i])
				return a[i] * sign < v.a[i] * sign;
		return false;
	}
 
	bool operator>(const bigint &v) const {
		return v < *this;
	}
	bool operator<=(const bigint &v) const {
		return !(v < *this);
	}
	bool operator>=(const bigint &v) const {
		return !(*this < v);
	}
	bool operator==(const bigint &v) const {
		return !(*this < v) && !(v < *this);
	}
	bool operator!=(const bigint &v) const {
		return *this < v || v < *this;
	}
 
	void trim() {
		while (!a.empty() && !a.back())
			a.pop_back();
		if (a.empty())
			sign = 1;
	}
 
	bool isZero() const {
		return a.empty() || (a.size() == 1 && !a[0]);
	}
 
	bigint operator-() const {
		bigint res = *this;
		res.sign = -sign;
		return res;
	}
 
	bigint abs() const {
		bigint res = *this;
		res.sign *= res.sign;
		return res;
	}
 
	long long longValue() const {
		long long res = 0;
		for (int i = a.size() - 1; i >= 0; i--)
			res = res * base + a[i];
		return res * sign;
	}
 
	friend bigint gcd(const bigint &a, const bigint &b) {
		return b.isZero() ? a : gcd(b, a % b);
	}
	friend bigint lcm(const bigint &a, const bigint &b) {
		return a / gcd(a, b) * b;
	}
 
	void read(const string &s) {
		sign = 1;
		a.clear();
		int pos = 0;
		while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {
			if (s[pos] == '-')
				sign = -sign;
			++pos;
		}
		for (int i = s.size() - 1; i >= pos; i -= base_digits) {
			int x = 0;
			for (int j = max(pos, i - base_digits + 1); j <= i; j++)
				x = x * 10 + s[j] - '0';
			a.push_back(x);
		}
		trim();
	}
 
	friend istream& operator>>(istream &stream, bigint &v) {
		string s;
		stream >> s;
		v.read(s);
		return stream;
	}
 
	friend ostream& operator<<(ostream &stream, const bigint &v) {
		if (v.sign == -1)
			stream << '-';
		stream << (v.a.empty() ? 0 : v.a.back());
		for (int i = (int) v.a.size() - 2; i >= 0; --i)
			stream << setw(base_digits) << setfill('0') << v.a[i];
		return stream;
	}
 
	static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {
		vector<long long> p(max(old_digits, new_digits) + 1);
		p[0] = 1;
		for (int i = 1; i < (int) p.size(); i++)
			p[i] = p[i - 1] * 10;
		vector<int> res;
		long long cur = 0;
		int cur_digits = 0;
		for (int i = 0; i < (int) a.size(); i++) {
			cur += a[i] * p[cur_digits];
			cur_digits += old_digits;
			while (cur_digits >= new_digits) {
				res.push_back(int(cur % p[new_digits]));
				cur /= p[new_digits];
				cur_digits -= new_digits;
			}
		}
		res.push_back((int) cur);
		while (!res.empty() && !res.back())
			res.pop_back();
		return res;
	}
 
	typedef vector<long long> vll;
 
	static vll karatsubaMultiply(const vll &a, const vll &b) {
		int n = a.size();
		vll res(n + n);
		if (n <= 32) {
			for (int i = 0; i < n; i++)
				for (int j = 0; j < n; j++)
					res[i + j] += a[i] * b[j];
			return res;
		}
 
		int k = n >> 1;
		vll a1(a.begin(), a.begin() + k);
		vll a2(a.begin() + k, a.end());
		vll b1(b.begin(), b.begin() + k);
		vll b2(b.begin() + k, b.end());
 
		vll a1b1 = karatsubaMultiply(a1, b1);
		vll a2b2 = karatsubaMultiply(a2, b2);
 
		for (int i = 0; i < k; i++)
			a2[i] += a1[i];
		for (int i = 0; i < k; i++)
			b2[i] += b1[i];
 
		vll r = karatsubaMultiply(a2, b2);
		for (int i = 0; i < (int) a1b1.size(); i++)
			r[i] -= a1b1[i];
		for (int i = 0; i < (int) a2b2.size(); i++)
			r[i] -= a2b2[i];
 
		for (int i = 0; i < (int) r.size(); i++)
			res[i + k] += r[i];
		for (int i = 0; i < (int) a1b1.size(); i++)
			res[i] += a1b1[i];
		for (int i = 0; i < (int) a2b2.size(); i++)
			res[i + n] += a2b2[i];
		return res;
	}
 
	bigint operator*(const bigint &v) const {
		vector<int> a6 = convert_base(this->a, base_digits, 6);
		vector<int> b6 = convert_base(v.a, base_digits, 6);
		vll a(a6.begin(), a6.end());
		vll b(b6.begin(), b6.end());
		while (a.size() < b.size())
			a.push_back(0);
		while (b.size() < a.size())
			b.push_back(0);
		while (a.size() & (a.size() - 1))
			a.push_back(0), b.push_back(0);
		vll c = karatsubaMultiply(a, b);
		bigint res;
		res.sign = sign * v.sign;
		for (int i = 0, carry = 0; i < (int) c.size(); i++) {
			long long cur = c[i] + carry;
			res.a.push_back((int) (cur % 1000000));
			carry = (int) (cur / 1000000);
		}
		res.a = convert_base(res.a, 6, base_digits);
		res.trim();
		return res;
	}
};
/*
  #######################   THE   BIG   INT   ##########################
  ######################################################################
*/

int main(){
	ios::sync_with_stdio(0), cin.tie(0);
	bigint a = 10000;
	for (int i = 0; i < 1; i++) a = a * a;
	cout << a << '\n';
}
\end{lstlisting}

\subsection{bitset.cpp}
\begin{lstlisting}
// bitset
//
// deve ser inicializado com um valor constante
const int N = 50;
bitset<N> bit;
// pode receber uma string binaria ou um int
bit = "1010", bit = 13;
bit.count() // quantas posicoes acesas
bit.set() // acende tudo
bit.set(3) // acende a posicao 3
bit.reset() // apaga tudo
bit.reset(4) // apaga a posicao 4
bit.flip() // flipa tudo
bit.flip(2) // flipa a posicao 2
string a = bit.to_string() // transforma em string
bit &= bit
bit |= bit
bit ^= bit 
\end{lstlisting}

\subsection{mt19937_64.cpp}
\begin{lstlisting}
// mt19937_64
//
// Random generator for long long

mt19937_64 rng((ll) chrono::steady_clock::now().time_since_epoch().count());
ll rand = rng();
\end{lstlisting}

\subsection{timer.cpp}
\begin{lstlisting}
// timer
//
// timer T; T() -> retorna o tempo em ms desde que declarou
using namespace chrono;
struct timer : high_resolution_clock {
	const time_point start;
	timer(): start(now()) {}
	int operator()() {
		return duration_cast<milliseconds>(now() - start).count();
	}
};
\end{lstlisting}

\end{document}
